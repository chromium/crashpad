<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crashpad: crashpad::CrashpadClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="crashpad_doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Crashpad
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classcrashpad_1_1CrashpadClient.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcrashpad_1_1CrashpadClient-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">crashpad::CrashpadClient Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The primary interface for an application to have Crashpad monitor it for crashes.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;client/crashpad_client.h&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7366c56f2429a00f217be3c0d3165f5f" id="r_a7366c56f2429a00f217be3c0d3165f5f"><td class="memItemLeft" align="right" valign="top"><a id="a7366c56f2429a00f217be3c0d3165f5f" name="a7366c56f2429a00f217be3c0d3165f5f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FirstChanceHandler</b> = bool (*)(int, siginfo_t*, ucontext_t*)</td></tr>
<tr class="memdesc:a7366c56f2429a00f217be3c0d3165f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for custom handlers installed by clients. <br /></td></tr>
<tr class="separator:a7366c56f2429a00f217be3c0d3165f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee35d49868b4c5e4ca3e2ebae523b7f" id="r_a0ee35d49868b4c5e4ca3e2ebae523b7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ee35d49868b4c5e4ca3e2ebae523b7f">ProcessPendingReportsObservationCallback</a> = std::function&lt;void()&gt;</td></tr>
<tr class="memdesc:a0ee35d49868b4c5e4ca3e2ebae523b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observation callback invoked each time this object finishes processing and attempting to upload on-disk crash reports (whether or not the uploads succeeded).  <br /></td></tr>
<tr class="separator:a0ee35d49868b4c5e4ca3e2ebae523b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b2f0cb8ca7cda859a5de77c8150b0ed" id="r_a7b2f0cb8ca7cda859a5de77c8150b0ed"><td class="memItemLeft" align="right" valign="top"><a id="a7b2f0cb8ca7cda859a5de77c8150b0ed" name="a7b2f0cb8ca7cda859a5de77c8150b0ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CrashpadClient</b> (const <a class="el" href="classcrashpad_1_1CrashpadClient.html">CrashpadClient</a> &amp;)=delete</td></tr>
<tr class="separator:a7b2f0cb8ca7cda859a5de77c8150b0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82322072d17e3228f79798b6d433077f" id="r_a82322072d17e3228f79798b6d433077f"><td class="memItemLeft" align="right" valign="top"><a id="a82322072d17e3228f79798b6d433077f" name="a82322072d17e3228f79798b6d433077f"></a>
<a class="el" href="classcrashpad_1_1CrashpadClient.html">CrashpadClient</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcrashpad_1_1CrashpadClient.html">CrashpadClient</a> &amp;)=delete</td></tr>
<tr class="separator:a82322072d17e3228f79798b6d433077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a66dbad38f306d733bac8e42de02cf" id="r_a55a66dbad38f306d733bac8e42de02cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55a66dbad38f306d733bac8e42de02cf">StartHandler</a> (const base::FilePath &amp;handler, const base::FilePath &amp;database, const base::FilePath &amp;metrics_dir, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, const std::vector&lt; std::string &gt; &amp;arguments, bool restartable, bool asynchronous_start, const std::vector&lt; base::FilePath &gt; &amp;attachments={})</td></tr>
<tr class="memdesc:a55a66dbad38f306d733bac8e42de02cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a Crashpad handler process, performing any necessary handshake to configure it.  <br /></td></tr>
<tr class="separator:a55a66dbad38f306d733bac8e42de02cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d2d23831a27eef8fe99deb2d3119dc" id="r_ae2d2d23831a27eef8fe99deb2d3119dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d2d23831a27eef8fe99deb2d3119dc">SetHandlerSocket</a> (<a class="el" href="namespacecrashpad.html#a2d3a0ca2e9e37905b425f2cb1b428e7e">ScopedFileHandle</a> sock, pid_t pid)</td></tr>
<tr class="memdesc:ae2d2d23831a27eef8fe99deb2d3119dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the socket to a presumably-running Crashpad handler process which was started with <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a>.  <br /></td></tr>
<tr class="separator:ae2d2d23831a27eef8fe99deb2d3119dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ab4585d5703a3289a7f05df806575a" id="r_ac6ab4585d5703a3289a7f05df806575a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ab4585d5703a3289a7f05df806575a">StartJavaHandlerAtCrash</a> (const std::string &amp;class_name, const std::vector&lt; std::string &gt; *env, const base::FilePath &amp;database, const base::FilePath &amp;metrics_dir, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="memdesc:ac6ab4585d5703a3289a7f05df806575a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a signal handler to execute <code>/system/bin/app_process</code> and load a Java class in response to a crash.  <br /></td></tr>
<tr class="separator:ac6ab4585d5703a3289a7f05df806575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed0bd663b34b4bd5640cf6e42289034" id="r_a1ed0bd663b34b4bd5640cf6e42289034"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ed0bd663b34b4bd5640cf6e42289034">StartHandlerWithLinkerAtCrash</a> (const std::string &amp;handler_trampoline, const std::string &amp;handler_library, bool is_64_bit, const std::vector&lt; std::string &gt; *env, const base::FilePath &amp;database, const base::FilePath &amp;metrics_dir, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="memdesc:a1ed0bd663b34b4bd5640cf6e42289034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a signal handler to start a Crashpad handler process by loading it with <code>/system/bin/linker</code>.  <br /></td></tr>
<tr class="separator:a1ed0bd663b34b4bd5640cf6e42289034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf7a68a42e8108f8b648a4f19d52287" id="r_abcf7a68a42e8108f8b648a4f19d52287"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcf7a68a42e8108f8b648a4f19d52287">StartHandlerAtCrash</a> (const base::FilePath &amp;handler, const base::FilePath &amp;database, const base::FilePath &amp;metrics_dir, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, const std::vector&lt; std::string &gt; &amp;arguments, const std::vector&lt; base::FilePath &gt; &amp;attachments={})</td></tr>
<tr class="memdesc:abcf7a68a42e8108f8b648a4f19d52287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a signal handler to launch a handler process in reponse to a crash.  <br /></td></tr>
<tr class="separator:abcf7a68a42e8108f8b648a4f19d52287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f5ab794ec5e1e671e13c28e82fa5f5" id="r_a60f5ab794ec5e1e671e13c28e82fa5f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60f5ab794ec5e1e671e13c28e82fa5f5">SetUnhandledSignals</a> (const std::set&lt; int &gt; &amp;unhandled_signals)</td></tr>
<tr class="memdesc:a60f5ab794ec5e1e671e13c28e82fa5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures a set of signals that shouldn't have Crashpad signal handlers installed.  <br /></td></tr>
<tr class="separator:a60f5ab794ec5e1e671e13c28e82fa5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f34445eca859e6c0d1876e8e171c25" id="r_a89f34445eca859e6c0d1876e8e171c25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89f34445eca859e6c0d1876e8e171c25">SetHandlerMachService</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:a89f34445eca859e6c0d1876e8e171c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process’ crash handler to a Mach service registered with the bootstrap server.  <br /></td></tr>
<tr class="separator:a89f34445eca859e6c0d1876e8e171c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f93df3806aba3bd9886b12229550e12" id="r_a5f93df3806aba3bd9886b12229550e12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f93df3806aba3bd9886b12229550e12">SetHandlerMachPort</a> (base::apple::ScopedMachSendRight exception_port)</td></tr>
<tr class="memdesc:a5f93df3806aba3bd9886b12229550e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process’ crash handler to a Mach port.  <br /></td></tr>
<tr class="separator:a5f93df3806aba3bd9886b12229550e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dced7d1eccf3c64ae2db2ab0d4bcaa" id="r_a79dced7d1eccf3c64ae2db2ab0d4bcaa"><td class="memItemLeft" align="right" valign="top">base::apple::ScopedMachSendRight&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79dced7d1eccf3c64ae2db2ab0d4bcaa">GetHandlerMachPort</a> () const</td></tr>
<tr class="memdesc:a79dced7d1eccf3c64ae2db2ab0d4bcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a send right to the process’ crash handler Mach port.  <br /></td></tr>
<tr class="separator:a79dced7d1eccf3c64ae2db2ab0d4bcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1d5d38e9b4f5781e3821551dcc39d5" id="r_a9f1d5d38e9b4f5781e3821551dcc39d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f1d5d38e9b4f5781e3821551dcc39d5">SetHandlerIPCPipe</a> (const std::wstring &amp;ipc_pipe)</td></tr>
<tr class="memdesc:a9f1d5d38e9b4f5781e3821551dcc39d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the IPC pipe of a presumably-running Crashpad handler process which was started with <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> or by other compatible means and does an IPC message exchange to register this process with the handler. Crashes will be serviced once this method returns.  <br /></td></tr>
<tr class="separator:a9f1d5d38e9b4f5781e3821551dcc39d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc86d3d5bc6dcc9c9456e487f516c4d" id="r_a2fc86d3d5bc6dcc9c9456e487f516c4d"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fc86d3d5bc6dcc9c9456e487f516c4d">GetHandlerIPCPipe</a> () const</td></tr>
<tr class="memdesc:a2fc86d3d5bc6dcc9c9456e487f516c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the IPC pipe name used to register with the Crashpad handler.  <br /></td></tr>
<tr class="separator:a2fc86d3d5bc6dcc9c9456e487f516c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0377d4e93ac77453f57f3c1fcae09e14" id="r_a0377d4e93ac77453f57f3c1fcae09e14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0377d4e93ac77453f57f3c1fcae09e14">WaitForHandlerStart</a> (unsigned int timeout_ms)</td></tr>
<tr class="memdesc:a0377d4e93ac77453f57f3c1fcae09e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <code>asynchronous_start</code> is used with <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a>, this method can be used to block until the handler launch has been completed to retrieve status information.  <br /></td></tr>
<tr class="separator:a0377d4e93ac77453f57f3c1fcae09e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd0ae1ad706038c6f648be8d6469e15" id="r_a8cd0ae1ad706038c6f648be8d6469e15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cd0ae1ad706038c6f648be8d6469e15">RegisterWerModule</a> (const std::wstring &amp;full_path)</td></tr>
<tr class="memdesc:a8cd0ae1ad706038c6f648be8d6469e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a DLL using WerRegisterExceptionModule().  <br /></td></tr>
<tr class="separator:a8cd0ae1ad706038c6f648be8d6469e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7f78d5b29981a529a181734f14aa0bf5" id="r_a7f78d5b29981a529a181734f14aa0bf5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f78d5b29981a529a181734f14aa0bf5">GetHandlerSocket</a> (int *sock, pid_t *pid)</td></tr>
<tr class="memdesc:a7f78d5b29981a529a181734f14aa0bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the socket and process ID for the handler.  <br /></td></tr>
<tr class="separator:a7f78d5b29981a529a181734f14aa0bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5232b8b72daa59955aa599b57b3d70" id="r_a9f5232b8b72daa59955aa599b57b3d70"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f5232b8b72daa59955aa599b57b3d70">InitializeSignalStackForThread</a> ()</td></tr>
<tr class="memdesc:a9f5232b8b72daa59955aa599b57b3d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses <code>sigaltstack()</code> to allocate a signal stack for the calling thread.  <br /></td></tr>
<tr class="separator:a9f5232b8b72daa59955aa599b57b3d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec0698a7626fd82a3dc756f60d4e061" id="r_a5ec0698a7626fd82a3dc756f60d4e061"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ec0698a7626fd82a3dc756f60d4e061">StartJavaHandlerForClient</a> (const std::string &amp;class_name, const std::vector&lt; std::string &gt; *env, const base::FilePath &amp;database, const base::FilePath &amp;metrics_dir, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, const std::vector&lt; std::string &gt; &amp;arguments, int socket)</td></tr>
<tr class="memdesc:a5ec0698a7626fd82a3dc756f60d4e061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes <code>/system/bin/app_process</code> and loads a Java class.  <br /></td></tr>
<tr class="separator:a5ec0698a7626fd82a3dc756f60d4e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d9776fd32f37ef528fa1a3eeac78fc" id="r_a86d9776fd32f37ef528fa1a3eeac78fc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86d9776fd32f37ef528fa1a3eeac78fc">StartHandlerWithLinkerForClient</a> (const std::string &amp;handler_trampoline, const std::string &amp;handler_library, bool is_64_bit, const std::vector&lt; std::string &gt; *env, const base::FilePath &amp;database, const base::FilePath &amp;metrics_dir, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, const std::vector&lt; std::string &gt; &amp;arguments, int socket)</td></tr>
<tr class="memdesc:a86d9776fd32f37ef528fa1a3eeac78fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a Crashpad handler process with an initial client by loading it with <code>/system/bin/linker</code>.  <br /></td></tr>
<tr class="separator:a86d9776fd32f37ef528fa1a3eeac78fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b09eb149139d4df63a4bca3042ef67" id="r_a10b09eb149139d4df63a4bca3042ef67"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10b09eb149139d4df63a4bca3042ef67">StartHandlerForClient</a> (const base::FilePath &amp;handler, const base::FilePath &amp;database, const base::FilePath &amp;metrics_dir, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, const std::vector&lt; std::string &gt; &amp;arguments, int socket)</td></tr>
<tr class="memdesc:a10b09eb149139d4df63a4bca3042ef67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a handler process with an initial client.  <br /></td></tr>
<tr class="separator:a10b09eb149139d4df63a4bca3042ef67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab06443c04d43a2c0dac926275c5ad27" id="r_aab06443c04d43a2c0dac926275c5ad27"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab06443c04d43a2c0dac926275c5ad27">DumpWithoutCrash</a> (NativeCPUContext *context)</td></tr>
<tr class="memdesc:aab06443c04d43a2c0dac926275c5ad27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture a dump even though there hasn't been a crash.  <br /></td></tr>
<tr class="separator:aab06443c04d43a2c0dac926275c5ad27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c85fe7b91688420fad92df3914a4a74" id="r_a1c85fe7b91688420fad92df3914a4a74"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c85fe7b91688420fad92df3914a4a74">CrashWithoutDump</a> (const std::string &amp;message)</td></tr>
<tr class="memdesc:a1c85fe7b91688420fad92df3914a4a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables any installed crash handler, not including any <a class="el" href="#a7366c56f2429a00f217be3c0d3165f5f" title="The type for custom handlers installed by clients.">FirstChanceHandler</a> and crashes the current process.  <br /></td></tr>
<tr class="separator:a1c85fe7b91688420fad92df3914a4a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf4149291f643c8bfdb43ce8b6c55af" id="r_afbf4149291f643c8bfdb43ce8b6c55af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbf4149291f643c8bfdb43ce8b6c55af">SetFirstChanceExceptionHandler</a> (<a class="el" href="#a7366c56f2429a00f217be3c0d3165f5f">FirstChanceHandler</a> handler)</td></tr>
<tr class="memdesc:afbf4149291f643c8bfdb43ce8b6c55af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a custom crash signal handler which runs before the currently installed Crashpad handler.  <br /></td></tr>
<tr class="separator:afbf4149291f643c8bfdb43ce8b6c55af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be35922505fe7ac6c7e895110729938" id="r_a5be35922505fe7ac6c7e895110729938"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5be35922505fe7ac6c7e895110729938">SetLastChanceExceptionHandler</a> (bool(*handler)(int, siginfo_t *, ucontext_t *))</td></tr>
<tr class="memdesc:a5be35922505fe7ac6c7e895110729938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a custom crash signal handler which runs after the currently installed Crashpad handler.  <br /></td></tr>
<tr class="separator:a5be35922505fe7ac6c7e895110729938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca367c1dc74adaa43162498c5a4c4a1" id="r_abca367c1dc74adaa43162498c5a4c4a1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abca367c1dc74adaa43162498c5a4c4a1">StartCrashpadInProcessHandler</a> (const base::FilePath &amp;database, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, <a class="el" href="#a0ee35d49868b4c5e4ca3e2ebae523b7f">ProcessPendingReportsObservationCallback</a> callback)</td></tr>
<tr class="memdesc:abca367c1dc74adaa43162498c5a4c4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the process to direct its crashes to the iOS in-process Crashpad handler.  <br /></td></tr>
<tr class="separator:abca367c1dc74adaa43162498c5a4c4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeadfc2c5c3a59a713b5e66863f85948" id="r_abeadfc2c5c3a59a713b5e66863f85948"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeadfc2c5c3a59a713b5e66863f85948">ProcessIntermediateDumps</a> (const std::map&lt; std::string, std::string &gt; &amp;annotations={})</td></tr>
<tr class="memdesc:abeadfc2c5c3a59a713b5e66863f85948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler convert intermediate dumps into minidumps and trigger an upload if possible.  <br /></td></tr>
<tr class="separator:abeadfc2c5c3a59a713b5e66863f85948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b2694c9ac6c03337375fd78ea0f606" id="r_a62b2694c9ac6c03337375fd78ea0f606"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62b2694c9ac6c03337375fd78ea0f606">ProcessIntermediateDump</a> (const base::FilePath &amp;file, const std::map&lt; std::string, std::string &gt; &amp;annotations={})</td></tr>
<tr class="memdesc:a62b2694c9ac6c03337375fd78ea0f606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler convert a single intermediate dump at <em class="arg">file</em> generated by DumpWithoutCrashAndDeferProcessingAtPath into a minidump and trigger an upload if possible.  <br /></td></tr>
<tr class="separator:a62b2694c9ac6c03337375fd78ea0f606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ad055cbc0559637638c1827eb98813" id="r_a74ad055cbc0559637638c1827eb98813"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74ad055cbc0559637638c1827eb98813">StartProcessingPendingReports</a> (<a class="el" href="namespacecrashpad.html#a8acaf90af42afce7536ea74c1cf32258">UploadBehavior</a> upload_behavior=<a class="el" href="namespacecrashpad.html#a8acaf90af42afce7536ea74c1cf32258a3827652cb700b6d3d2cdf18d69c52979">UploadBehavior::kUploadWhenAppIsActive</a>)</td></tr>
<tr class="memdesc:a74ad055cbc0559637638c1827eb98813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler begin in-process uploading of any pending reports.  <br /></td></tr>
<tr class="separator:a74ad055cbc0559637638c1827eb98813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d9ce224c47b7c14fc57bccb9b08204" id="r_a11d9ce224c47b7c14fc57bccb9b08204"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d9ce224c47b7c14fc57bccb9b08204">DumpWithoutCrash</a> (NativeCPUContext *context)</td></tr>
<tr class="memdesc:a11d9ce224c47b7c14fc57bccb9b08204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture an intermediate dump even though there hasn't been a crash. The intermediate dump will be converted to a mindump immediately. If <a class="el" href="#a74ad055cbc0559637638c1827eb98813" title="Requests that the handler begin in-process uploading of any pending reports.">StartProcessingPendingReports()</a> has been called, this will also trigger an upload.  <br /></td></tr>
<tr class="separator:a11d9ce224c47b7c14fc57bccb9b08204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab68a45c6124a96c4881198dee39661a" id="r_aab68a45c6124a96c4881198dee39661a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab68a45c6124a96c4881198dee39661a">DumpWithoutCrashAndDeferProcessing</a> (NativeCPUContext *context)</td></tr>
<tr class="memdesc:aab68a45c6124a96c4881198dee39661a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture an intermediate dump even though there hasn't been a crash. The intermediate dump will not be converted to a mindump until <a class="el" href="#abeadfc2c5c3a59a713b5e66863f85948" title="Requests that the handler convert intermediate dumps into minidumps and trigger an upload if possible...">ProcessIntermediateDumps()</a> is called.  <br /></td></tr>
<tr class="separator:aab68a45c6124a96c4881198dee39661a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac572c522f926f426cc7a86b759b0147a" id="r_ac572c522f926f426cc7a86b759b0147a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac572c522f926f426cc7a86b759b0147a">DumpWithoutCrashAndDeferProcessingAtPath</a> (NativeCPUContext *context, const base::FilePath path)</td></tr>
<tr class="memdesc:ac572c522f926f426cc7a86b759b0147a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture an intermediate dump and store it in path, even though there hasn't been a crash. The intermediate dump will not be converted to a mindump until <a class="el" href="#a62b2694c9ac6c03337375fd78ea0f606" title="Requests that the handler convert a single intermediate dump at file generated by DumpWithoutCrashAnd...">ProcessIntermediateDump()</a> is called.  <br /></td></tr>
<tr class="separator:ac572c522f926f426cc7a86b759b0147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6018afb6648d77f74f7cc28231db2982" id="r_a6018afb6648d77f74f7cc28231db2982"><td class="memItemLeft" align="right" valign="top"><a id="a6018afb6648d77f74f7cc28231db2982" name="a6018afb6648d77f74f7cc28231db2982"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetForTesting</b> ()</td></tr>
<tr class="memdesc:a6018afb6648d77f74f7cc28231db2982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the Crashpad client. Intended to be used by tests so multiple Crashpad clients can be started and stopped. Not expected to be used in a shipping application. <br /></td></tr>
<tr class="separator:a6018afb6648d77f74f7cc28231db2982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09fcf86b403def5852944e9f2c98438" id="r_ab09fcf86b403def5852944e9f2c98438"><td class="memItemLeft" align="right" valign="top"><a id="ab09fcf86b403def5852944e9f2c98438" name="ab09fcf86b403def5852944e9f2c98438"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMachExceptionCallbackForTesting</b> (void(*callback)())</td></tr>
<tr class="memdesc:ab09fcf86b403def5852944e9f2c98438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject a callback into Mach handling. Intended to be used by tests to trigger a reentrant exception. <br /></td></tr>
<tr class="separator:ab09fcf86b403def5852944e9f2c98438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724a19bda2c7961912b38dd5f956672c" id="r_a724a19bda2c7961912b38dd5f956672c"><td class="memItemLeft" align="right" valign="top"><a id="a724a19bda2c7961912b38dd5f956672c" name="a724a19bda2c7961912b38dd5f956672c"></a>
static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetThreadIdForTesting</b> ()</td></tr>
<tr class="memdesc:a724a19bda2c7961912b38dd5f956672c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thread id of the Mach exception thread, used by tests. <br /></td></tr>
<tr class="separator:a724a19bda2c7961912b38dd5f956672c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac211aa3a8cf278eb10f4058a7776fb" id="r_a8ac211aa3a8cf278eb10f4058a7776fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ac211aa3a8cf278eb10f4058a7776fb">DumpWithoutCrash</a> (const CONTEXT &amp;context)</td></tr>
<tr class="memdesc:a8ac211aa3a8cf278eb10f4058a7776fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture a dump even though there hasn't been a crash.  <br /></td></tr>
<tr class="separator:a8ac211aa3a8cf278eb10f4058a7776fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d1fa142b0bf7094fc66fef3135a64a" id="r_a87d1fa142b0bf7094fc66fef3135a64a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87d1fa142b0bf7094fc66fef3135a64a">DumpAndCrash</a> (EXCEPTION_POINTERS *exception_pointers)</td></tr>
<tr class="memdesc:a87d1fa142b0bf7094fc66fef3135a64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture a dump using the given <em class="arg">exception_pointers</em> to get the <code>EXCEPTION_RECORD</code> and <code>CONTEXT</code>.  <br /></td></tr>
<tr class="separator:a87d1fa142b0bf7094fc66fef3135a64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a46ba3d17822a7025b526980564d7e" id="r_a35a46ba3d17822a7025b526980564d7e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35a46ba3d17822a7025b526980564d7e">DumpAndCrashTargetProcess</a> (HANDLE process, HANDLE blame_thread, DWORD exception_code)</td></tr>
<tr class="memdesc:a35a46ba3d17822a7025b526980564d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture a dump of a different process.  <br /></td></tr>
<tr class="separator:a35a46ba3d17822a7025b526980564d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6a1e62d90a67db782664b1fe5a952f" id="r_a1a6a1e62d90a67db782664b1fe5a952f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a6a1e62d90a67db782664b1fe5a952f">UseSystemDefaultHandler</a> ()</td></tr>
<tr class="memdesc:a1a6a1e62d90a67db782664b1fe5a952f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the process to direct its crashes to the default handler for the operating system.  <br /></td></tr>
<tr class="separator:a1a6a1e62d90a67db782664b1fe5a952f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The primary interface for an application to have Crashpad monitor it for crashes. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0ee35d49868b4c5e4ca3e2ebae523b7f" name="a0ee35d49868b4c5e4ca3e2ebae523b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee35d49868b4c5e4ca3e2ebae523b7f">&#9670;&#160;</a></span>ProcessPendingReportsObservationCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0ee35d49868b4c5e4ca3e2ebae523b7f">crashpad::CrashpadClient::ProcessPendingReportsObservationCallback</a> = std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Observation callback invoked each time this object finishes processing and attempting to upload on-disk crash reports (whether or not the uploads succeeded). </p>
<p>This callback is copied into this object. Any references or pointers inside must outlive this object.</p>
<p>The callback might be invoked on a background thread, so clients must synchronize appropriately. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1c85fe7b91688420fad92df3914a4a74" name="a1c85fe7b91688420fad92df3914a4a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c85fe7b91688420fad92df3914a4a74">&#9670;&#160;</a></span>CrashWithoutDump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::CrashWithoutDump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables any installed crash handler, not including any <a class="el" href="#a7366c56f2429a00f217be3c0d3165f5f" title="The type for custom handlers installed by clients.">FirstChanceHandler</a> and crashes the current process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>A message to be logged before crashing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87d1fa142b0bf7094fc66fef3135a64a" name="a87d1fa142b0bf7094fc66fef3135a64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d1fa142b0bf7094fc66fef3135a64a">&#9670;&#160;</a></span>DumpAndCrash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::DumpAndCrash </td>
          <td>(</td>
          <td class="paramtype">EXCEPTION_POINTERS *</td>          <td class="paramname"><span class="paramname"><em>exception_pointers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler capture a dump using the given <em class="arg">exception_pointers</em> to get the <code>EXCEPTION_RECORD</code> and <code>CONTEXT</code>. </p>
<p>This function is not necessary in general usage as an unhandled exception filter is installed by <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> or <a class="el" href="#a9f1d5d38e9b4f5781e3821551dcc39d5" title="Sets the IPC pipe of a presumably-running Crashpad handler process which was started with StartHandle...">SetHandlerIPCPipe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_pointers</td><td>An <code>EXCEPTION_POINTERS</code>, as would generally passed to an unhandled exception filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35a46ba3d17822a7025b526980564d7e" name="a35a46ba3d17822a7025b526980564d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a46ba3d17822a7025b526980564d7e">&#9670;&#160;</a></span>DumpAndCrashTargetProcess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::DumpAndCrashTargetProcess </td>
          <td>(</td>
          <td class="paramtype">HANDLE</td>          <td class="paramname"><span class="paramname"><em>process</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE</td>          <td class="paramname"><span class="paramname"><em>blame_thread</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>exception_code</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler capture a dump of a different process. </p>
<p>The target process must be an already-registered Crashpad client. An exception will be triggered in the target process, and the regular dump mechanism used. This function will block until the exception in the target process has been handled by the Crashpad handler.</p>
<p>This function is unavailable when running on Windows XP and will return <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">process</td><td>A <code>HANDLE</code> identifying the process to be dumped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blame_thread</td><td>If non-null, a <code>HANDLE</code> valid in the caller's process, referring to a thread in the target process. If this is supplied, instead of the exception referring to the location where the exception was injected, an exception record will be fabricated that refers to the current location of the given thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_code</td><td>If <em class="arg">blame_thread</em> is non-null, this will be used as the exception code in the exception record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the exception was triggered successfully. </dd></dl>

</div>
</div>
<a id="a8ac211aa3a8cf278eb10f4058a7776fb" name="a8ac211aa3a8cf278eb10f4058a7776fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac211aa3a8cf278eb10f4058a7776fb">&#9670;&#160;</a></span>DumpWithoutCrash() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::DumpWithoutCrash </td>
          <td>(</td>
          <td class="paramtype">const CONTEXT &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler capture a dump even though there hasn't been a crash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A <code>CONTEXT</code>, generally captured by <a class="el" href="namespacecrashpad.html#ac25486c6b4c38fc7c7868e978094edcf" title="Saves the CPU context.">CaptureContext()</a> or similar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab06443c04d43a2c0dac926275c5ad27" name="aab06443c04d43a2c0dac926275c5ad27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab06443c04d43a2c0dac926275c5ad27">&#9670;&#160;</a></span>DumpWithoutCrash() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::DumpWithoutCrash </td>
          <td>(</td>
          <td class="paramtype">NativeCPUContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler capture a dump even though there hasn't been a crash. </p>
<p>A handler must have already been installed before calling this method.</p>
<p>TODO(jperaza): Floating point information in the context is zeroed out until <a class="el" href="namespacecrashpad.html#ac25486c6b4c38fc7c7868e978094edcf" title="Saves the CPU context.">CaptureContext()</a> supports collecting that information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A NativeCPUContext, generally captured by <a class="el" href="namespacecrashpad.html#ac25486c6b4c38fc7c7868e978094edcf" title="Saves the CPU context.">CaptureContext()</a> or similar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11d9ce224c47b7c14fc57bccb9b08204" name="a11d9ce224c47b7c14fc57bccb9b08204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d9ce224c47b7c14fc57bccb9b08204">&#9670;&#160;</a></span>DumpWithoutCrash() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void crashpad::CrashpadClient::DumpWithoutCrash </td>
          <td>(</td>
          <td class="paramtype">NativeCPUContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler capture an intermediate dump even though there hasn't been a crash. The intermediate dump will be converted to a mindump immediately. If <a class="el" href="#a74ad055cbc0559637638c1827eb98813" title="Requests that the handler begin in-process uploading of any pending reports.">StartProcessingPendingReports()</a> has been called, this will also trigger an upload. </p>
<p>For internal use only. Clients should use <a class="el" href="simulate__crash__ios_8h.html#a0ac6f4df5ed356f04dd12be3f07f9ed2" title="Captures the CPU context and creates a minidump dump without an exception. The minidump will immediat...">CRASHPAD_SIMULATE_CRASH()</a>.</p>
<p>A handler must have already been installed before calling this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A NativeCPUContext, generally captured by <a class="el" href="namespacecrashpad.html#ac25486c6b4c38fc7c7868e978094edcf" title="Saves the CPU context.">CaptureContext()</a> or similar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab68a45c6124a96c4881198dee39661a" name="aab68a45c6124a96c4881198dee39661a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab68a45c6124a96c4881198dee39661a">&#9670;&#160;</a></span>DumpWithoutCrashAndDeferProcessing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::DumpWithoutCrashAndDeferProcessing </td>
          <td>(</td>
          <td class="paramtype">NativeCPUContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler capture an intermediate dump even though there hasn't been a crash. The intermediate dump will not be converted to a mindump until <a class="el" href="#abeadfc2c5c3a59a713b5e66863f85948" title="Requests that the handler convert intermediate dumps into minidumps and trigger an upload if possible...">ProcessIntermediateDumps()</a> is called. </p>
<p>For internal use only. Clients should use <a class="el" href="simulate__crash__ios_8h.html#a6a083b3827f348eb8fab8112d6f3d831" title="Captures the CPU context and captures an intermediate dump without an exception. Does not convert the...">CRASHPAD_SIMULATE_CRASH_AND_DEFER_PROCESSING()</a>.</p>
<p>A handler must have already been installed before calling this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A NativeCPUContext, generally captured by <a class="el" href="namespacecrashpad.html#ac25486c6b4c38fc7c7868e978094edcf" title="Saves the CPU context.">CaptureContext()</a> or similar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac572c522f926f426cc7a86b759b0147a" name="ac572c522f926f426cc7a86b759b0147a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac572c522f926f426cc7a86b759b0147a">&#9670;&#160;</a></span>DumpWithoutCrashAndDeferProcessingAtPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::DumpWithoutCrashAndDeferProcessingAtPath </td>
          <td>(</td>
          <td class="paramtype">NativeCPUContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath</td>          <td class="paramname"><span class="paramname"><em>path</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler capture an intermediate dump and store it in path, even though there hasn't been a crash. The intermediate dump will not be converted to a mindump until <a class="el" href="#a62b2694c9ac6c03337375fd78ea0f606" title="Requests that the handler convert a single intermediate dump at file generated by DumpWithoutCrashAnd...">ProcessIntermediateDump()</a> is called. </p>
<p>For internal use only. Clients should use CRASHPAD_SIMULATE_CRASH_AND_DEFER_PROCESSING_AT_PATH().</p>
<p>A handler must have already been installed before calling this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A NativeCPUContext, generally captured by <a class="el" href="namespacecrashpad.html#ac25486c6b4c38fc7c7868e978094edcf" title="Saves the CPU context.">CaptureContext()</a> or similar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path for writing the intermediate dump. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fc86d3d5bc6dcc9c9456e487f516c4d" name="a2fc86d3d5bc6dcc9c9456e487f516c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc86d3d5bc6dcc9c9456e487f516c4d">&#9670;&#160;</a></span>GetHandlerIPCPipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring crashpad::CrashpadClient::GetHandlerIPCPipe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the IPC pipe name used to register with the Crashpad handler. </p>
<p>This method is only defined on Windows.</p>
<p>This method retrieves the IPC pipe name set by <a class="el" href="#a9f1d5d38e9b4f5781e3821551dcc39d5" title="Sets the IPC pipe of a presumably-running Crashpad handler process which was started with StartHandle...">SetHandlerIPCPipe()</a>, or a suitable IPC pipe name chosen by <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a>. It must only be called after a successful call to one of those methods. It is intended to be used to obtain the IPC pipe name so that it may be passed to other processes, so that they may register with an existing Crashpad handler by calling <a class="el" href="#a9f1d5d38e9b4f5781e3821551dcc39d5" title="Sets the IPC pipe of a presumably-running Crashpad handler process which was started with StartHandle...">SetHandlerIPCPipe()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The full name of the crash handler IPC pipe, a string of the form <code>&amp;quot;\\.\pipe\NAME&amp;quot;</code>. </dd></dl>

</div>
</div>
<a id="a79dced7d1eccf3c64ae2db2ab0d4bcaa" name="a79dced7d1eccf3c64ae2db2ab0d4bcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79dced7d1eccf3c64ae2db2ab0d4bcaa">&#9670;&#160;</a></span>GetHandlerMachPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">base::apple::ScopedMachSendRight crashpad::CrashpadClient::GetHandlerMachPort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a send right to the process’ crash handler Mach port. </p>
<p>This method is only defined on macOS.</p>
<p>This method can be used to obtain the crash handler Mach port when a Crashpad client process wishes to provide a send right to this port to another process. The IPC mechanism used to convey the right is under the application’s control. If the other process wishes to become a client of the same crash handler, it can provide the transferred right to <a class="el" href="#a5f93df3806aba3bd9886b12229550e12" title="Sets the process’ crash handler to a Mach port.">SetHandlerMachPort()</a>.</p>
<p>See <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> for more detail on how the port and handler are configured.</p>
<dl class="section return"><dt>Returns</dt><dd>The Mach port set by <a class="el" href="#a5f93df3806aba3bd9886b12229550e12" title="Sets the process’ crash handler to a Mach port.">SetHandlerMachPort()</a>, possibly indirectly by a call to another method such as <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> or <a class="el" href="#a89f34445eca859e6c0d1876e8e171c25" title="Sets the process’ crash handler to a Mach service registered with the bootstrap server.">SetHandlerMachService()</a>. This method must only be called after a successful call to one of those methods. <code>MACH_PORT_NULL</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a7f78d5b29981a529a181734f14aa0bf5" name="a7f78d5b29981a529a181734f14aa0bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f78d5b29981a529a181734f14aa0bf5">&#9670;&#160;</a></span>GetHandlerSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool crashpad::CrashpadClient::GetHandlerSocket </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t *</td>          <td class="paramname"><span class="paramname"><em>pid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the socket and process ID for the handler. </p>
<p><code><a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a></code> must have successfully been called before calling this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sock</td><td>The socket connected to the handler, if not <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pid</td><td>The handler's process ID, if not <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise <code>false</code> with a message logged. </dd></dl>

</div>
</div>
<a id="a9f5232b8b72daa59955aa599b57b3d70" name="a9f5232b8b72daa59955aa599b57b3d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5232b8b72daa59955aa599b57b3d70">&#9670;&#160;</a></span>InitializeSignalStackForThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool crashpad::CrashpadClient::InitializeSignalStackForThread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses <code>sigaltstack()</code> to allocate a signal stack for the calling thread. </p>
<p>This method allocates an alternate stack to handle signals delivered to the calling thread and should be called early in the lifetime of each thread. Installing an alternate stack allows signals to be delivered in the event that the call stack's stack pointer points to invalid memory, as in the case of stack overflow.</p>
<p>This method is called automatically by <a class="el" href="#ae2d2d23831a27eef8fe99deb2d3119dc" title="Sets the socket to a presumably-running Crashpad handler process which was started with StartHandler(...">SetHandlerSocket()</a> and the various <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> methods. It is harmless to call multiple times. A new signal stack will be allocated only if there is no existing stack or the existing stack is too small. The stack will be automatically freed when the thread exits.</p>
<p>An application might choose to diligently call this method from the start routine for each thread, call it from a <code>pthread_create()</code> wrapper which the application provides, or link the provided "client:pthread_create" target.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise <code>false</code> with a message logged. </dd></dl>

</div>
</div>
<a id="a62b2694c9ac6c03337375fd78ea0f606" name="a62b2694c9ac6c03337375fd78ea0f606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b2694c9ac6c03337375fd78ea0f606">&#9670;&#160;</a></span>ProcessIntermediateDump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::ProcessIntermediateDump </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler convert a single intermediate dump at <em class="arg">file</em> generated by DumpWithoutCrashAndDeferProcessingAtPath into a minidump and trigger an upload if possible. </p>
<p>A handler must have already been installed before calling this method. This method should be called when an application is ready to start processing previously created intermediate dumps. Processing will block, so this should not be called on the main UI thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The intermediate dump to process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. Useful when adding crash annotations detected on the next run after a crash but before upload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abeadfc2c5c3a59a713b5e66863f85948" name="abeadfc2c5c3a59a713b5e66863f85948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeadfc2c5c3a59a713b5e66863f85948">&#9670;&#160;</a></span>ProcessIntermediateDumps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::ProcessIntermediateDumps </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler convert intermediate dumps into minidumps and trigger an upload if possible. </p>
<p>A handler must have already been installed before calling this method. This method should be called when an application is ready to start processing previously created intermediate dumps. Processing will block, so this should not be called on the main UI thread. No intermediate dumps will be processed until this method is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. Useful when adding crash annotations detected on the next run after a crash but before upload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cd0ae1ad706038c6f648be8d6469e15" name="a8cd0ae1ad706038c6f648be8d6469e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd0ae1ad706038c6f648be8d6469e15">&#9670;&#160;</a></span>RegisterWerModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::RegisterWerModule </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>full_path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a DLL using WerRegisterExceptionModule(). </p>
<p>This method should only be called after a successful call to <a class="el" href="#a9f1d5d38e9b4f5781e3821551dcc39d5" title="Sets the IPC pipe of a presumably-running Crashpad handler process which was started with StartHandle...">SetHandlerIPCPipe()</a> or <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a>. The registration is valid for the lifetime of this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">full_path</td><td>The full path to the DLL that will be registered. The DLL path should also be set in an appropriate <code>Windows Error Reporting</code> registry key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the DLL was registered. Note: Windows just stashes the path somewhere so this returns <code>true</code> even if the DLL is not yet set in an appropriate registry key, or does not exist. </dd></dl>

</div>
</div>
<a id="afbf4149291f643c8bfdb43ce8b6c55af" name="afbf4149291f643c8bfdb43ce8b6c55af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf4149291f643c8bfdb43ce8b6c55af">&#9670;&#160;</a></span>SetFirstChanceExceptionHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::SetFirstChanceExceptionHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7366c56f2429a00f217be3c0d3165f5f">FirstChanceHandler</a></td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Installs a custom crash signal handler which runs before the currently installed Crashpad handler. </p>
<p>Handling signals appropriately can be tricky and use of this method should be avoided, if possible.</p>
<p>A handler must have already been installed before calling this method.</p>
<p>The custom handler runs in a signal handler context and must be safe for that purpose.</p>
<p>If the custom handler returns <code>true</code>, the signal is considered handled and the signal handler returns. Otherwise, the currently installed Crashpad signal handler is run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>The custom crash signal handler to install. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f1d5d38e9b4f5781e3821551dcc39d5" name="a9f1d5d38e9b4f5781e3821551dcc39d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1d5d38e9b4f5781e3821551dcc39d5">&#9670;&#160;</a></span>SetHandlerIPCPipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::SetHandlerIPCPipe </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>ipc_pipe</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the IPC pipe of a presumably-running Crashpad handler process which was started with <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> or by other compatible means and does an IPC message exchange to register this process with the handler. Crashes will be serviced once this method returns. </p>
<p>This method is only defined on Windows.</p>
<p>This method sets the unhandled exception handler to a local function that when reached will "signal and wait" for the crash handler process to create the dump.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipc_pipe</td><td>The full name of the crash handler IPC pipe. This is a string of the form <code>&amp;quot;\\.\pipe\NAME&amp;quot;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success and <code>false</code> on failure. </dd></dl>

</div>
</div>
<a id="a5f93df3806aba3bd9886b12229550e12" name="a5f93df3806aba3bd9886b12229550e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f93df3806aba3bd9886b12229550e12">&#9670;&#160;</a></span>SetHandlerMachPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::SetHandlerMachPort </td>
          <td>(</td>
          <td class="paramtype">base::apple::ScopedMachSendRight</td>          <td class="paramname"><span class="paramname"><em>exception_port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the process’ crash handler to a Mach port. </p>
<p>This method is only defined on macOS.</p>
<p>See <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> for more detail on how the port and handler are configured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_port</td><td>An <code>exception_port_t</code> corresponding to a Crashpad exception handler service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a89f34445eca859e6c0d1876e8e171c25" name="a89f34445eca859e6c0d1876e8e171c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f34445eca859e6c0d1876e8e171c25">&#9670;&#160;</a></span>SetHandlerMachService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::SetHandlerMachService </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>service_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the process’ crash handler to a Mach service registered with the bootstrap server. </p>
<p>This method is only defined on macOS.</p>
<p>See <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> for more detail on how the port and handler are configured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>The service name of a Crashpad exception handler service previously registered with the bootstrap server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="ae2d2d23831a27eef8fe99deb2d3119dc" name="ae2d2d23831a27eef8fe99deb2d3119dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d2d23831a27eef8fe99deb2d3119dc">&#9670;&#160;</a></span>SetHandlerSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::SetHandlerSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecrashpad.html#a2d3a0ca2e9e37905b425f2cb1b428e7e">ScopedFileHandle</a></td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the socket to a presumably-running Crashpad handler process which was started with <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a>. </p>
<p>This method installs a signal handler to request crash dumps on <em class="arg">sock</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>A socket connected to a Crashpad handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The process ID of the handler, used to set the handler as this process' ptracer. 0 indicates it is not necessary to set the handler as this process' ptracer. -1 indicates that the handler's process ID should be determined by communicating over the socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5be35922505fe7ac6c7e895110729938" name="a5be35922505fe7ac6c7e895110729938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be35922505fe7ac6c7e895110729938">&#9670;&#160;</a></span>SetLastChanceExceptionHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::SetLastChanceExceptionHandler </td>
          <td>(</td>
          <td class="paramtype">bool(*</td>          <td class="paramname"><span class="paramname"><em>handler&#160;</em></span>)(int, siginfo_t *, ucontext_t *)</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Installs a custom crash signal handler which runs after the currently installed Crashpad handler. </p>
<p>Handling signals appropriately can be tricky and use of this method should be avoided, if possible.</p>
<p>A handler must have already been installed before calling this method.</p>
<p>The custom handler runs in a signal handler context and must be safe for that purpose.</p>
<p>If the custom handler returns <code>true</code>, the signal is not reraised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>The custom crash signal handler to install. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60f5ab794ec5e1e671e13c28e82fa5f5" name="a60f5ab794ec5e1e671e13c28e82fa5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f5ab794ec5e1e671e13c28e82fa5f5">&#9670;&#160;</a></span>SetUnhandledSignals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::SetUnhandledSignals </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unhandled_signals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures a set of signals that shouldn't have Crashpad signal handlers installed. </p>
<p>This method should be called before calling <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a>, <a class="el" href="#ae2d2d23831a27eef8fe99deb2d3119dc" title="Sets the socket to a presumably-running Crashpad handler process which was started with StartHandler(...">SetHandlerSocket()</a>, or other methods that install Crashpad signal handlers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unhandled_signals</td><td>The set of unhandled signals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abca367c1dc74adaa43162498c5a4c4a1" name="abca367c1dc74adaa43162498c5a4c4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca367c1dc74adaa43162498c5a4c4a1">&#9670;&#160;</a></span>StartCrashpadInProcessHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::StartCrashpadInProcessHandler </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0ee35d49868b4c5e4ca3e2ebae523b7f">ProcessPendingReportsObservationCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the process to direct its crashes to the iOS in-process Crashpad handler. </p>
<p>This method is only defined on iOS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The path to a Crashpad database. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL of an upload server. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Optional callback invoked zero or more times on a background thread each time the handler finishes processing and attempting to upload on-disk crash reports. If this callback is empty, it is not invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a55a66dbad38f306d733bac8e42de02cf" name="a55a66dbad38f306d733bac8e42de02cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a66dbad38f306d733bac8e42de02cf">&#9670;&#160;</a></span>StartHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::StartHandler </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>metrics_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>restartable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>asynchronous_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; base::FilePath &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>attachments</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a Crashpad handler process, performing any necessary handshake to configure it. </p>
<p>This method directs crashes to the Crashpad handler. On macOS, this is applicable to this process and all subsequent child processes. On Windows, child processes must also register by using <a class="el" href="#a9f1d5d38e9b4f5781e3821551dcc39d5" title="Sets the IPC pipe of a presumably-running Crashpad handler process which was started with StartHandle...">SetHandlerIPCPipe()</a>.</p>
<p>On macOS, this method starts a Crashpad handler and obtains a Mach send right corresponding to a receive right held by the handler process. The handler process runs an exception server on this port. This method sets the task’s exception port for <code>EXC_CRASH</code>, <code>EXC_RESOURCE</code>, and <code>EXC_GUARD</code> exceptions to the Mach send right obtained. The handler will be installed with behavior <code>EXCEPTION_STATE_IDENTITY | MACH_EXCEPTION_CODES</code> and thread state flavor <code>MACHINE_THREAD_STATE</code>. Exception ports are inherited, so a Crashpad handler started here will remain the handler for any child processes created after <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> is called. These child processes do not need to call <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> or be aware of Crashpad in any way. The Crashpad handler will receive crashes from child processes that have inherited it as their exception handler even after the process that called <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a> exits.</p>
<p>On Windows, if <em class="arg">asynchronous_start</em> is <code>true</code>, this function will not directly call <code>CreateProcess()</code>, making it suitable for use in a <code>DllMain()</code>. In that case, the handler is started from a background thread, deferring the handler's startup. Nevertheless, regardless of the value of <em class="arg">asynchronous_start</em>, after calling this method, the global unhandled exception filter is set up, and all crashes will be handled by Crashpad. Optionally, use <a class="el" href="#a0377d4e93ac77453f57f3c1fcae09e14" title="When asynchronous_start is used with StartHandler(), this method can be used to block until the handl...">WaitForHandlerStart()</a> to join with the background thread and retrieve the status of handler startup.</p>
<p>On Fuchsia, this method binds to the exception port of the current default job, and starts a Crashpad handler to monitor that port.</p>
<p>On Linux, this method starts a Crashpad handler, connected to this process via an <code>AF_UNIX</code> socket pair and installs signal handlers to request crash dumps on the client's socket end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>The path to a Crashpad handler executable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The path to a Crashpad database. The handler will be started with this path as its <code>--database</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metrics_dir</td><td>The path to an already existing directory where metrics files can be stored. The handler will be started with this path as its <code>--metrics-dir</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL of an upload server. The handler will be started with this URL as its <code>--url</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. The handler will be started with an <code>--annotation</code> argument for each element in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>Additional arguments to pass to the Crashpad handler. Arguments passed in other parameters and arguments required to perform the handshake are the responsibility of this method, and must not be specified in this parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restartable</td><td>If <code>true</code>, the handler will be restarted if it dies, if this behavior is supported. This option is not available on all platforms, and does not function on all OS versions. If it is not supported, it will be ignored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">asynchronous_start</td><td>If <code>true</code>, the handler will be started from a background thread. Optionally, <a class="el" href="#a0377d4e93ac77453f57f3c1fcae09e14" title="When asynchronous_start is used with StartHandler(), this method can be used to block until the handl...">WaitForHandlerStart()</a> can be used at a suitable time to retreive the result of background startup. This option is only used on Windows. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attachments</td><td>Vector that stores file paths that should be captured with each report at the time of the crash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="abcf7a68a42e8108f8b648a4f19d52287" name="abcf7a68a42e8108f8b648a4f19d52287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf7a68a42e8108f8b648a4f19d52287">&#9670;&#160;</a></span>StartHandlerAtCrash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::StartHandlerAtCrash </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>metrics_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; base::FilePath &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>attachments</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a signal handler to launch a handler process in reponse to a crash. </p>
<p>The handler process will create a crash dump for this process and exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>The path to a Crashpad handler executable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The path to a Crashpad database. The handler will be started with this path as its <code>--database</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metrics_dir</td><td>The path to an already existing directory where metrics files can be stored. The handler will be started with this path as its <code>--metrics-dir</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL of an upload server. The handler will be started with this URL as its <code>--url</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. The handler will be started with an <code>--annotation</code> argument for each element in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>Additional arguments to pass to the Crashpad handler. Arguments passed in other parameters and arguments required to perform the handshake are the responsibility of this method, and must not be specified in this parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attachments</td><td>Attachment paths to pass to the Crashpad handler. The handler will be started with an <code>--attachment</code> argument for each path in this vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a10b09eb149139d4df63a4bca3042ef67" name="a10b09eb149139d4df63a4bca3042ef67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b09eb149139d4df63a4bca3042ef67">&#9670;&#160;</a></span>StartHandlerForClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::StartHandlerForClient </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>metrics_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a handler process with an initial client. </p>
<p>This method allows a process to launch the handler process on behalf of another process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>The path to a Crashpad handler executable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The path to a Crashpad database. The handler will be started with this path as its <code>--database</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metrics_dir</td><td>The path to an already existing directory where metrics files can be stored. The handler will be started with this path as its <code>--metrics-dir</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL of an upload server. The handler will be started with this URL as its <code>--url</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. The handler will be started with an <code>--annotation</code> argument for each element in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>Additional arguments to pass to the Crashpad handler. Arguments passed in other parameters and arguments required to perform the handshake are the responsibility of this method, and must not be specified in this parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The server end of a socket pair. The client end should be used with an <a class="el" href="classcrashpad_1_1ExceptionHandlerClient.html" title="A client for an ExceptionHandlerServer.">ExceptionHandlerClient</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a1ed0bd663b34b4bd5640cf6e42289034" name="a1ed0bd663b34b4bd5640cf6e42289034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed0bd663b34b4bd5640cf6e42289034">&#9670;&#160;</a></span>StartHandlerWithLinkerAtCrash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::StartHandlerWithLinkerAtCrash </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>handler_trampoline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>handler_library</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_64_bit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>metrics_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a signal handler to start a Crashpad handler process by loading it with <code>/system/bin/linker</code>. </p>
<p>This method is only supported by Android Q+.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler_trampoline</td><td>The path to a Crashpad handler trampoline executable, possibly located within an apk, e.g. "/data/app/myapk.apk!/myabi/libcrashpad_handler_trampoline.so". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler_library</td><td>The name of a library exporting the symbol <code>CrashpadHandlerMain()</code>. The path to this library must be present in <code>LD_LIBRARY_PATH</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_64_bit</td><td><code>true</code> if <em class="arg">handler_trampoline</em> and <em class="arg">handler_library</em> are 64-bit objects. They must have the same bitness. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">env</td><td>A vector of environment variables of the form <code>var=value</code> defining the environment in which to execute <code>app_process</code>. If this value is <code>nullptr</code>, the application's environment at the time of the crash will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The path to a Crashpad database. The handler will be started with this path as its <code>--database</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metrics_dir</td><td>The path to an already existing directory where metrics files can be stored. The handler will be started with this path as its <code>--metrics-dir</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL of an upload server. The handler will be started with this URL as its <code>--url</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. The handler will be started with an <code>--annotation</code> argument for each element in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>Additional arguments to pass to the Crashpad handler. Arguments passed in other parameters and arguments required to perform the handshake are the responsibility of this method, and must not be specified in this parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a86d9776fd32f37ef528fa1a3eeac78fc" name="a86d9776fd32f37ef528fa1a3eeac78fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d9776fd32f37ef528fa1a3eeac78fc">&#9670;&#160;</a></span>StartHandlerWithLinkerForClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool crashpad::CrashpadClient::StartHandlerWithLinkerForClient </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>handler_trampoline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>handler_library</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_64_bit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>metrics_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a Crashpad handler process with an initial client by loading it with <code>/system/bin/linker</code>. </p>
<p>This method is only supported by Android Q+.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler_trampoline</td><td>The path to a Crashpad handler trampoline executable, possibly located within an apk, e.g. "/data/app/myapk.apk!/myabi/libcrashpad_handler_trampoline.so". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler_library</td><td>The name of a library exporting the symbol <code>CrashpadHandlerMain()</code>. The path to this library must be present in <code>LD_LIBRARY_PATH</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_64_bit</td><td><code>true</code> if <em class="arg">handler_trampoline</em> and <em class="arg">handler_library</em> are 64-bit objects. They must have the same bitness. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">env</td><td>A vector of environment variables of the form <code>var=value</code> defining the environment in which to execute <code>app_process</code>. If this value is <code>nullptr</code>, the application's current environment will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The path to a Crashpad database. The handler will be started with this path as its <code>--database</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metrics_dir</td><td>The path to an already existing directory where metrics files can be stored. The handler will be started with this path as its <code>--metrics-dir</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL of an upload server. The handler will be started with this URL as its <code>--url</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. The handler will be started with an <code>--annotation</code> argument for each element in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>Additional arguments to pass to the Crashpad handler. Arguments passed in other parameters and arguments required to perform the handshake are the responsibility of this method, and must not be specified in this parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The server end of a socket pair. The client end should be used with an <a class="el" href="classcrashpad_1_1ExceptionHandlerClient.html" title="A client for an ExceptionHandlerServer.">ExceptionHandlerClient</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="ac6ab4585d5703a3289a7f05df806575a" name="ac6ab4585d5703a3289a7f05df806575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ab4585d5703a3289a7f05df806575a">&#9670;&#160;</a></span>StartJavaHandlerAtCrash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::StartJavaHandlerAtCrash </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>class_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>metrics_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a signal handler to execute <code>/system/bin/app_process</code> and load a Java class in response to a crash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">class_name</td><td>The fully qualified class name to load, which must define a <code>main()</code> method to be invoked by <code>app_process</code>. Arguments will be passed to this method as though it were the Crashpad handler. This class is expected to load a native library defining <a class="el" href="namespacecrashpad.html#a6925b00a82891a9fd7a77ec6f5259094" title="The main() of the crashpad_handler binary.">crashpad::HandlerMain()</a> and pass the arguments to it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">env</td><td>A vector of environment variables of the form <code>var=value</code> defining the environment in which to execute <code>app_process</code>. If this value is <code>nullptr</code>, the application's environment at the time of the crash will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The path to a Crashpad database. The handler will be started with this path as its <code>--database</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metrics_dir</td><td>The path to an already existing directory where metrics files can be stored. The handler will be started with this path as its <code>--metrics-dir</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL of an upload server. The handler will be started with this URL as its <code>--url</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. The handler will be started with an <code>--annotation</code> argument for each element in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>Additional arguments to pass to the Crashpad handler. Arguments passed in other parameters and arguments required to perform the handshake are the responsibility of this method, and must not be specified in this parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a5ec0698a7626fd82a3dc756f60d4e061" name="a5ec0698a7626fd82a3dc756f60d4e061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec0698a7626fd82a3dc756f60d4e061">&#9670;&#160;</a></span>StartJavaHandlerForClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool crashpad::CrashpadClient::StartJavaHandlerForClient </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>class_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>metrics_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes <code>/system/bin/app_process</code> and loads a Java class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">class_name</td><td>The fully qualified class name to load, which must define a <code>main()</code> method to be invoked by <code>app_process</code>. Arguments will be passed to this method as though it were the Crashpad handler. This class is expected to load a native library defining <a class="el" href="namespacecrashpad.html#a6925b00a82891a9fd7a77ec6f5259094" title="The main() of the crashpad_handler binary.">crashpad::HandlerMain()</a> and pass the arguments to it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">env</td><td>A vector of environment variables of the form <code>var=value</code> defining the environment in which to execute <code>app_process</code>. If this value is <code>nullptr</code>, the application's current environment will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The path to a Crashpad database. The handler will be started with this path as its <code>--database</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metrics_dir</td><td>The path to an already existing directory where metrics files can be stored. The handler will be started with this path as its <code>--metrics-dir</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL of an upload server. The handler will be started with this URL as its <code>--url</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. The handler will be started with an <code>--annotation</code> argument for each element in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>Additional arguments to pass to the Crashpad handler. Arguments passed in other parameters and arguments required to perform the handshake are the responsibility of this method, and must not be specified in this parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The server end of a socket pair. The client end should be used with an <a class="el" href="classcrashpad_1_1ExceptionHandlerClient.html" title="A client for an ExceptionHandlerServer.">ExceptionHandlerClient</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a74ad055cbc0559637638c1827eb98813" name="a74ad055cbc0559637638c1827eb98813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ad055cbc0559637638c1827eb98813">&#9670;&#160;</a></span>StartProcessingPendingReports()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::StartProcessingPendingReports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecrashpad.html#a8acaf90af42afce7536ea74c1cf32258">UploadBehavior</a></td>          <td class="paramname"><span class="paramname"><em>upload_behavior</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacecrashpad.html#a8acaf90af42afce7536ea74c1cf32258a3827652cb700b6d3d2cdf18d69c52979">UploadBehavior::kUploadWhenAppIsActive</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler begin in-process uploading of any pending reports. </p>
<p>Once called the handler will start looking for pending reports to upload on another thread. This method does not block.</p>
<p>A handler must have already been installed before calling this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">upload_behavior</td><td>Controls when the upload thread will run and process pending reports. By default, only uploads pending reports when the application is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a6a1e62d90a67db782664b1fe5a952f" name="a1a6a1e62d90a67db782664b1fe5a952f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6a1e62d90a67db782664b1fe5a952f">&#9670;&#160;</a></span>UseSystemDefaultHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::UseSystemDefaultHandler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the process to direct its crashes to the default handler for the operating system. </p>
<p>On macOS, this sets the task’s exception port as in <a class="el" href="#a5f93df3806aba3bd9886b12229550e12" title="Sets the process’ crash handler to a Mach port.">SetHandlerMachPort()</a>, but the exception handler used is obtained from <a class="el" href="namespacecrashpad.html#abf8f0c52904467bf6c534f78a52d5699" title="Obtains the system’s default Mach exception handler for crash-type exceptions.">SystemCrashReporterHandler()</a>. If the system’s crash reporter handler cannot be determined or set, the task’s exception ports for crash-type exceptions are cleared.</p>
<p>Use of this function is strongly discouraged.</p>
<dl class="section warning"><dt>Warning</dt><dd>After a call to this function, Crashpad will no longer monitor the process for crashes until a subsequent call to <a class="el" href="#a5f93df3806aba3bd9886b12229550e12" title="Sets the process’ crash handler to a Mach port.">SetHandlerMachPort()</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is provided as a static function to allow it to be used in situations where a <a class="el" href="classcrashpad_1_1CrashpadClient.html" title="The primary interface for an application to have Crashpad monitor it for crashes.">CrashpadClient</a> object is not otherwise available. This may be useful when a child process inherits its parent’s Crashpad handler, but wants to sever this tie. </dd></dl>

</div>
</div>
<a id="a0377d4e93ac77453f57f3c1fcae09e14" name="a0377d4e93ac77453f57f3c1fcae09e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0377d4e93ac77453f57f3c1fcae09e14">&#9670;&#160;</a></span>WaitForHandlerStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::WaitForHandlerStart </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When <code>asynchronous_start</code> is used with <a class="el" href="#a55a66dbad38f306d733bac8e42de02cf" title="Starts a Crashpad handler process, performing any necessary handshake to configure it.">StartHandler()</a>, this method can be used to block until the handler launch has been completed to retrieve status information. </p>
<p>This method should not be used unless <code>asynchronous_start</code> was <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>The number of milliseconds to wait for a result from the background launch, or <code>0xffffffff</code> to block indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the hander startup succeeded, <code>false</code> otherwise, and an error message will have been logged. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>client/<b>crashpad_client.h</b></li>
<li>client/<b>crashpad_client_fuchsia.cc</b></li>
<li>client/<b>crashpad_client_ios.cc</b></li>
<li>client/<b>crashpad_client_linux.cc</b></li>
<li>client/<b>crashpad_client_mac.cc</b></li>
<li>client/<b>crashpad_client_win.cc</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecrashpad.html">crashpad</a></li><li class="navelem"><a class="el" href="classcrashpad_1_1CrashpadClient.html">CrashpadClient</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
