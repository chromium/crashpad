<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crashpad: crashpad Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="crashpad_doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Crashpad
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacecrashpad.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">crashpad Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The main namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespacecrashpad_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal namespace, not for public use. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html">test</a></td></tr>
<tr class="memdesc:namespacecrashpad_1_1test"><td class="mdescLeft">&#160;</td><td class="mdescRight">The testing namespace, for use in test code only. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1AgePruneCondition.html">AgePruneCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1PruneCondition.html" title="An abstract base class for evaluating crash reports for deletion.">PruneCondition</a> that deletes reports older than the specified number days.  <a href="classcrashpad_1_1AgePruneCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1AlignedAllocator.html">AlignedAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A standard allocator that aligns its allocations as requested, suitable for use as an allocator in standard containers.  <a href="structcrashpad_1_1AlignedAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Annotation.html">Annotation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for an annotation, which records a name-value pair of arbitrary data when set.  <a href="classcrashpad_1_1Annotation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1AnnotationList.html">AnnotationList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list that contains all the currently set annotations.  <a href="classcrashpad_1_1AnnotationList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1AnnotationSnapshot.html">AnnotationSnapshot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1AuxiliaryVector.html">AuxiliaryVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the auxiliary vector for a target process.  <a href="classcrashpad_1_1AuxiliaryVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Base94OutputStream.html">Base94OutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements Base94 encoding/decoding, it uses all printable characters except space for encoding, and no padding is required.  <a href="classcrashpad_1_1Base94OutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1BinaryPruneCondition.html">BinaryPruneCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1PruneCondition.html" title="An abstract base class for evaluating crash reports for deletion.">PruneCondition</a> that conjoins two other PruneConditions.  <a href="classcrashpad_1_1BinaryPruneCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CheckedRange.html">CheckedRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that a range, composed of a base and size, does not overflow its data type.  <a href="classcrashpad_1_1CheckedRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ChildPortHandshake.html">ChildPortHandshake</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a handshake protocol that allows processes to exchange port rights.  <a href="classcrashpad_1_1ChildPortHandshake.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ChildPortServer.html">ChildPortServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A server interface for the <code>child_port</code> Mach subsystem.  <a href="classcrashpad_1_1ChildPortServer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1ClientToServerMessage.html">ClientToServerMessage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The message passed from client to server by <a class="el" href="#a0d993c28de1644014bf81bac75817757" title="Connect over the given pipe_name, passing message to the server, storing the server&#39;s reply into resp...">SendToCrashHandlerServer()</a>.  <a href="structcrashpad_1_1ClientToServerMessage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CodeViewRecordBuildID.html">CodeViewRecordBuildID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CodeView record containing an ELF build-id.  <a href="structcrashpad_1_1CodeViewRecordBuildID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CodeViewRecordPDB20.html">CodeViewRecordPDB20</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CodeView record linking to a <code>.pdb</code> 2.0 file.  <a href="structcrashpad_1_1CodeViewRecordPDB20.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CodeViewRecordPDB70.html">CodeViewRecordPDB70</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CodeView record linking to a <code>.pdb</code> 7.0 file.  <a href="structcrashpad_1_1CodeViewRecordPDB70.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CompositeHTTPBodyStream.html">CompositeHTTPBodyStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a> that combines an array of several other <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a> objects into a single, unified stream.  <a href="classcrashpad_1_1CompositeHTTPBodyStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CompositeMachMessageServer.html">CompositeMachMessageServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts multiple <a class="el" href="classcrashpad_1_1MachMessageServer_1_1Interface.html" title="A Mach RPC callback interface, called by Run().">MachMessageServer::Interface</a> implementations for simultaneous use in a single <a class="el" href="classcrashpad_1_1MachMessageServer.html#ace981f2e495984f119aa074f7d33bff6" title="Runs a Mach message server to handle a Mach RPC request for MIG servers.">MachMessageServer::Run()</a> call.  <a href="classcrashpad_1_1CompositeMachMessageServer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context structure capable of carrying the context of any supported CPU architecture.  <a href="structcrashpad_1_1CPUContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CPUContextARM.html">CPUContextARM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context structure carrying ARM CPU state.  <a href="structcrashpad_1_1CPUContextARM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CPUContextARM64.html">CPUContextARM64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context structure carrying ARM64 CPU state.  <a href="structcrashpad_1_1CPUContextARM64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CPUContextMIPS.html">CPUContextMIPS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context structure carrying MIPS CPU state.  <a href="structcrashpad_1_1CPUContextMIPS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CPUContextMIPS64.html">CPUContextMIPS64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context structure carrying MIPS64 CPU state.  <a href="structcrashpad_1_1CPUContextMIPS64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CPUContextRISCV64.html">CPUContextRISCV64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context structure carrying RISCV64 CPU state.  <a href="structcrashpad_1_1CPUContextRISCV64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CPUContextX86.html">CPUContextX86</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context structure carrying 32-bit x86 CPU state.  <a href="structcrashpad_1_1CPUContextX86.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CPUContextX86__64.html">CPUContextX86_64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context structure carrying x86_64 CPU state.  <a href="structcrashpad_1_1CPUContextX86__64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html">CrashpadClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The primary interface for an application to have Crashpad monitor it for crashes.  <a href="classcrashpad_1_1CrashpadClient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CrashpadInfo.html">CrashpadInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that can be used by a Crashpad-enabled program to provide information to the Crashpad crash handler.  <a href="structcrashpad_1_1CrashpadInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1CrashpadInfoClientOptions.html">CrashpadInfoClientOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options represented in a client’s <a class="el" href="structcrashpad_1_1CrashpadInfo.html" title="A structure that can be used by a Crashpad-enabled program to provide information to the Crashpad cra...">CrashpadInfo</a> structure.  <a href="structcrashpad_1_1CrashpadInfoClientOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadInfoReader.html">CrashpadInfoReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads <a class="el" href="structcrashpad_1_1CrashpadInfo.html" title="A structure that can be used by a Crashpad-enabled program to provide information to the Crashpad cra...">CrashpadInfo</a> structs from another process via a <a class="el" href="classcrashpad_1_1ProcessMemoryRange.html" title="Provides range protected access to the memory of another process.">ProcessMemoryRange</a>.  <a href="classcrashpad_1_1CrashpadInfoReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashReportDatabase.html">CrashReportDatabase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for managing a collection of crash report files and metadata associated with the crash reports.  <a href="classcrashpad_1_1CrashReportDatabase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashReportDatabaseGeneric.html">CrashReportDatabaseGeneric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashReportDatabaseMac.html">CrashReportDatabaseMac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1CrashReportDatabase.html" title="An interface for managing a collection of crash report files and metadata associated with the crash r...">CrashReportDatabase</a> that uses HFS+ extended attributes to store report metadata.  <a href="classcrashpad_1_1CrashReportDatabaseMac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashReportDatabaseWin.html">CrashReportDatabaseWin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashReportExceptionHandler.html">CrashReportExceptionHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception handler that writes crash reports for exceptions to a <a class="el" href="classcrashpad_1_1CrashReportDatabase.html" title="An interface for managing a collection of crash report files and metadata associated with the crash r...">CrashReportDatabase</a>.  <a href="classcrashpad_1_1CrashReportExceptionHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashReportUploadThread.html">CrashReportUploadThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread that processes pending crash reports in a <a class="el" href="classcrashpad_1_1CrashReportDatabase.html" title="An interface for managing a collection of crash report files and metadata associated with the crash r...">CrashReportDatabase</a> by uploading them or marking them as completed without upload, as desired.  <a href="classcrashpad_1_1CrashReportUploadThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrosCrashReportExceptionHandler.html">CrosCrashReportExceptionHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception handler that writes crash reports to the ChromeOS crash_reporter.  <a href="classcrashpad_1_1CrosCrashReportExceptionHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1DatabaseSizePruneCondition.html">DatabaseSizePruneCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1PruneCondition.html" title="An abstract base class for evaluating crash reports for deletion.">PruneCondition</a> that deletes older reports to keep the total Crashpad database size under the specified limit.  <a href="classcrashpad_1_1DatabaseSizePruneCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1DebugRendezvous.html">DebugRendezvous</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an <code>r_debug</code> struct defined in <code>&lt;link.h&gt;</code> via <a class="el" href="classcrashpad_1_1ProcessMemoryRange.html" title="Provides range protected access to the memory of another process.">ProcessMemoryRange</a>.  <a href="classcrashpad_1_1DebugRendezvous.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1DelimitedFileReader.html">DelimitedFileReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a file one field or line at a time.  <a href="classcrashpad_1_1DelimitedFileReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1DirectoryReader.html">DirectoryReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the file and directory names in a directory.  <a href="classcrashpad_1_1DirectoryReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1DirectPtraceConnection.html">DirectPtraceConnection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a direct <code>ptrace</code> connection to a process.  <a href="classcrashpad_1_1DirectPtraceConnection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ElfDynamicArrayReader.html">ElfDynamicArrayReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader for ELF dynamic arrays mapped into another process.  <a href="classcrashpad_1_1ElfDynamicArrayReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ElfImageReader.html">ElfImageReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader for ELF images mapped into another process.  <a href="classcrashpad_1_1ElfImageReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ElfSymbolTableReader.html">ElfSymbolTableReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader for symbol tables in ELF images mapped into another process.  <a href="classcrashpad_1_1ElfSymbolTableReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ExceptionHandlerClient.html">ExceptionHandlerClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A client for an <a class="el" href="classcrashpad_1_1ExceptionHandlerServer.html" title="Runs the main exception-handling server in Crashpad’s handler process.">ExceptionHandlerServer</a>.  <a href="classcrashpad_1_1ExceptionHandlerClient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ExceptionHandlerProtocol.html">ExceptionHandlerProtocol</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ExceptionHandlerServer.html">ExceptionHandlerServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the main exception-handling server in Crashpad’s handler process.  <a href="classcrashpad_1_1ExceptionHandlerServer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1ExceptionInformation.html">ExceptionInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure read out of the client process by the crash handler when an exception occurs.  <a href="structcrashpad_1_1ExceptionInformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ExceptionPorts.html">ExceptionPorts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A better interface to <code>*_get_exception_ports()</code> and <code>*_set_exception_ports()</code>.  <a href="classcrashpad_1_1ExceptionPorts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ExceptionSnapshot.html">ExceptionSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract interface to a snapshot representing an exception that a snapshot process sustained and triggered the snapshot being taken.  <a href="classcrashpad_1_1ExceptionSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1FileEncoder.html">FileEncoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class is used to compress and base94-encode, or base94-decode and decompress the given input file to the output file.  <a href="classcrashpad_1_1FileEncoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1FileOutputStream.html">FileOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class is used to write data to a file.  <a href="classcrashpad_1_1FileOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1FileReader.html">FileReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A file reader implementation that wraps traditional system file operations on files accessed through the filesystem.  <a href="classcrashpad_1_1FileReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1FileReaderHTTPBodyStream.html">FileReaderHTTPBodyStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a> that reads from a <a class="el" href="classcrashpad_1_1FileReaderInterface.html" title="An interface to read to files and other file-like objects with semantics matching the underlying plat...">FileReaderInterface</a> and provides its contents for an HTTP body.  <a href="classcrashpad_1_1FileReaderHTTPBodyStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1FileReaderInterface.html">FileReaderInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to read to files and other file-like objects with semantics matching the underlying platform (POSIX or Windows).  <a href="classcrashpad_1_1FileReaderInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1FileSeekerInterface.html">FileSeekerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to seek in files and other file-like objects with semantics matching the underlying platform (POSIX or Windows).  <a href="classcrashpad_1_1FileSeekerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1FileWriter.html">FileWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A file writer implementation that wraps traditional system file operations on files accessed through the filesystem.  <a href="classcrashpad_1_1FileWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1FileWriterInterface.html">FileWriterInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to write to files and other file-like objects with semantics matching the underlying platform (POSIX or Windows).  <a href="classcrashpad_1_1FileWriterInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncrashpad_1_1FloatContext.html">FloatContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The floating point registers used for an architecture family.  <a href="unioncrashpad_1_1FloatContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1GzipHTTPBodyStream.html">GzipHTTPBodyStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a> that <code>gzip</code>-compresses another <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a>.  <a href="classcrashpad_1_1GzipHTTPBodyStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1HandleSnapshot.html">HandleSnapshot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to a stream that can be used for an HTTP request body.  <a href="classcrashpad_1_1HTTPBodyStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1HTTPMultipartBuilder.html">HTTPMultipartBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to build a MIME multipart message, conforming to RFC 2046, for use as a HTTP request body.  <a href="classcrashpad_1_1HTTPMultipartBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1HTTPTransport.html">HTTPTransport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcrashpad_1_1HTTPTransport.html" title="HTTPTransport executes a HTTP request using the specified URL, HTTP method, headers,...">HTTPTransport</a> executes a HTTP request using the specified URL, HTTP method, headers, and body. This class can only issue a synchronous HTTP request.  <a href="classcrashpad_1_1HTTPTransport.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ImageAnnotationReader.html">ImageAnnotationReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads Annotations from another process via a <a class="el" href="classcrashpad_1_1ProcessMemoryRange.html" title="Provides range protected access to the memory of another process.">ProcessMemoryRange</a>.  <a href="classcrashpad_1_1ImageAnnotationReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1InitialClientData.html">InitialClientData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for the data associated with the <code>--initial-client-data</code> method for initializing the handler process on Windows.  <a href="classcrashpad_1_1InitialClientData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1InitializationState.html">InitializationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks whether data are initialized.  <a href="classcrashpad_1_1InitializationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1InitializationStateDcheck.html">InitializationStateDcheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks whether data are initialized, triggering a DCHECK assertion on an invalid data access.  <a href="classcrashpad_1_1InitializationStateDcheck.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1LengthDelimitedRingBufferReader.html">LengthDelimitedRingBufferReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads variable-length data buffers from a <code><a class="el" href="structcrashpad_1_1RingBufferData.html" title="Storage for a ring buffer which can hold up to RingBufferCapacity bytes of Base 128-varint delimited ...">RingBufferData</a></code>, delimited by Base128 varint-encoded length delimiters.  <a href="classcrashpad_1_1LengthDelimitedRingBufferReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1LengthDelimitedRingBufferWriter.html">LengthDelimitedRingBufferWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes variable-length data buffers to a <code><a class="el" href="structcrashpad_1_1RingBufferData.html" title="Storage for a ring buffer which can hold up to RingBufferCapacity bytes of Base 128-varint delimited ...">RingBufferData</a></code>, delimited by Base128 varint-encoded length delimiters.  <a href="classcrashpad_1_1LengthDelimitedRingBufferWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1LogOutputStream.html">LogOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class outputs a stream of data as a series of log messages.  <a href="classcrashpad_1_1LogOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MachMessageServer.html">MachMessageServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a Mach message server to handle a Mach RPC request for MIG servers.  <a href="classcrashpad_1_1MachMessageServer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MachOImageAnnotationsReader.html">MachOImageAnnotationsReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader for annotations stored in a Mach-O image mapped into another process.  <a href="classcrashpad_1_1MachOImageAnnotationsReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MachOImageReader.html">MachOImageReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader for Mach-O images mapped into another process.  <a href="classcrashpad_1_1MachOImageReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MachOImageSegmentReader.html">MachOImageSegmentReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader for <code>LC_SEGMENT</code> or <code>LC_SEGMENT_64</code> load commands in Mach-O images mapped into another process.  <a href="classcrashpad_1_1MachOImageSegmentReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MachOImageSymbolTableReader.html">MachOImageSymbolTableReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader for symbol tables in Mach-O images mapped into another process.  <a href="classcrashpad_1_1MachOImageSymbolTableReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MemoryMap.html">MemoryMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses information about mapped memory in another process.  <a href="classcrashpad_1_1MemoryMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MemoryMapFuchsia.html">MemoryMapFuchsia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of mappings in the address space of a Fuchsia process.  <a href="classcrashpad_1_1MemoryMapFuchsia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MemoryMapRegionSnapshot.html">MemoryMapRegionSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract interface to a snapshot representing a region of the memory map present in the snapshot process.  <a href="classcrashpad_1_1MemoryMapRegionSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MemorySnapshot.html">MemorySnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract interface to a snapshot representing a region of memory present in a snapshot process.  <a href="classcrashpad_1_1MemorySnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Metrics.html">Metrics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container class to hold shared UMA metrics integration points.  <a href="classcrashpad_1_1Metrics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpAMD64XSaveFormatCetU.html">MinidumpAMD64XSaveFormatCetU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XSAVE_CET_U_FORMAT.  <a href="structcrashpad_1_1MinidumpAMD64XSaveFormatCetU.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpAnnotation.html">MinidumpAnnotation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typed annotation object.  <a href="structcrashpad_1_1MinidumpAnnotation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpAnnotationList.html">MinidumpAnnotationList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of annotation objects.  <a href="structcrashpad_1_1MinidumpAnnotationList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpAnnotationListWriter.html">MinidumpAnnotationListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpAnnotationList.html" title="A list of annotation objects.">MinidumpAnnotationList</a> object in a minidump file, containing a list of <a class="el" href="structcrashpad_1_1MinidumpAnnotation.html" title="A typed annotation object.">MinidumpAnnotation</a> objects.  <a href="classcrashpad_1_1MinidumpAnnotationListWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpAnnotationWriter.html">MinidumpAnnotationWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpAnnotation.html" title="A typed annotation object.">MinidumpAnnotation</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpAnnotationWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpByteArray.html">MinidumpByteArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable-length array of bytes carried within a minidump file. The data have no intrinsic type and should be interpreted according to their referencing context.  <a href="structcrashpad_1_1MinidumpByteArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpByteArrayWriter.html">MinidumpByteArrayWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a variable-length byte array for a minidump into a.  <a href="classcrashpad_1_1MinidumpByteArrayWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html">MinidumpContextAMD64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An x86_64 (AMD64) CPU context (register state) carried in a minidump file.  <a href="structcrashpad_1_1MinidumpContextAMD64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpContextAMD64Writer.html">MinidumpContextAMD64Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html" title="An x86_64 (AMD64) CPU context (register state) carried in a minidump file.">MinidumpContextAMD64</a> structure in a minidump file.  <a href="classcrashpad_1_1MinidumpContextAMD64Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpContextARM.html">MinidumpContextARM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 32-bit ARM CPU context (register state) carried in a minidump file.  <a href="structcrashpad_1_1MinidumpContextARM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpContextARM64.html">MinidumpContextARM64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 64-bit ARM CPU context (register state) carried in a minidump file.  <a href="structcrashpad_1_1MinidumpContextARM64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpContextARM64Writer.html">MinidumpContextARM64Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpContextARM64.html" title="A 64-bit ARM CPU context (register state) carried in a minidump file.">MinidumpContextARM64</a> structure in a minidump file.  <a href="classcrashpad_1_1MinidumpContextARM64Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpContextARMWriter.html">MinidumpContextARMWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpContextARM.html" title="A 32-bit ARM CPU context (register state) carried in a minidump file.">MinidumpContextARM</a> structure in a minidump file.  <a href="classcrashpad_1_1MinidumpContextARMWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpContextChunk.html">MinidumpContextChunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CONTEXT_CHUNK.  <a href="structcrashpad_1_1MinidumpContextChunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpContextExHeader.html">MinidumpContextExHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CONTEXT_EX.  <a href="structcrashpad_1_1MinidumpContextExHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpContextMIPS.html">MinidumpContextMIPS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 32bit MIPS CPU context (register state) carried in a minidump file.  <a href="structcrashpad_1_1MinidumpContextMIPS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpContextMIPS64.html">MinidumpContextMIPS64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 32bit MIPS CPU context (register state) carried in a minidump file.  <a href="structcrashpad_1_1MinidumpContextMIPS64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpContextMIPS64Writer.html">MinidumpContextMIPS64Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpContextMIPS64.html" title="A 32bit MIPS CPU context (register state) carried in a minidump file.">MinidumpContextMIPS64</a> structure in a minidump file.  <a href="classcrashpad_1_1MinidumpContextMIPS64Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpContextMIPSWriter.html">MinidumpContextMIPSWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpContextMIPS.html" title="A 32bit MIPS CPU context (register state) carried in a minidump file.">MinidumpContextMIPS</a> structure in a minidump file.  <a href="classcrashpad_1_1MinidumpContextMIPSWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpContextRISCV64.html">MinidumpContextRISCV64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 64-bit RISC-V CPU context (register state) carried in a minidump file.  <a href="structcrashpad_1_1MinidumpContextRISCV64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpContextRISCV64Writer.html">MinidumpContextRISCV64Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpContextRISCV64.html" title="A 64-bit RISC-V CPU context (register state) carried in a minidump file.">MinidumpContextRISCV64</a> structure in a minidump file.  <a href="classcrashpad_1_1MinidumpContextRISCV64Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpContextWriter.html">MinidumpContextWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for writers of CPU context structures in minidump files.  <a href="classcrashpad_1_1MinidumpContextWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 32-bit x86 CPU context (register state) carried in a minidump file.  <a href="structcrashpad_1_1MinidumpContextX86.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpContextX86Writer.html">MinidumpContextX86Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpContextX86.html" title="A 32-bit x86 CPU context (register state) carried in a minidump file.">MinidumpContextX86</a> structure in a minidump file.  <a href="classcrashpad_1_1MinidumpContextX86Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpCrashpadInfo.html">MinidumpCrashpadInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional Crashpad-specific information carried within a minidump file.  <a href="structcrashpad_1_1MinidumpCrashpadInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpCrashpadInfoWriter.html">MinidumpCrashpadInfoWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpCrashpadInfo.html" title="Additional Crashpad-specific information carried within a minidump file.">MinidumpCrashpadInfo</a> stream in a minidump file.  <a href="classcrashpad_1_1MinidumpCrashpadInfoWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpExceptionWriter.html">MinidumpExceptionWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__EXCEPTION__STREAM.html" title="Information about the exception that triggered a minidump file’s generation.">MINIDUMP_EXCEPTION_STREAM</a> stream in a minidump file.  <a href="classcrashpad_1_1MinidumpExceptionWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpFileWriter.html">MinidumpFileWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root-level object in a minidump file.  <a href="classcrashpad_1_1MinidumpFileWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpHandleDataWriter.html">MinidumpHandleDataWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a MINIDUMP_HANDLE_DATA_STREAM stream in a minidump and its contained <a class="el" href="structMINIDUMP__HANDLE__DESCRIPTOR.html" title="Contains the state of an individual system handle at the time the snapshot was taken....">MINIDUMP_HANDLE_DESCRIPTOR</a> s.  <a href="classcrashpad_1_1MinidumpHandleDataWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpMemoryInfoListWriter.html">MinidumpMemoryInfoListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__MEMORY__INFO__LIST.html" title="Contains a list of memory regions.">MINIDUMP_MEMORY_INFO_LIST</a> stream in a minidump file, containing a list of <a class="el" href="structMINIDUMP__MEMORY__INFO.html" title="Describes a region of memory.">MINIDUMP_MEMORY_INFO</a> objects.  <a href="classcrashpad_1_1MinidumpMemoryInfoListWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpMemoryListWriter.html">MinidumpMemoryListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__MEMORY__LIST.html" title="Information about memory regions within the process.">MINIDUMP_MEMORY_LIST</a> stream in a minidump file, containing a list of <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> objects.  <a href="classcrashpad_1_1MinidumpMemoryListWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpMiscInfoWriter.html">MinidumpMiscInfoWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a stream in the <a class="el" href="structMINIDUMP__MISC__INFO.html" title="Information about the process that the minidump file contains a snapshot of, as well as the system th...">MINIDUMP_MISC_INFO</a> family in a minidump file.  <a href="classcrashpad_1_1MinidumpMiscInfoWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpModuleCodeViewRecordBuildIDWriter.html">MinidumpModuleCodeViewRecordBuildIDWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1CodeViewRecordBuildID.html" title="A CodeView record containing an ELF build-id.">CodeViewRecordBuildID</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpModuleCodeViewRecordBuildIDWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpModuleCodeViewRecordPDB20Writer.html">MinidumpModuleCodeViewRecordPDB20Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1CodeViewRecordPDB20.html" title="A CodeView record linking to a .pdb 2.0 file.">CodeViewRecordPDB20</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpModuleCodeViewRecordPDB20Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpModuleCodeViewRecordPDB70Writer.html">MinidumpModuleCodeViewRecordPDB70Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1CodeViewRecordPDB70.html" title="A CodeView record linking to a .pdb 7.0 file.">CodeViewRecordPDB70</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpModuleCodeViewRecordPDB70Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpModuleCodeViewRecordWriter.html">MinidumpModuleCodeViewRecordWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for writers of CodeView records referenced by <a class="el" href="structMINIDUMP__MODULE.html#acd07e35faf066880eeabea8a91aa887a" title="A pointer to the module’s CodeView record, typically a link to its debugging information in crashpad:...">MINIDUMP_MODULE::CvRecord</a> in minidump files.  <a href="classcrashpad_1_1MinidumpModuleCodeViewRecordWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfo.html">MinidumpModuleCrashpadInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional Crashpad-specific information about a module carried within a minidump file.  <a href="structcrashpad_1_1MinidumpModuleCrashpadInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfoLink.html">MinidumpModuleCrashpadInfoLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A link between a <a class="el" href="structMINIDUMP__MODULE.html" title="Information about a specific module loaded within the process at the time the snapshot was taken.">MINIDUMP_MODULE</a> structure and additional Crashpad-specific information about a module carried within a minidump file.  <a href="structcrashpad_1_1MinidumpModuleCrashpadInfoLink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfoList.html">MinidumpModuleCrashpadInfoList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional Crashpad-specific information about modules carried within a minidump file.  <a href="structcrashpad_1_1MinidumpModuleCrashpadInfoList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpModuleCrashpadInfoListWriter.html">MinidumpModuleCrashpadInfoListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfoList.html" title="Additional Crashpad-specific information about modules carried within a minidump file.">MinidumpModuleCrashpadInfoList</a> object in a minidump file, containing a list of <a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfo.html" title="Additional Crashpad-specific information about a module carried within a minidump file.">MinidumpModuleCrashpadInfo</a> objects.  <a href="classcrashpad_1_1MinidumpModuleCrashpadInfoListWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpModuleCrashpadInfoWriter.html">MinidumpModuleCrashpadInfoWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfo.html" title="Additional Crashpad-specific information about a module carried within a minidump file.">MinidumpModuleCrashpadInfo</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpModuleCrashpadInfoWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpModuleListWriter.html">MinidumpModuleListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__MODULE__LIST.html" title="Information about all modules loaded within the process at the time the snapshot was taken.">MINIDUMP_MODULE_LIST</a> stream in a minidump file, containing a list of <a class="el" href="structMINIDUMP__MODULE.html" title="Information about a specific module loaded within the process at the time the snapshot was taken.">MINIDUMP_MODULE</a> objects.  <a href="classcrashpad_1_1MinidumpModuleListWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpModuleMiscDebugRecordWriter.html">MinidumpModuleMiscDebugRecordWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for an <a class="el" href="structIMAGE__DEBUG__MISC.html" title="Miscellaneous debugging record.">IMAGE_DEBUG_MISC</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpModuleMiscDebugRecordWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpModuleWriter.html">MinidumpModuleWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__MODULE.html" title="Information about a specific module loaded within the process at the time the snapshot was taken.">MINIDUMP_MODULE</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpModuleWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpRVAList.html">MinidumpRVAList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8" title="An offset within a minidump file, relative to the start of its MINIDUMP_HEADER.">RVA</a> pointers.  <a href="structcrashpad_1_1MinidumpRVAList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionary.html">MinidumpSimpleStringDictionary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of key-value pairs.  <a href="structcrashpad_1_1MinidumpSimpleStringDictionary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionaryEntry.html">MinidumpSimpleStringDictionaryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A key-value pair.  <a href="structcrashpad_1_1MinidumpSimpleStringDictionaryEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpSimpleStringDictionaryEntryWriter.html">MinidumpSimpleStringDictionaryEntryWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionaryEntry.html" title="A key-value pair.">MinidumpSimpleStringDictionaryEntry</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpSimpleStringDictionaryEntryWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpSimpleStringDictionaryWriter.html">MinidumpSimpleStringDictionaryWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionary.html" title="A list of key-value pairs.">MinidumpSimpleStringDictionary</a> object in a minidump file, containing a list of <a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionaryEntry.html" title="A key-value pair.">MinidumpSimpleStringDictionaryEntry</a> objects.  <a href="classcrashpad_1_1MinidumpSimpleStringDictionaryWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpStream.html">MinidumpStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a minidump stream along with its stream ID.  <a href="classcrashpad_1_1MinidumpStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpSystemInfoWriter.html">MinidumpSystemInfoWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__SYSTEM__INFO.html" title="Information about the system that hosted the process that the minidump file contains a snapshot of.">MINIDUMP_SYSTEM_INFO</a> stream in a minidump file.  <a href="classcrashpad_1_1MinidumpSystemInfoWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpThreadListWriter.html">MinidumpThreadListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__THREAD__LIST.html" title="Information about all threads within the process.">MINIDUMP_THREAD_LIST</a> stream in a minidump file, containing a list of <a class="el" href="structMINIDUMP__THREAD.html" title="Information about a specific thread within the process.">MINIDUMP_THREAD</a> objects.  <a href="classcrashpad_1_1MinidumpThreadListWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpThreadNameListWriter.html">MinidumpThreadNameListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__THREAD__NAME__LIST.html" title="Variable-sized struct which contains a list of MINIDUMP_THREAD_NAME structs.">MINIDUMP_THREAD_NAME_LIST</a> stream in a minidump file, containing a list of <a class="el" href="structMINIDUMP__THREAD__NAME.html" title="Contains the name of the thread with the given thread ID.">MINIDUMP_THREAD_NAME</a> objects.  <a href="classcrashpad_1_1MinidumpThreadNameListWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpThreadNameWriter.html">MinidumpThreadNameWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__THREAD__NAME.html" title="Contains the name of the thread with the given thread ID.">MINIDUMP_THREAD_NAME</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpThreadNameWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpThreadWriter.html">MinidumpThreadWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__THREAD.html" title="Information about a specific thread within the process.">MINIDUMP_THREAD</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpThreadWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpUnloadedModuleListWriter.html">MinidumpUnloadedModuleListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__UNLOADED__MODULE__LIST.html" title="Information about all modules recorded as unloaded when the snapshot was taken.">MINIDUMP_UNLOADED_MODULE_LIST</a> stream in a minidump file, containing a list of <a class="el" href="structMINIDUMP__UNLOADED__MODULE.html" title="Information about a specific module that was recorded as being unloaded at the time the snapshot was ...">MINIDUMP_UNLOADED_MODULE</a> objects.  <a href="classcrashpad_1_1MinidumpUnloadedModuleListWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpUnloadedModuleWriter.html">MinidumpUnloadedModuleWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a <a class="el" href="structMINIDUMP__UNLOADED__MODULE.html" title="Information about a specific module that was recorded as being unloaded at the time the snapshot was ...">MINIDUMP_UNLOADED_MODULE</a> object in a minidump file.  <a href="classcrashpad_1_1MinidumpUnloadedModuleWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpUserExtensionStreamDataSource.html">MinidumpUserExtensionStreamDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a user extension data stream in a minidump.  <a href="classcrashpad_1_1MinidumpUserExtensionStreamDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpUserStreamWriter.html">MinidumpUserStreamWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The writer for a MINIDUMP_USER_STREAM in a minidump file.  <a href="classcrashpad_1_1MinidumpUserStreamWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpUTF8String.html">MinidumpUTF8String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable-length UTF-8-encoded string carried within a minidump file.  <a href="structcrashpad_1_1MinidumpUTF8String.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpXSaveAMD64CetU.html">MinidumpXSaveAMD64CetU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XSAVE_CET_U_FORMAT.  <a href="classcrashpad_1_1MinidumpXSaveAMD64CetU.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1MinidumpXSaveAreaHeader.html">MinidumpXSaveAreaHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XSAVE_AREA_HEADER.  <a href="structcrashpad_1_1MinidumpXSaveAreaHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1MinidumpXSaveFeatureAMD64.html">MinidumpXSaveFeatureAMD64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an xsave feature that knows where and how big it is.  <a href="classcrashpad_1_1MinidumpXSaveFeatureAMD64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ModuleSnapshot.html">ModuleSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract interface to a snapshot representing a code module (binary image) loaded into a snapshot process.  <a href="classcrashpad_1_1ModuleSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1NoCfiIcall.html">NoCfiIcall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables cfi-icall for calls made through a function pointer.  <a href="classcrashpad_1_1NoCfiIcall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1NotifyServer.html">NotifyServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A server interface for the <code>notify</code> Mach subsystem.  <a href="classcrashpad_1_1NotifyServer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ObjcExceptionDelegate.html">ObjcExceptionDelegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for notifying the <a class="el" href="classcrashpad_1_1CrashpadClient.html" title="The primary interface for an application to have Crashpad monitor it for crashes.">CrashpadClient</a> of NSExceptions.  <a href="classcrashpad_1_1ObjcExceptionDelegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Paths.html">Paths</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to obtain paths.  <a href="classcrashpad_1_1Paths.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PEImageAnnotationsReader.html">PEImageAnnotationsReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader of annotations stored in a PE image mapped into another process.  <a href="classcrashpad_1_1PEImageAnnotationsReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PEImageReader.html">PEImageReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader for PE images mapped into another process.  <a href="classcrashpad_1_1PEImageReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PEImageResourceReader.html">PEImageResourceReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader for resources stored in PE images mapped into another process.  <a href="classcrashpad_1_1PEImageResourceReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessInfo.html">ProcessInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers information about a process given its <code>HANDLE</code>. This consists primarily of information stored in the Process Environment Block.  <a href="classcrashpad_1_1ProcessInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessMemory.html">ProcessMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for accessing the memory of another process.  <a href="classcrashpad_1_1ProcessMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessMemoryFuchsia.html">ProcessMemoryFuchsia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the memory of another Fuchsia process.  <a href="classcrashpad_1_1ProcessMemoryFuchsia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessMemoryLinux.html">ProcessMemoryLinux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the memory of another Linux process.  <a href="classcrashpad_1_1ProcessMemoryLinux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessMemoryMac.html">ProcessMemoryMac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the memory of another Mach task.  <a href="classcrashpad_1_1ProcessMemoryMac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessMemoryRange.html">ProcessMemoryRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides range protected access to the memory of another process.  <a href="classcrashpad_1_1ProcessMemoryRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessMemorySanitized.html">ProcessMemorySanitized</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanitized access to the memory of another process.  <a href="classcrashpad_1_1ProcessMemorySanitized.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessMemoryWin.html">ProcessMemoryWin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the memory of another Windows process.  <a href="classcrashpad_1_1ProcessMemoryWin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessReaderFuchsia.html">ProcessReaderFuchsia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses information about another process, identified by a Fuchsia process.  <a href="classcrashpad_1_1ProcessReaderFuchsia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessReaderLinux.html">ProcessReaderLinux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses information about another process, identified by a process ID.  <a href="classcrashpad_1_1ProcessReaderLinux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessReaderMac.html">ProcessReaderMac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses information about another process, identified by a Mach task.  <a href="classcrashpad_1_1ProcessReaderMac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessReaderWin.html">ProcessReaderWin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses information about another process, identified by a <code>HANDLE</code>.  <a href="classcrashpad_1_1ProcessReaderWin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessSnapshot.html">ProcessSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract interface to a snapshot representing the state of a process.  <a href="classcrashpad_1_1ProcessSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessSnapshotFuchsia.html">ProcessSnapshotFuchsia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a> of a running (or crashed) process running on a Fuchsia system. This class is not yet implemented.  <a href="classcrashpad_1_1ProcessSnapshotFuchsia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessSnapshotLinux.html">ProcessSnapshotLinux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a> of a running (or crashed) process running on a Linux system.  <a href="classcrashpad_1_1ProcessSnapshotLinux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessSnapshotMac.html">ProcessSnapshotMac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a> of a running (or crashed) process running on a macOS system.  <a href="classcrashpad_1_1ProcessSnapshotMac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessSnapshotMinidump.html">ProcessSnapshotMinidump</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a> based on a minidump file.  <a href="classcrashpad_1_1ProcessSnapshotMinidump.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessSnapshotSanitized.html">ProcessSnapshotSanitized</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a> which wraps and filters sensitive information from another <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a>.  <a href="classcrashpad_1_1ProcessSnapshotSanitized.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessSnapshotWin.html">ProcessSnapshotWin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a> of a running (or crashed) process running on a Windows system.  <a href="classcrashpad_1_1ProcessSnapshotWin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcessSubrangeReader.html">ProcessSubrangeReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="classcrashpad_1_1ProcessReaderWin.html" title="Accesses information about another process, identified by a HANDLE.">ProcessReaderWin</a> that only allows a specific subrange to be read from.  <a href="classcrashpad_1_1ProcessSubrangeReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ProcStatReader.html">ProcStatReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the /proc/[pid]/stat file for a thread.  <a href="classcrashpad_1_1ProcStatReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PruneCondition.html">PruneCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class for evaluating crash reports for deletion.  <a href="classcrashpad_1_1PruneCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PruneCrashReportThread.html">PruneCrashReportThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread that periodically prunes crash reports from the database using the specified condition.  <a href="classcrashpad_1_1PruneCrashReportThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PruneIntermediateDumpsAndCrashReportsThread.html">PruneIntermediateDumpsAndCrashReportsThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread that periodically prunes crash reports from the database using the specified condition, and any leftover locked intermediate dumps.  <a href="classcrashpad_1_1PruneIntermediateDumpsAndCrashReportsThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PtraceBroker.html">PtraceBroker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a <a class="el" href="classcrashpad_1_1PtraceConnection.html" title="Provides an interface for making ptrace requests against a process and its threads.">PtraceConnection</a> over a socket.  <a href="classcrashpad_1_1PtraceBroker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PtraceClient.html">PtraceClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a <a class="el" href="classcrashpad_1_1PtraceConnection.html" title="Provides an interface for making ptrace requests against a process and its threads.">PtraceConnection</a> over a socket.  <a href="classcrashpad_1_1PtraceClient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PtraceConnection.html">PtraceConnection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an interface for making <code>ptrace</code> requests against a process and its threads.  <a href="classcrashpad_1_1PtraceConnection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Ptracer.html">Ptracer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an architecturally agnostic interface for collecting information with <code>ptrace</code>.  <a href="classcrashpad_1_1Ptracer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1PtraceStrategyDecider.html">PtraceStrategyDecider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for deciding how the handler should <code>ptrace</code> a client.  <a href="classcrashpad_1_1PtraceStrategyDecider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1RangeSet.html">RangeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256" title="Type used to represent an address in a process, potentially across bitness.">VMAddress</a> ranges.  <a href="classcrashpad_1_1RangeSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1RegistrationRequest.html">RegistrationRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A client registration request.  <a href="structcrashpad_1_1RegistrationRequest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1RegistrationResponse.html">RegistrationResponse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A client registration response.  <a href="structcrashpad_1_1RegistrationResponse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1RingBufferAnnotation.html">RingBufferAnnotation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="classcrashpad_1_1Annotation.html" title="Base class for an annotation, which records a name-value pair of arbitrary data when set.">Annotation</a></code> which wraps a <code>LengthDelimitedRingBuffer</code> of up to <code>Capacity</code> bytes in length.  <a href="classcrashpad_1_1RingBufferAnnotation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1RingBufferData.html">RingBufferData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for a ring buffer which can hold up to <code><a class="el" href="#aa7ef9aa2375aa179ab428923628fbc12" title="Capacity of a RingBufferData, in bytes.">RingBufferCapacity</a></code> bytes of Base 128-varint delimited variable-length items.  <a href="structcrashpad_1_1RingBufferData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1RTL__UNLOAD__EVENT__TRACE.html">RTL_UNLOAD_EVENT_TRACE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1SanitizationAllowedMemoryRanges.html">SanitizationAllowedMemoryRanges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a list of allowed memory ranges.  <a href="structcrashpad_1_1SanitizationAllowedMemoryRanges.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1SanitizationInformation.html">SanitizationInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struture containing information about how snapshots should be sanitized.  <a href="structcrashpad_1_1SanitizationInformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ScopedForbidReturn.html">ScopedForbidReturn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that a scope must not be exited while unsafe.  <a href="classcrashpad_1_1ScopedForbidReturn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ScopedMmap.html">ScopedMmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains a memory-mapped region created by <code>mmap()</code>.  <a href="classcrashpad_1_1ScopedMmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ScopedProcessSuspend.html">ScopedProcessSuspend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the suspension of another process.  <a href="classcrashpad_1_1ScopedProcessSuspend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ScopedPrSetDumpable.html">ScopedPrSetDumpable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ScopedPrSetPtracer.html">ScopedPrSetPtracer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ScopedPtraceAttach.html">ScopedPtraceAttach</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains a <code>ptrace()</code> attachment to a process.  <a href="classcrashpad_1_1ScopedPtraceAttach.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1ScopedRegistryKeyCloseTraits.html">ScopedRegistryKeyCloseTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1ScopedRemoveFileTraits.html">ScopedRemoveFileTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ScopedSetEvent.html">ScopedSetEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>SetEvent()</code> on destruction at latest.  <a href="classcrashpad_1_1ScopedSetEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ScopedSpinGuard.html">ScopedSpinGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scoped mutual-exclusion guard wrapping a <code><a class="el" href="structcrashpad_1_1SpinGuardState.html" title="Spinlock state for ScopedSpinGuard.">SpinGuardState</a></code> with RAII semantics.  <a href="classcrashpad_1_1ScopedSpinGuard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ScopedTaskSuspend.html">ScopedTaskSuspend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the suspension of another task.  <a href="classcrashpad_1_1ScopedTaskSuspend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Semaphore.html">Semaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An anonymous in-process counting sempahore.  <a href="classcrashpad_1_1Semaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncrashpad_1_1ServerToClientMessage.html">ServerToClientMessage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The response sent back to the client via <a class="el" href="#a0d993c28de1644014bf81bac75817757" title="Connect over the given pipe_name, passing message to the server, storing the server&#39;s reply into resp...">SendToCrashHandlerServer()</a>.  <a href="unioncrashpad_1_1ServerToClientMessage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1SessionEndWatcher.html">SessionEndWatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a hidden window and waits for a <code>WM_ENDSESSION</code> message, indicating that the session is ending and the application should terminate.  <a href="classcrashpad_1_1SessionEndWatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Settings.html">Settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for accessing and modifying the settings of a <a class="el" href="classcrashpad_1_1CrashReportDatabase.html" title="An interface for managing a collection of crash report files and metadata associated with the crash r...">CrashReportDatabase</a>.  <a href="classcrashpad_1_1Settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1ShutdownRequest.html">ShutdownRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A message only sent to the server by itself to trigger shutdown.  <a href="structcrashpad_1_1ShutdownRequest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Signals.html">Signals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for handling POSIX signals.  <a href="classcrashpad_1_1Signals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1SnapshotMinidumpMemoryWriter.html">SnapshotMinidumpMemoryWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for writers of memory ranges pointed to by <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> objects in a minidump file.  <a href="classcrashpad_1_1SnapshotMinidumpMemoryWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1SpinGuardState.html">SpinGuardState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spinlock state for <code><a class="el" href="classcrashpad_1_1ScopedSpinGuard.html" title="A scoped mutual-exclusion guard wrapping a SpinGuardState with RAII semantics.">ScopedSpinGuard</a></code>.  <a href="structcrashpad_1_1SpinGuardState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Stoppable.html">Stoppable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for operations that may be Started and Stopped.  <a href="classcrashpad_1_1Stoppable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1StringAnnotation.html">StringAnnotation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An.  <a href="classcrashpad_1_1StringAnnotation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1StringFile.html">StringFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A file reader and writer backed by a virtual file, as opposed to a file on disk or other operating system file descriptor-based file.  <a href="classcrashpad_1_1StringFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1StringHTTPBodyStream.html">StringHTTPBodyStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a> that turns a fixed string into a stream.  <a href="classcrashpad_1_1StringHTTPBodyStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1SystemSnapshot.html">SystemSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract interface to a snapshot representing the state of a system, comprising an operating system, CPU architecture, and various other characteristics.  <a href="classcrashpad_1_1SystemSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1TestCrashpadInfo.html">TestCrashpadInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic thread abstraction. Users should derive from this class and implement ThreadMain().  <a href="classcrashpad_1_1Thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncrashpad_1_1ThreadContext.html">ThreadContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of general purpose registers for an architecture family.  <a href="unioncrashpad_1_1ThreadContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1ThreadInfo.html">ThreadInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of <code>ptrace</code>-able information about a thread.  <a href="structcrashpad_1_1ThreadInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ThreadLogMessages.html">ThreadLogMessages</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Captures log messages produced on the current thread during an object’s lifetime.  <a href="classcrashpad_1_1ThreadLogMessages.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ThreadSafeVector.html">ThreadSafeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for a <code>std::vector&lt;&gt;</code> that can be accessed safely from multiple threads.  <a href="classcrashpad_1_1ThreadSafeVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ThreadSnapshot.html">ThreadSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract interface to a snapshot representing a thread (lightweight process) present in a snapshot process.  <a href="classcrashpad_1_1ThreadSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ToolSupport.html">ToolSupport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common functions used by command line tools.  <a href="classcrashpad_1_1ToolSupport.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1Traits32.html">Traits32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1Traits64.html">Traits64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1TSimpleAddressRangeBag.html">TSimpleAddressRangeBag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bag implementation using a fixed amount of storage, so that it does not perform any dynamic allocations for its operations.  <a href="classcrashpad_1_1TSimpleAddressRangeBag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1TSimpleStringDictionary.html">TSimpleStringDictionary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map/dictionary collection implementation using a fixed amount of storage, so that it does not perform any dynamic allocations for its operations.  <a href="classcrashpad_1_1TSimpleStringDictionary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1uint128__struct.html">uint128_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 128-bit quantity.  <a href="structcrashpad_1_1uint128__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1UniversalMachExcServer.html">UniversalMachExcServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A server interface for the <code>exc</code> and <code>mach_exc</code> Mach subsystems, unified to handle exceptions delivered to either subsystem, and simplified to have only a single interface method needing implementation.  <a href="classcrashpad_1_1UniversalMachExcServer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1UnixCredentialSocket.html">UnixCredentialSocket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for communicating over <code>SO_PASSCRED</code> enabled <code>AF_UNIX</code> sockets.  <a href="classcrashpad_1_1UnixCredentialSocket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1UnloadedModuleSnapshot.html">UnloadedModuleSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about an unloaded module that was previously loaded into a snapshot process.  <a href="classcrashpad_1_1UnloadedModuleSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1UserMinidumpStream.html">UserMinidumpStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information describing a custom user data stream in a minidump.  <a href="classcrashpad_1_1UserMinidumpStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1UserStreamDataSource.html">UserStreamDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extensibility interface for embedders who wish to add custom streams to minidumps.  <a href="classcrashpad_1_1UserStreamDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1UUID.html">UUID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A universally unique identifier (UUID).  <a href="structcrashpad_1_1UUID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1WeakFileHandleFileReader.html">WeakFileHandleFileReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A file reader backed by a <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>.  <a href="classcrashpad_1_1WeakFileHandleFileReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1WeakFileHandleFileWriter.html">WeakFileHandleFileWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A file writer backed by a <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>.  <a href="classcrashpad_1_1WeakFileHandleFileWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1WerRegistration.html">WerRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context to be passed to WerRegisterRuntimeExceptionModule().  <a href="structcrashpad_1_1WerRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1WorkerThread.html">WorkerThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1WorkerThread.html" title="A WorkerThread executes its Delegate&#39;s DoWork method repeatedly on a dedicated thread at a set time i...">WorkerThread</a> executes its <a class="el" href="classcrashpad_1_1WorkerThread_1_1Delegate.html" title="An interface for doing work on a WorkerThread.">Delegate</a>'s DoWork method repeatedly on a dedicated thread at a set time interval.  <a href="classcrashpad_1_1WorkerThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1WritableIoVec.html">WritableIoVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <code>iovec</code> with a <code>const</code> <a class="el" href="structcrashpad_1_1WritableIoVec.html#abcf5d801519cf50aa286c3baa8f55d05" title="The base address of a memory region for output.">iov_base</a> field.  <a href="structcrashpad_1_1WritableIoVec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1ZlibOutputStream.html">ZlibOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class wraps zlib into <em class="arg">OutputStreamInterface</em>.  <a href="classcrashpad_1_1ZlibOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a95ae81abfb73416067e266451015b3d6" id="r_a95ae81abfb73416067e266451015b3d6"><td class="memItemLeft" align="right" valign="top"><a id="a95ae81abfb73416067e266451015b3d6" name="a95ae81abfb73416067e266451015b3d6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UserDataMinidumpStreamHandle</b> = <a class="el" href="structcrashpad_1_1internal_1_1UserDataMinidumpStreamListEntry.html">internal::UserDataMinidumpStreamListEntry</a></td></tr>
<tr class="separator:a95ae81abfb73416067e266451015b3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ef9aa2375aa179ab428923628fbc12" id="r_aa7ef9aa2375aa179ab428923628fbc12"><td class="memItemLeft" align="right" valign="top"><a id="aa7ef9aa2375aa179ab428923628fbc12" name="aa7ef9aa2375aa179ab428923628fbc12"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RingBufferCapacity</b> = uint32_t</td></tr>
<tr class="memdesc:aa7ef9aa2375aa179ab428923628fbc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacity of a <code><a class="el" href="structcrashpad_1_1RingBufferData.html" title="Storage for a ring buffer which can hold up to RingBufferCapacity bytes of Base 128-varint delimited ...">RingBufferData</a></code>, in bytes. <br /></td></tr>
<tr class="separator:aa7ef9aa2375aa179ab428923628fbc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ac7f59200f3fee264cf9f7248a8910" id="r_ac3ac7f59200f3fee264cf9f7248a8910"><td class="memItemLeft" align="right" valign="top"><a id="ac3ac7f59200f3fee264cf9f7248a8910" name="ac3ac7f59200f3fee264cf9f7248a8910"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RingBufferAnnotationCapacity</b> = <a class="el" href="#aa7ef9aa2375aa179ab428923628fbc12">RingBufferCapacity</a></td></tr>
<tr class="memdesc:ac3ac7f59200f3fee264cf9f7248a8910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacity of <code><a class="el" href="classcrashpad_1_1RingBufferAnnotation.html" title="An Annotation which wraps a LengthDelimitedRingBuffer of up to Capacity bytes in length.">RingBufferAnnotation</a></code>, in bytes. <br /></td></tr>
<tr class="separator:ac3ac7f59200f3fee264cf9f7248a8910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddac921c80ea43961025cacea5e92f1" id="r_a0ddac921c80ea43961025cacea5e92f1"><td class="memItemLeft" align="right" valign="top"><a id="a0ddac921c80ea43961025cacea5e92f1" name="a0ddac921c80ea43961025cacea5e92f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleAddressRangeBag</b> = <a class="el" href="classcrashpad_1_1TSimpleAddressRangeBag.html">TSimpleAddressRangeBag</a>&lt;64&gt;</td></tr>
<tr class="memdesc:a0ddac921c80ea43961025cacea5e92f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1TSimpleAddressRangeBag.html" title="A bag implementation using a fixed amount of storage, so that it does not perform any dynamic allocat...">TSimpleAddressRangeBag</a> with default template parameters. <br /></td></tr>
<tr class="separator:a0ddac921c80ea43961025cacea5e92f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234f585958271d359e8f1a4ae3f95553" id="r_a234f585958271d359e8f1a4ae3f95553"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a234f585958271d359e8f1a4ae3f95553">SimpleStringDictionary</a> = <a class="el" href="classcrashpad_1_1TSimpleStringDictionary.html">TSimpleStringDictionary</a>&lt;256, 256, 64&gt;</td></tr>
<tr class="memdesc:a234f585958271d359e8f1a4ae3f95553"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1TSimpleStringDictionary.html" title="A map/dictionary collection implementation using a fixed amount of storage, so that it does not perfo...">TSimpleStringDictionary</a> with default template parameters.  <br /></td></tr>
<tr class="separator:a234f585958271d359e8f1a4ae3f95553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3893b3669fe314ad5485f98446ae7dc0" id="r_a3893b3669fe314ad5485f98446ae7dc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3893b3669fe314ad5485f98446ae7dc0">UserStreamDataSources</a></td></tr>
<tr class="separator:a3893b3669fe314ad5485f98446ae7dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f88ce9692185d6885a6ca33d9a1769a" id="r_a5f88ce9692185d6885a6ca33d9a1769a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f88ce9692185d6885a6ca33d9a1769a">MinidumpUTF16StringListWriter</a></td></tr>
<tr class="separator:a5f88ce9692185d6885a6ca33d9a1769a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51b94450e9ed369f88eb5145b79a294" id="r_ae51b94450e9ed369f88eb5145b79a294"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae51b94450e9ed369f88eb5145b79a294">MinidumpUTF8StringListWriter</a></td></tr>
<tr class="separator:ae51b94450e9ed369f88eb5145b79a294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1c44f1c92c4ae031829f6f1b255268" id="r_a6e1c44f1c92c4ae031829f6f1b255268"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e1c44f1c92c4ae031829f6f1b255268">MinidumpThreadIDMap</a> = std::map&lt;uint64_t, uint32_t&gt;</td></tr>
<tr class="memdesc:a6e1c44f1c92c4ae031829f6f1b255268"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map that connects 64-bit snapshot thread IDs to 32-bit minidump thread IDs.  <br /></td></tr>
<tr class="separator:a6e1c44f1c92c4ae031829f6f1b255268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23e97af4fc55d89e2f7f6775138980c" id="r_aa23e97af4fc55d89e2f7f6775138980c"><td class="memItemLeft" align="right" valign="top"><a id="aa23e97af4fc55d89e2f7f6775138980c" name="aa23e97af4fc55d89e2f7f6775138980c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FileHandle</b> = int</td></tr>
<tr class="memdesc:aa23e97af4fc55d89e2f7f6775138980c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-specific alias for a low-level file handle. <br /></td></tr>
<tr class="separator:aa23e97af4fc55d89e2f7f6775138980c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e870ea9156f1bfdff1b998a77cdd9e" id="r_a73e870ea9156f1bfdff1b998a77cdd9e"><td class="memItemLeft" align="right" valign="top"><a id="a73e870ea9156f1bfdff1b998a77cdd9e" name="a73e870ea9156f1bfdff1b998a77cdd9e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FileOffset</b> = off_t</td></tr>
<tr class="memdesc:a73e870ea9156f1bfdff1b998a77cdd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-specific alias for a position in an open file. <br /></td></tr>
<tr class="separator:a73e870ea9156f1bfdff1b998a77cdd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3a0ca2e9e37905b425f2cb1b428e7e" id="r_a2d3a0ca2e9e37905b425f2cb1b428e7e"><td class="memItemLeft" align="right" valign="top"><a id="a2d3a0ca2e9e37905b425f2cb1b428e7e" name="a2d3a0ca2e9e37905b425f2cb1b428e7e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ScopedFileHandle</b> = base::ScopedFD</td></tr>
<tr class="memdesc:a2d3a0ca2e9e37905b425f2cb1b428e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scoped wrapper of a <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>. <br /></td></tr>
<tr class="separator:a2d3a0ca2e9e37905b425f2cb1b428e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbae3880f57681cd84026b2c5a042ca" id="r_a9cbae3880f57681cd84026b2c5a042ca"><td class="memItemLeft" align="right" valign="top"><a id="a9cbae3880f57681cd84026b2c5a042ca" name="a9cbae3880f57681cd84026b2c5a042ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FileOperationResult</b> = ssize_t</td></tr>
<tr class="memdesc:a9cbae3880f57681cd84026b2c5a042ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return value of read and write calls. <br /></td></tr>
<tr class="separator:a9cbae3880f57681cd84026b2c5a042ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1196c8542180d5e524acf5c12c70400" id="r_af1196c8542180d5e524acf5c12c70400"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1196c8542180d5e524acf5c12c70400">ScopedRemoveFile</a></td></tr>
<tr class="separator:af1196c8542180d5e524acf5c12c70400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac349d7ee7fdd6c312073c0e9d9af3db6" id="r_ac349d7ee7fdd6c312073c0e9d9af3db6"><td class="memItemLeft" align="right" valign="top"><a id="ac349d7ee7fdd6c312073c0e9d9af3db6" name="ac349d7ee7fdd6c312073c0e9d9af3db6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LinuxVMAddress</b> = uint64_t</td></tr>
<tr class="memdesc:ac349d7ee7fdd6c312073c0e9d9af3db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent an address in a process, potentially across bitness. <br /></td></tr>
<tr class="separator:ac349d7ee7fdd6c312073c0e9d9af3db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03f17b393b7a4f00279d2c37550b441" id="r_af03f17b393b7a4f00279d2c37550b441"><td class="memItemLeft" align="right" valign="top"><a id="af03f17b393b7a4f00279d2c37550b441" name="af03f17b393b7a4f00279d2c37550b441"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LinuxVMSize</b> = uint64_t</td></tr>
<tr class="memdesc:af03f17b393b7a4f00279d2c37550b441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent the size of a memory range (with a <a class="el" href="#ac349d7ee7fdd6c312073c0e9d9af3db6" title="Type used to represent an address in a process, potentially across bitness.">LinuxVMAddress</a>), potentially across bitness. <br /></td></tr>
<tr class="separator:af03f17b393b7a4f00279d2c37550b441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad894185a26f2a63c3c24170b03fa096a" id="r_ad894185a26f2a63c3c24170b03fa096a"><td class="memItemLeft" align="right" valign="top"><a id="ad894185a26f2a63c3c24170b03fa096a" name="ad894185a26f2a63c3c24170b03fa096a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LinuxVMOffset</b> = int64_t</td></tr>
<tr class="memdesc:ad894185a26f2a63c3c24170b03fa096a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent an offset from a <a class="el" href="#ac349d7ee7fdd6c312073c0e9d9af3db6" title="Type used to represent an address in a process, potentially across bitness.">LinuxVMAddress</a>, potentially across bitness. <br /></td></tr>
<tr class="separator:ad894185a26f2a63c3c24170b03fa096a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b6bbc20b0887c35b955e2898b968fd" id="r_a39b6bbc20b0887c35b955e2898b968fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39b6bbc20b0887c35b955e2898b968fd">CheckedLinuxAddressRange</a></td></tr>
<tr class="memdesc:a39b6bbc20b0887c35b955e2898b968fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that a range, composed of a base and a size, does not overflow the pointer type of the process it describes a range in.  <br /></td></tr>
<tr class="separator:a39b6bbc20b0887c35b955e2898b968fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9746092c7c995c911caf433b7f1abd15" id="r_a9746092c7c995c911caf433b7f1abd15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9746092c7c995c911caf433b7f1abd15">CheckedMachAddressRange</a></td></tr>
<tr class="memdesc:a9746092c7c995c911caf433b7f1abd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that a range, composed of a base and a size, does not overflow the pointer type of the process it describes a range in.  <br /></td></tr>
<tr class="separator:a9746092c7c995c911caf433b7f1abd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a2e5f928712c15766a756cd2035d90" id="r_ae8a2e5f928712c15766a756cd2035d90"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8a2e5f928712c15766a756cd2035d90">ConstThreadState</a> = const natural_t*</td></tr>
<tr class="memdesc:ae8a2e5f928712c15766a756cd2035d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const version of <code>thread_state_t</code>.  <br /></td></tr>
<tr class="separator:ae8a2e5f928712c15766a756cd2035d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd63ad5a7c13f493e8d1e37ef7801bce" id="r_abd63ad5a7c13f493e8d1e37ef7801bce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd63ad5a7c13f493e8d1e37ef7801bce">MachMessageDeadline</a> = uint64_t</td></tr>
<tr class="memdesc:abd63ad5a7c13f493e8d1e37ef7801bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time before which a <a class="el" href="#a35293418a0b7637a00631807ac4b431e" title="Runs mach_msg() with a deadline, as opposed to a timeout.">MachMessageWithDeadline()</a> call should complete.  <br /></td></tr>
<tr class="separator:abd63ad5a7c13f493e8d1e37ef7801bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b472f487657ece8e0a9a662a13b2256" id="r_a3b472f487657ece8e0a9a662a13b2256"><td class="memItemLeft" align="right" valign="top"><a id="a3b472f487657ece8e0a9a662a13b2256" name="a3b472f487657ece8e0a9a662a13b2256"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VMAddress</b> = uint64_t</td></tr>
<tr class="memdesc:a3b472f487657ece8e0a9a662a13b2256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent an address in a process, potentially across bitness. <br /></td></tr>
<tr class="separator:a3b472f487657ece8e0a9a662a13b2256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc29d9e6679a899150179ba3ce896072" id="r_afc29d9e6679a899150179ba3ce896072"><td class="memItemLeft" align="right" valign="top"><a id="afc29d9e6679a899150179ba3ce896072" name="afc29d9e6679a899150179ba3ce896072"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VMSize</b> = uint64_t</td></tr>
<tr class="memdesc:afc29d9e6679a899150179ba3ce896072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent the size of a memory range (with a <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256" title="Type used to represent an address in a process, potentially across bitness.">VMAddress</a>), potentially across bitness. <br /></td></tr>
<tr class="separator:afc29d9e6679a899150179ba3ce896072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2830f883069635702408e21571dfe2" id="r_a4f2830f883069635702408e21571dfe2"><td class="memItemLeft" align="right" valign="top"><a id="a4f2830f883069635702408e21571dfe2" name="a4f2830f883069635702408e21571dfe2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VMOffset</b> = std::make_signed&lt;<a class="el" href="#afc29d9e6679a899150179ba3ce896072">VMSize</a>&gt;::type</td></tr>
<tr class="memdesc:a4f2830f883069635702408e21571dfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent an offset from a <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256" title="Type used to represent an address in a process, potentially across bitness.">VMAddress</a>, potentially across bitness. <br /></td></tr>
<tr class="separator:a4f2830f883069635702408e21571dfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cc715d0526f5bd9909027403f30d7d" id="r_a18cc715d0526f5bd9909027403f30d7d"><td class="memItemLeft" align="right" valign="top"><a id="a18cc715d0526f5bd9909027403f30d7d" name="a18cc715d0526f5bd9909027403f30d7d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SymbolicConstantToStringOptions</b> = unsigned int</td></tr>
<tr class="memdesc:a18cc715d0526f5bd9909027403f30d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitfield containing values of <a class="el" href="#a7856b82b71167792ea6103debb5105ed" title="Options for various *ToString functions in symbolic_constants_* files.">SymbolicConstantToStringOptionBits</a>. <br /></td></tr>
<tr class="separator:a18cc715d0526f5bd9909027403f30d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ec34d8dc54f6d191e3ddae3eb79170" id="r_a78ec34d8dc54f6d191e3ddae3eb79170"><td class="memItemLeft" align="right" valign="top"><a id="a78ec34d8dc54f6d191e3ddae3eb79170" name="a78ec34d8dc54f6d191e3ddae3eb79170"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StringToSymbolicConstantOptions</b> = unsigned int</td></tr>
<tr class="memdesc:a78ec34d8dc54f6d191e3ddae3eb79170"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitfield containing values of <a class="el" href="#a8387ad067a7e6a1735ab97a1af450d2b" title="Options for various StringTo* functions in symbolic_constants_* files.">StringToSymbolicConstantOptionBits</a>. <br /></td></tr>
<tr class="separator:a78ec34d8dc54f6d191e3ddae3eb79170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1566962442daa1b5a2f67c4346dd7e50" id="r_a1566962442daa1b5a2f67c4346dd7e50"><td class="memItemLeft" align="right" valign="top"><a id="a1566962442daa1b5a2f67c4346dd7e50" name="a1566962442daa1b5a2f67c4346dd7e50"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>HTTPHeaders</b> = std::map&lt;std::string, std::string&gt;</td></tr>
<tr class="memdesc:a1566962442daa1b5a2f67c4346dd7e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of HTTP header fields to their values. <br /></td></tr>
<tr class="separator:a1566962442daa1b5a2f67c4346dd7e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20680b609955bd1ed0f60f2c7ff46678" id="r_a20680b609955bd1ed0f60f2c7ff46678"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20680b609955bd1ed0f60f2c7ff46678">CheckedVMAddressRange</a></td></tr>
<tr class="memdesc:a20680b609955bd1ed0f60f2c7ff46678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that a range, composed of a base and a size, does not overflow the pointer type of the process it describes a range in.  <br /></td></tr>
<tr class="separator:a20680b609955bd1ed0f60f2c7ff46678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78e3cfff43d8e9e512f30955e370bb3" id="r_ab78e3cfff43d8e9e512f30955e370bb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab78e3cfff43d8e9e512f30955e370bb3">ScopedDIR</a> = base::ScopedGeneric&lt;DIR*, <a class="el" href="structcrashpad_1_1internal_1_1ScopedDIRCloseTraits.html">internal::ScopedDIRCloseTraits</a>&gt;</td></tr>
<tr class="memdesc:ab78e3cfff43d8e9e512f30955e370bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains a directory opened by <code>opendir</code>.  <br /></td></tr>
<tr class="separator:ab78e3cfff43d8e9e512f30955e370bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad772b944721fbe2c2cc4df22705bb6ec" id="r_ad772b944721fbe2c2cc4df22705bb6ec"><td class="memItemLeft" align="right" valign="top"><a id="ad772b944721fbe2c2cc4df22705bb6ec" name="ad772b944721fbe2c2cc4df22705bb6ec"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessID</b> = pid_t</td></tr>
<tr class="memdesc:ad772b944721fbe2c2cc4df22705bb6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for platform-specific type to represent a process. <br /></td></tr>
<tr class="separator:ad772b944721fbe2c2cc4df22705bb6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6c24d1765f8acd72a4c5da5ef93767" id="r_a0c6c24d1765f8acd72a4c5da5ef93767"><td class="memItemLeft" align="right" valign="top"><a id="a0c6c24d1765f8acd72a4c5da5ef93767" name="a0c6c24d1765f8acd72a4c5da5ef93767"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessMemoryNative</b> = <a class="el" href="classcrashpad_1_1ProcessMemoryFuchsia.html">ProcessMemoryFuchsia</a></td></tr>
<tr class="memdesc:a0c6c24d1765f8acd72a4c5da5ef93767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for platform-specific native implementation of <a class="el" href="classcrashpad_1_1ProcessMemory.html" title="Abstract base class for accessing the memory of another process.">ProcessMemory</a>. <br /></td></tr>
<tr class="separator:a0c6c24d1765f8acd72a4c5da5ef93767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c828ade5104707eb2b9e3d4141778b" id="r_a22c828ade5104707eb2b9e3d4141778b"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t Alignment = alignof(T)&gt; </td></tr>
<tr class="memitem:a22c828ade5104707eb2b9e3d4141778b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22c828ade5104707eb2b9e3d4141778b">AlignedVector</a> = std::vector&lt;T, <a class="el" href="structcrashpad_1_1AlignedAllocator.html">AlignedAllocator</a>&lt;T, Alignment&gt;&gt;</td></tr>
<tr class="memdesc:a22c828ade5104707eb2b9e3d4141778b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::vector</code> using <a class="el" href="structcrashpad_1_1AlignedAllocator.html" title="A standard allocator that aligns its allocations as requested, suitable for use as an allocator in st...">AlignedAllocator</a>.  <br /></td></tr>
<tr class="separator:a22c828ade5104707eb2b9e3d4141778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5872ff07ebe5bda9f532e8d3d752d77" id="r_ac5872ff07ebe5bda9f532e8d3d752d77"><td class="memItemLeft" align="right" valign="top"><a id="ac5872ff07ebe5bda9f532e8d3d752d77" name="ac5872ff07ebe5bda9f532e8d3d752d77"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>WinVMAddress</b> = uint64_t</td></tr>
<tr class="memdesc:ac5872ff07ebe5bda9f532e8d3d752d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent an address in a process, potentially across bitness. <br /></td></tr>
<tr class="separator:ac5872ff07ebe5bda9f532e8d3d752d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24b456d735f72df6141fd110542b24f" id="r_aa24b456d735f72df6141fd110542b24f"><td class="memItemLeft" align="right" valign="top"><a id="aa24b456d735f72df6141fd110542b24f" name="aa24b456d735f72df6141fd110542b24f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>WinVMSize</b> = uint64_t</td></tr>
<tr class="memdesc:aa24b456d735f72df6141fd110542b24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent the size of a memory range (with a <a class="el" href="#ac5872ff07ebe5bda9f532e8d3d752d77" title="Type used to represent an address in a process, potentially across bitness.">WinVMAddress</a>), potentially across bitness. <br /></td></tr>
<tr class="separator:aa24b456d735f72df6141fd110542b24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4f562873b273c153c1b9b92c39eafd" id="r_aee4f562873b273c153c1b9b92c39eafd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee4f562873b273c153c1b9b92c39eafd">CheckedWinAddressRange</a></td></tr>
<tr class="memdesc:aee4f562873b273c153c1b9b92c39eafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that a range, composed of a base and a size, does not overflow the pointer type of the process it describes a range in.  <br /></td></tr>
<tr class="separator:aee4f562873b273c153c1b9b92c39eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d238d84679f94a3ff54990a046c9d97" id="r_a9d238d84679f94a3ff54990a046c9d97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d238d84679f94a3ff54990a046c9d97">ScopedFileHANDLE</a></td></tr>
<tr class="separator:a9d238d84679f94a3ff54990a046c9d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b575c25dd6883dbbc08db53642cc2a9" id="r_a0b575c25dd6883dbbc08db53642cc2a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b575c25dd6883dbbc08db53642cc2a9">ScopedKernelHANDLE</a></td></tr>
<tr class="separator:a0b575c25dd6883dbbc08db53642cc2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa0022ad87e59bd944006a415df67d6" id="r_a9fa0022ad87e59bd944006a415df67d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa0022ad87e59bd944006a415df67d6">ScopedSearchHANDLE</a></td></tr>
<tr class="separator:a9fa0022ad87e59bd944006a415df67d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af880f0a616015d21f84fe942637b98ce" id="r_af880f0a616015d21f84fe942637b98ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af880f0a616015d21f84fe942637b98ce">ScopedVectoredExceptionRegistration</a></td></tr>
<tr class="separator:af880f0a616015d21f84fe942637b98ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b03ee3dc50e580c62f657e6f6d0061" id="r_a44b03ee3dc50e580c62f657e6f6d0061"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44b03ee3dc50e580c62f657e6f6d0061">ScopedLocalAlloc</a></td></tr>
<tr class="separator:a44b03ee3dc50e580c62f657e6f6d0061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c3328971c7ec0e4924bdafdfabc92c" id="r_a37c3328971c7ec0e4924bdafdfabc92c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37c3328971c7ec0e4924bdafdfabc92c">ScopedRegistryKey</a></td></tr>
<tr class="separator:a37c3328971c7ec0e4924bdafdfabc92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8acaf90af42afce7536ea74c1cf32258" id="r_a8acaf90af42afce7536ea74c1cf32258"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8acaf90af42afce7536ea74c1cf32258">UploadBehavior</a> </td></tr>
<tr class="memdesc:a8acaf90af42afce7536ea74c1cf32258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to control upload behavior when processing pending reports.  <a href="#a8acaf90af42afce7536ea74c1cf32258">More...</a><br /></td></tr>
<tr class="separator:a8acaf90af42afce7536ea74c1cf32258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835e6bd6cb3f97c99c572596878c1573" id="r_a835e6bd6cb3f97c99c572596878c1573"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a835e6bd6cb3f97c99c572596878c1573">MinidumpContextFlags</a> : uint32_t </td></tr>
<tr class="memdesc:a835e6bd6cb3f97c99c572596878c1573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture-independent flags for <code>context_flags</code> fields in Minidump context structures.  <a href="#a835e6bd6cb3f97c99c572596878c1573">More...</a><br /></td></tr>
<tr class="separator:a835e6bd6cb3f97c99c572596878c1573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a503f0a39ec98188b60178edbc1fc55" id="r_a2a503f0a39ec98188b60178edbc1fc55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a503f0a39ec98188b60178edbc1fc55">MinidumpContextX86Flags</a> : uint32_t </td></tr>
<tr class="memdesc:a2a503f0a39ec98188b60178edbc1fc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit x86-specifc flags for MinidumpContextX86::context_flags.  <a href="#a2a503f0a39ec98188b60178edbc1fc55">More...</a><br /></td></tr>
<tr class="separator:a2a503f0a39ec98188b60178edbc1fc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa197c419950bae99f1ba663f10b1891c" id="r_aa197c419950bae99f1ba663f10b1891c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa197c419950bae99f1ba663f10b1891c">MinidumpContextAMD64Flags</a> : uint32_t </td></tr>
<tr class="memdesc:aa197c419950bae99f1ba663f10b1891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">x86_64-specific flags for MinidumpContextAMD64::context_flags.  <a href="#aa197c419950bae99f1ba663f10b1891c">More...</a><br /></td></tr>
<tr class="separator:aa197c419950bae99f1ba663f10b1891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7077f40e8cf5fae1f668085248efe77" id="r_ab7077f40e8cf5fae1f668085248efe77"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7077f40e8cf5fae1f668085248efe77">MinidumpContextARMFlags</a> : uint32_t </td></tr>
<tr class="memdesc:ab7077f40e8cf5fae1f668085248efe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit ARM-specifc flags for MinidumpContextARM::context_flags.  <a href="#ab7077f40e8cf5fae1f668085248efe77">More...</a><br /></td></tr>
<tr class="separator:ab7077f40e8cf5fae1f668085248efe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52002589247bce8e16fc48857f31ec8a" id="r_a52002589247bce8e16fc48857f31ec8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52002589247bce8e16fc48857f31ec8a">MinidumpContextARM64Flags</a> : uint32_t </td></tr>
<tr class="memdesc:a52002589247bce8e16fc48857f31ec8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit ARM-specifc flags for MinidumpContextARM64::context_flags.  <a href="#a52002589247bce8e16fc48857f31ec8a">More...</a><br /></td></tr>
<tr class="separator:a52002589247bce8e16fc48857f31ec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add06cd316d6db039af0fd3607be18dec" id="r_add06cd316d6db039af0fd3607be18dec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add06cd316d6db039af0fd3607be18dec">MinidumpContextMIPSFlags</a> : uint32_t </td></tr>
<tr class="memdesc:add06cd316d6db039af0fd3607be18dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">32bit MIPS-specifc flags for MinidumpContextMIPS::context_flags. Based on minidump_cpu_mips.h from breakpad  <a href="#add06cd316d6db039af0fd3607be18dec">More...</a><br /></td></tr>
<tr class="separator:add06cd316d6db039af0fd3607be18dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34392d7c57fce1cdcc10bb1f026a79e6" id="r_a34392d7c57fce1cdcc10bb1f026a79e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34392d7c57fce1cdcc10bb1f026a79e6">MinidumpContextMIPS64Flags</a> : uint32_t </td></tr>
<tr class="memdesc:a34392d7c57fce1cdcc10bb1f026a79e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">64bit MIPS-specifc flags for MinidumpContextMIPS64::context_flags. Based on minidump_cpu_mips.h from breakpad  <a href="#a34392d7c57fce1cdcc10bb1f026a79e6">More...</a><br /></td></tr>
<tr class="separator:a34392d7c57fce1cdcc10bb1f026a79e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b038cf2475f6e27660050f8907a309e" id="r_a2b038cf2475f6e27660050f8907a309e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b038cf2475f6e27660050f8907a309e">MinidumpContextRISCV64Flags</a> : uint32_t </td></tr>
<tr class="memdesc:a2b038cf2475f6e27660050f8907a309e"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit RISCV-specific flags for MinidumpContextRISCV64::context_flags.  <a href="#a2b038cf2475f6e27660050f8907a309e">More...</a><br /></td></tr>
<tr class="separator:a2b038cf2475f6e27660050f8907a309e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88363a45a4af1a16f542a8c1ff522ab9" id="r_a88363a45a4af1a16f542a8c1ff522ab9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88363a45a4af1a16f542a8c1ff522ab9">MinidumpStreamType</a> : uint32_t </td></tr>
<tr class="memdesc:a88363a45a4af1a16f542a8c1ff522ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minidump stream type values for <a class="el" href="structMINIDUMP__DIRECTORY.html#a425b8b68da6810a126c759c5f5a94f7d" title="The type of stream referenced, a value of MINIDUMP_STREAM_TYPE.">MINIDUMP_DIRECTORY::StreamType</a>. Each stream structure has a corresponding stream type value to identify it.  <a href="#a88363a45a4af1a16f542a8c1ff522ab9">More...</a><br /></td></tr>
<tr class="separator:a88363a45a4af1a16f542a8c1ff522ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e532bb06fc5ffdd93e0ceb6d789eb1" id="r_a98e532bb06fc5ffdd93e0ceb6d789eb1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98e532bb06fc5ffdd93e0ceb6d789eb1">MinidumpCPUArchitecture</a> : uint16_t </td></tr>
<tr class="memdesc:a98e532bb06fc5ffdd93e0ceb6d789eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU type values for <a class="el" href="structMINIDUMP__SYSTEM__INFO.html#adc85b29d7df8943baf1a96af23051ca8" title="The system’s CPU architecture. This may be a PROCESSOR_ARCHITECTURE_* value, or a member of crashpad:...">MINIDUMP_SYSTEM_INFO::ProcessorArchitecture</a>.  <a href="#a98e532bb06fc5ffdd93e0ceb6d789eb1">More...</a><br /></td></tr>
<tr class="separator:a98e532bb06fc5ffdd93e0ceb6d789eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf5a6562c9ccee9b4ef3ae4d9ac0be7" id="r_a3bf5a6562c9ccee9b4ef3ae4d9ac0be7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bf5a6562c9ccee9b4ef3ae4d9ac0be7">MinidumpOSType</a> : uint8_t </td></tr>
<tr class="memdesc:a3bf5a6562c9ccee9b4ef3ae4d9ac0be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operating system type values for <a class="el" href="structMINIDUMP__SYSTEM__INFO.html#a9aac8ed4707ea43563fed1776454bad5" title="The system’s operating system type, which distinguishes between “desktop” or “workstation” systems an...">MINIDUMP_SYSTEM_INFO::ProductType</a>.  <a href="#a3bf5a6562c9ccee9b4ef3ae4d9ac0be7">More...</a><br /></td></tr>
<tr class="separator:a3bf5a6562c9ccee9b4ef3ae4d9ac0be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be77c6f7868f00c2f279006a1abe26a" id="r_a9be77c6f7868f00c2f279006a1abe26a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9be77c6f7868f00c2f279006a1abe26a">MinidumpOS</a> : uint32_t </td></tr>
<tr class="memdesc:a9be77c6f7868f00c2f279006a1abe26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operating system family values for <a class="el" href="structMINIDUMP__SYSTEM__INFO.html#a214e7bd61a89343a80a3c9a265fbbe96" title="The system’s operating system family. This may be a VER_PLATFORM_* value, or a member of crashpad::Mi...">MINIDUMP_SYSTEM_INFO::PlatformId</a>.  <a href="#a9be77c6f7868f00c2f279006a1abe26a">More...</a><br /></td></tr>
<tr class="separator:a9be77c6f7868f00c2f279006a1abe26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270e290ba558e948eb6690bd217cbb71" id="r_a270e290ba558e948eb6690bd217cbb71"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a270e290ba558e948eb6690bd217cbb71">CPUArchitecture</a> </td></tr>
<tr class="memdesc:a270e290ba558e948eb6690bd217cbb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">A system’s CPU architecture.  <a href="#a270e290ba558e948eb6690bd217cbb71">More...</a><br /></td></tr>
<tr class="separator:a270e290ba558e948eb6690bd217cbb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96bb7edb42a2e1ce28eda205a18a17a" id="r_ab96bb7edb42a2e1ce28eda205a18a17a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab96bb7edb42a2e1ce28eda205a18a17a">ProcessSuspensionState</a> : bool </td></tr>
<tr class="memdesc:ab96bb7edb42a2e1ce28eda205a18a17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of process being read by ProcessReaderWin.  <a href="#ab96bb7edb42a2e1ce28eda205a18a17a">More...</a><br /></td></tr>
<tr class="separator:ab96bb7edb42a2e1ce28eda205a18a17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa69b0967d9a6df659ff5d2a02ff3e51" id="r_afa69b0967d9a6df659ff5d2a02ff3e51"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">FileWriteMode</a> </td></tr>
<tr class="memdesc:afa69b0967d9a6df659ff5d2a02ff3e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the mode that LoggingOpenFileForWrite() uses.  <a href="#afa69b0967d9a6df659ff5d2a02ff3e51">More...</a><br /></td></tr>
<tr class="separator:afa69b0967d9a6df659ff5d2a02ff3e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034ccc90eb0d1f587ee89275d822175d" id="r_a034ccc90eb0d1f587ee89275d822175d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a> : bool </td></tr>
<tr class="memdesc:a034ccc90eb0d1f587ee89275d822175d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the permissions bits for files created on POSIX systems.  <a href="#a034ccc90eb0d1f587ee89275d822175d">More...</a><br /></td></tr>
<tr class="separator:a034ccc90eb0d1f587ee89275d822175d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3753a95b02e5c96c6e20017e467cef07" id="r_a3753a95b02e5c96c6e20017e467cef07"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3753a95b02e5c96c6e20017e467cef07">FileLocking</a> : bool </td></tr>
<tr class="memdesc:a3753a95b02e5c96c6e20017e467cef07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the locking mode that LoggingLockFile() uses.  <a href="#a3753a95b02e5c96c6e20017e467cef07">More...</a><br /></td></tr>
<tr class="separator:a3753a95b02e5c96c6e20017e467cef07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e435b88af637eb873950400d28bc9d4" id="r_a5e435b88af637eb873950400d28bc9d4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e435b88af637eb873950400d28bc9d4">FileLockingBlocking</a> : bool </td></tr>
<tr class="memdesc:a5e435b88af637eb873950400d28bc9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if LoggingLockFile will block.  <a href="#a5e435b88af637eb873950400d28bc9d4">More...</a><br /></td></tr>
<tr class="separator:a5e435b88af637eb873950400d28bc9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dad59abd6bde82bf08419de636d580" id="r_a50dad59abd6bde82bf08419de636d580"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50dad59abd6bde82bf08419de636d580">FileLockingResult</a> : int </td></tr>
<tr class="memdesc:a50dad59abd6bde82bf08419de636d580"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return value for LoggingLockFile.  <a href="#a50dad59abd6bde82bf08419de636d580">More...</a><br /></td></tr>
<tr class="separator:a50dad59abd6bde82bf08419de636d580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8402ddae562db04a8daf6bffecaded5b" id="r_a8402ddae562db04a8daf6bffecaded5b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8402ddae562db04a8daf6bffecaded5b">StdioStream</a> </td></tr>
<tr class="memdesc:a8402ddae562db04a8daf6bffecaded5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the FileHandle that StdioFileHandle() returns.  <a href="#a8402ddae562db04a8daf6bffecaded5b">More...</a><br /></td></tr>
<tr class="separator:a8402ddae562db04a8daf6bffecaded5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589b4d9bd6f2233b67148ab6793c3c13" id="r_a589b4d9bd6f2233b67148ab6793c3c13"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a> </td></tr>
<tr class="memdesc:a589b4d9bd6f2233b67148ab6793c3c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result code for a ReadXattr operation.  <a href="#a589b4d9bd6f2233b67148ab6793c3c13">More...</a><br /></td></tr>
<tr class="separator:a589b4d9bd6f2233b67148ab6793c3c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bdc8a7a2af1fc2459cad703879884d" id="r_af2bdc8a7a2af1fc2459cad703879884d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: mach_msg_timeout_t </td></tr>
<tr class="memdesc:af2bdc8a7a2af1fc2459cad703879884d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special constants used as <code>mach_msg_timeout_t</code> values.  <a href="#af2bdc8a7a2af1fc2459cad703879884d">More...</a><br /></td></tr>
<tr class="separator:af2bdc8a7a2af1fc2459cad703879884d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaf1be45de9c694fb5e4169b963a64d" id="r_a1aaf1be45de9c694fb5e4169b963a64d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: MachMessageDeadline </td></tr>
<tr class="memdesc:a1aaf1be45de9c694fb5e4169b963a64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special constants used as <a class="el" href="#abd63ad5a7c13f493e8d1e37ef7801bce">MachMessageDeadline</a> values.  <a href="#a1aaf1be45de9c694fb5e4169b963a64d">More...</a><br /></td></tr>
<tr class="separator:a1aaf1be45de9c694fb5e4169b963a64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7856b82b71167792ea6103debb5105ed" id="r_a7856b82b71167792ea6103debb5105ed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7856b82b71167792ea6103debb5105ed">SymbolicConstantToStringOptionBits</a> </td></tr>
<tr class="memdesc:a7856b82b71167792ea6103debb5105ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for various <code>*ToString</code> functions in <code>symbolic_constants_*</code> files.  <a href="#a7856b82b71167792ea6103debb5105ed">More...</a><br /></td></tr>
<tr class="separator:a7856b82b71167792ea6103debb5105ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8387ad067a7e6a1735ab97a1af450d2b" id="r_a8387ad067a7e6a1735ab97a1af450d2b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8387ad067a7e6a1735ab97a1af450d2b">StringToSymbolicConstantOptionBits</a> </td></tr>
<tr class="memdesc:a8387ad067a7e6a1735ab97a1af450d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for various <code>StringTo*</code> functions in <code>symbolic_constants_*</code> files.  <a href="#a8387ad067a7e6a1735ab97a1af450d2b">More...</a><br /></td></tr>
<tr class="separator:a8387ad067a7e6a1735ab97a1af450d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b405c19a5787fabcfba96001d49f292" id="r_a3b405c19a5787fabcfba96001d49f292"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b405c19a5787fabcfba96001d49f292">TriState</a> : uint8_t </td></tr>
<tr class="memdesc:a3b405c19a5787fabcfba96001d49f292"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tri-state value that can be unset, on, or off.  <a href="#a3b405c19a5787fabcfba96001d49f292">More...</a><br /></td></tr>
<tr class="separator:a3b405c19a5787fabcfba96001d49f292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f81158149497e656e97ce1b1565185" id="r_a62f81158149497e656e97ce1b1565185"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62f81158149497e656e97ce1b1565185">ExceptionCodes</a> : uint32_t </td></tr>
<tr class="memdesc:a62f81158149497e656e97ce1b1565185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crashpad-specific exception codes that are used as arguments to <code>RaiseException()</code> in unusual circumstances.  <a href="#a62f81158149497e656e97ce1b1565185">More...</a><br /></td></tr>
<tr class="separator:a62f81158149497e656e97ce1b1565185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed837c91f40cc54ab984d6d5d93f95fc" id="r_aed837c91f40cc54ab984d6d5d93f95fc"><td class="memItemLeft" align="right" valign="top"><a id="aed837c91f40cc54ab984d6d5d93f95fc" name="aed837c91f40cc54ab984d6d5d93f95fc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:aed837c91f40cc54ab984d6d5d93f95fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c3b380111db0abbcf5e2fa8791c8ca" id="r_aa4c3b380111db0abbcf5e2fa8791c8ca"><td class="memItemLeft" align="right" valign="top"><a id="aa4c3b380111db0abbcf5e2fa8791c8ca" name="aa4c3b380111db0abbcf5e2fa8791c8ca"></a>enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:aa4c3b380111db0abbcf5e2fa8791c8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf909fcc58999f95ab1a2d485a3b884f" id="r_acf909fcc58999f95ab1a2d485a3b884f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf909fcc58999f95ab1a2d485a3b884f">TerminationCodes</a> : unsigned int </td></tr>
<tr class="memdesc:acf909fcc58999f95ab1a2d485a3b884f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crashpad-specific codes that are used as arguments to SafeTerminateProcess() or <code>TerminateProcess()</code> in unusual circumstances.  <a href="#acf909fcc58999f95ab1a2d485a3b884f">More...</a><br /></td></tr>
<tr class="separator:acf909fcc58999f95ab1a2d485a3b884f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7dde662bc884d716c35ee765db725e" id="r_add7dde662bc884d716c35ee765db725e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:add7dde662bc884d716c35ee765db725e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a29f064fabb5cda55a8903bb99b72944d" id="r_a29f064fabb5cda55a8903bb99b72944d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29f064fabb5cda55a8903bb99b72944d">BuildHandlerArgvStrings</a> (const base::FilePath &amp;handler, const base::FilePath &amp;database, const base::FilePath &amp;metrics_dir, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, const std::vector&lt; std::string &gt; &amp;arguments, const std::vector&lt; base::FilePath &gt; &amp;attachments={})</td></tr>
<tr class="memdesc:a29f064fabb5cda55a8903bb99b72944d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a vector of arguments suitable for invoking a handler process based on arguments passed to StartHandler-type().  <br /></td></tr>
<tr class="separator:a29f064fabb5cda55a8903bb99b72944d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8913260552f8af42d01f9155b6e717a5" id="r_a8913260552f8af42d01f9155b6e717a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8913260552f8af42d01f9155b6e717a5">StringVectorToCStringVector</a> (const std::vector&lt; std::string &gt; &amp;strings, std::vector&lt; const char * &gt; *c_strings)</td></tr>
<tr class="memdesc:a8913260552f8af42d01f9155b6e717a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens a string vector into a const char* vector suitable for use in an exec() call.  <br /></td></tr>
<tr class="separator:a8913260552f8af42d01f9155b6e717a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4636cb044a8a94be000ac980e543042e" id="r_a4636cb044a8a94be000ac980e543042e"><td class="memItemLeft" align="right" valign="top"><a id="a4636cb044a8a94be000ac980e543042e" name="a4636cb044a8a94be000ac980e543042e"></a>
std::unique_ptr&lt; <a class="el" href="classcrashpad_1_1CrashReportDatabase.html">CrashReportDatabase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeInternal</b> (const base::FilePath &amp;path, bool may_create)</td></tr>
<tr class="separator:a4636cb044a8a94be000ac980e543042e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c1c43fa1b04d68f3262b88cd86e2e2" id="r_a20c1c43fa1b04d68f3262b88cd86e2e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20c1c43fa1b04d68f3262b88cd86e2e2">InstallObjcExceptionPreprocessor</a> (<a class="el" href="classcrashpad_1_1ObjcExceptionDelegate.html">ObjcExceptionDelegate</a> *delegate)</td></tr>
<tr class="memdesc:a20c1c43fa1b04d68f3262b88cd86e2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs the Objective-C exception preprocessor.  <br /></td></tr>
<tr class="separator:a20c1c43fa1b04d68f3262b88cd86e2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e92fe8e499b33a1478d98549ffea11" id="r_a73e92fe8e499b33a1478d98549ffea11"><td class="memItemLeft" align="right" valign="top"><a id="a73e92fe8e499b33a1478d98549ffea11" name="a73e92fe8e499b33a1478d98549ffea11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UninstallObjcExceptionPreprocessor</b> ()</td></tr>
<tr class="memdesc:a73e92fe8e499b33a1478d98549ffea11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstalls the Objective-C exception preprocessor. Expected to be used by tests only. <br /></td></tr>
<tr class="separator:a73e92fe8e499b33a1478d98549ffea11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f3bb96408b68f5e49bd39888cd282f" id="r_ad1f3bb96408b68f5e49bd39888cd282f"><td class="memTemplParams" colspan="2"><a id="ad1f3bb96408b68f5e49bd39888cd282f" name="ad1f3bb96408b68f5e49bd39888cd282f"></a>
template&lt;<a class="el" href="#aa7ef9aa2375aa179ab428923628fbc12">RingBufferCapacity</a> Capacity = internal::kDefaultRingBufferDataCapacity&gt; </td></tr>
<tr class="memitem:ad1f3bb96408b68f5e49bd39888cd282f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RingBufferData</b> () -&gt; RingBufferData&lt; Capacity &gt;</td></tr>
<tr class="separator:ad1f3bb96408b68f5e49bd39888cd282f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840d0e732192b0b9d8c40925abea41f3" id="r_a840d0e732192b0b9d8c40925abea41f3"><td class="memTemplParams" colspan="2"><a id="a840d0e732192b0b9d8c40925abea41f3" name="a840d0e732192b0b9d8c40925abea41f3"></a>
template&lt;typename RingBufferDataType&gt; </td></tr>
<tr class="memitem:a840d0e732192b0b9d8c40925abea41f3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LengthDelimitedRingBufferReader</b> (RingBufferDataType &amp;) -&gt; LengthDelimitedRingBufferReader&lt; RingBufferDataType &gt;</td></tr>
<tr class="separator:a840d0e732192b0b9d8c40925abea41f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2e5a1dd7ff607ec76b199257d01baf" id="r_a9c2e5a1dd7ff607ec76b199257d01baf"><td class="memTemplParams" colspan="2"><a id="a9c2e5a1dd7ff607ec76b199257d01baf" name="a9c2e5a1dd7ff607ec76b199257d01baf"></a>
template&lt;typename RingBufferDataType&gt; </td></tr>
<tr class="memitem:a9c2e5a1dd7ff607ec76b199257d01baf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LengthDelimitedRingBufferWriter</b> (RingBufferDataType &amp;) -&gt; LengthDelimitedRingBufferWriter&lt; RingBufferDataType &gt;</td></tr>
<tr class="separator:a9c2e5a1dd7ff607ec76b199257d01baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1767bc31528e1f4cfb4070855e6da96d" id="r_a1767bc31528e1f4cfb4070855e6da96d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1767bc31528e1f4cfb4070855e6da96d">PruneCrashReportDatabase</a> (<a class="el" href="classcrashpad_1_1CrashReportDatabase.html">CrashReportDatabase</a> *database, <a class="el" href="classcrashpad_1_1PruneCondition.html">PruneCondition</a> *condition)</td></tr>
<tr class="memdesc:a1767bc31528e1f4cfb4070855e6da96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes crash reports from <em class="arg">database</em> that match <em class="arg">condition</em>.  <br /></td></tr>
<tr class="separator:a1767bc31528e1f4cfb4070855e6da96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cf34ae22e75eafb32de8938487c3dc" id="r_a23cf34ae22e75eafb32de8938487c3dc"><td class="memItemLeft" align="right" valign="top"><a id="a23cf34ae22e75eafb32de8938487c3dc" name="a23cf34ae22e75eafb32de8938487c3dc"></a>
std::unique_ptr&lt; <a class="el" href="classcrashpad_1_1PruneCondition.html">PruneCondition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDefaultDatabasePruneCondition</b> ()</td></tr>
<tr class="separator:a23cf34ae22e75eafb32de8938487c3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36aba86185f228b08e04a8964b548fd1" id="r_a36aba86185f228b08e04a8964b548fd1"><td class="memTemplParams" colspan="2"><a id="a36aba86185f228b08e04a8964b548fd1" name="a36aba86185f228b08e04a8964b548fd1"></a>
template&lt;<a class="el" href="#ac3ac7f59200f3fee264cf9f7248a8910">RingBufferAnnotationCapacity</a> Capacity = internal::kDefaultRingBufferAnnotationCapacity&gt; </td></tr>
<tr class="memitem:a36aba86185f228b08e04a8964b548fd1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RingBufferAnnotation</b> (<a class="el" href="classcrashpad_1_1Annotation.html#a734ee64cd20afdb78acb8656ed867d34">Annotation::Type</a> type, const char name[]) -&gt; RingBufferAnnotation&lt; Capacity &gt;</td></tr>
<tr class="separator:a36aba86185f228b08e04a8964b548fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a44a5552e00ceaf0917f94433ac104" id="r_a45a44a5552e00ceaf0917f94433ac104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45a44a5552e00ceaf0917f94433ac104">SimulateCrash</a> (const NativeCPUContext &amp;cpu_context)</td></tr>
<tr class="memdesc:a45a44a5552e00ceaf0917f94433ac104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates a exception without crashing.  <br /></td></tr>
<tr class="separator:a45a44a5552e00ceaf0917f94433ac104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6dd0b469072cc3787ff17c8de47a84" id="r_a2c6dd0b469072cc3787ff17c8de47a84"><td class="memItemLeft" align="right" valign="top"><a id="a2c6dd0b469072cc3787ff17c8de47a84" name="a2c6dd0b469072cc3787ff17c8de47a84"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CrashpadHandlerMain</b> (int argc, char *argv[])</td></tr>
<tr class="separator:a2c6dd0b469072cc3787ff17c8de47a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6925b00a82891a9fd7a77ec6f5259094" id="r_a6925b00a82891a9fd7a77ec6f5259094"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6925b00a82891a9fd7a77ec6f5259094">HandlerMain</a> (int argc, char *argv[], const UserStreamDataSources *user_stream_sources)</td></tr>
<tr class="memdesc:a6925b00a82891a9fd7a77ec6f5259094"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>main()</code> of the <code>crashpad_handler</code> binary.  <br /></td></tr>
<tr class="separator:a6925b00a82891a9fd7a77ec6f5259094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8819955d3c396805f044bff1ecf595" id="r_acd8819955d3c396805f044bff1ecf595"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd8819955d3c396805f044bff1ecf595">CaptureSnapshot</a> (<a class="el" href="classcrashpad_1_1PtraceConnection.html">PtraceConnection</a> *connection, const <a class="el" href="structcrashpad_1_1ExceptionHandlerProtocol_1_1ClientInformation.html">ExceptionHandlerProtocol::ClientInformation</a> &amp;info, const std::map&lt; std::string, std::string &gt; &amp;process_annotations, uid_t client_uid, <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a> requesting_thread_stack_address, pid_t *requesting_thread_id, std::unique_ptr&lt; <a class="el" href="classcrashpad_1_1ProcessSnapshotLinux.html">ProcessSnapshotLinux</a> &gt; *process_snapshot, std::unique_ptr&lt; <a class="el" href="classcrashpad_1_1ProcessSnapshotSanitized.html">ProcessSnapshotSanitized</a> &gt; *sanitized_snapshot)</td></tr>
<tr class="memdesc:acd8819955d3c396805f044bff1ecf595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Captures a snapshot of a client over <em class="arg">connection</em>.  <br /></td></tr>
<tr class="separator:acd8819955d3c396805f044bff1ecf595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20301f0c5158576b0893444ff662108" id="r_ad20301f0c5158576b0893444ff662108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad20301f0c5158576b0893444ff662108">RecordFileLimitAnnotation</a> ()</td></tr>
<tr class="memdesc:ad20301f0c5158576b0893444ff662108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a <code>"file-limits"</code> simple annotation for the process.  <br /></td></tr>
<tr class="separator:ad20301f0c5158576b0893444ff662108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63faa5e791871a34f458e2e3995389df" id="r_a63faa5e791871a34f458e2e3995389df"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63faa5e791871a34f458e2e3995389df">BreakpadHTTPFormParametersFromMinidump</a> (const <a class="el" href="classcrashpad_1_1ProcessSnapshot.html">ProcessSnapshot</a> *process_snapshot)</td></tr>
<tr class="memdesc:a63faa5e791871a34f458e2e3995389df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a>, returns a map of key-value pairs to use as HTTP form parameters for upload to a Breakpad crash report colleciton server.  <br /></td></tr>
<tr class="separator:a63faa5e791871a34f458e2e3995389df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0004297cf46f8fd00258e02a4bcf13a" id="r_af0004297cf46f8fd00258e02a4bcf13a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0004297cf46f8fd00258e02a4bcf13a">AddUserExtensionStreams</a> (const UserStreamDataSources *user_stream_data_sources, <a class="el" href="classcrashpad_1_1ProcessSnapshot.html">ProcessSnapshot</a> *process_snapshot, <a class="el" href="classcrashpad_1_1MinidumpFileWriter.html">MinidumpFileWriter</a> *minidump_file_writer)</td></tr>
<tr class="memdesc:af0004297cf46f8fd00258e02a4bcf13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds user extension streams to a minidump.  <br /></td></tr>
<tr class="separator:af0004297cf46f8fd00258e02a4bcf13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad353f2b9619e894d4658b14c16607349" id="r_ad353f2b9619e894d4658b14c16607349"><td class="memItemLeft" align="right" valign="top"><a id="ad353f2b9619e894d4658b14c16607349" name="ad353f2b9619e894d4658b14c16607349"></a>
const char16_t *&#160;</td><td class="memItemRight" valign="bottom"><b>AsU16CStr</b> (const wchar_t *str)</td></tr>
<tr class="memdesc:ad353f2b9619e894d4658b14c16607349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion functions from a native UTF16 C-string to a char16_t C-string. No-op where the native UTF16 string is std::u16string. <br /></td></tr>
<tr class="separator:ad353f2b9619e894d4658b14c16607349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e5f19bce060f8a0041e7bdcc0a639e" id="r_a00e5f19bce060f8a0041e7bdcc0a639e"><td class="memItemLeft" align="right" valign="top"><a id="a00e5f19bce060f8a0041e7bdcc0a639e" name="a00e5f19bce060f8a0041e7bdcc0a639e"></a>
char16_t *&#160;</td><td class="memItemRight" valign="bottom"><b>AsU16CStr</b> (wchar_t *str)</td></tr>
<tr class="separator:a00e5f19bce060f8a0041e7bdcc0a639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58169a74e32daa2888614fcd2f2381ce" id="r_a58169a74e32daa2888614fcd2f2381ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58169a74e32daa2888614fcd2f2381ce">BuildMinidumpThreadIDMap</a> (const std::vector&lt; const <a class="el" href="classcrashpad_1_1ThreadSnapshot.html">ThreadSnapshot</a> * &gt; &amp;thread_snapshots, <a class="el" href="#a6e1c44f1c92c4ae031829f6f1b255268">MinidumpThreadIDMap</a> *thread_id_map)</td></tr>
<tr class="memdesc:a58169a74e32daa2888614fcd2f2381ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <a class="el" href="#a6e1c44f1c92c4ae031829f6f1b255268" title="A map that connects 64-bit snapshot thread IDs to 32-bit minidump thread IDs.">MinidumpThreadIDMap</a> for a group of <a class="el" href="classcrashpad_1_1ThreadSnapshot.html" title="An abstract interface to a snapshot representing a thread (lightweight process) present in a snapshot...">ThreadSnapshot</a> objects.  <br /></td></tr>
<tr class="separator:a58169a74e32daa2888614fcd2f2381ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14ca679827f9eac8b99f6833f314b4c" id="r_ad14ca679827f9eac8b99f6833f314b4c"><td class="memItemLeft" align="right" valign="top"><a id="ad14ca679827f9eac8b99f6833f314b4c" name="ad14ca679827f9eac8b99f6833f314b4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DEFINE_GETTER</b> (<a class="el" href="#a3b405c19a5787fabcfba96001d49f292">TriState</a>, SystemCrashReporterForwarding, system_crash_reporter_forwarding) DEFINE_GETTER(<a class="el" href="#a3b405c19a5787fabcfba96001d49f292">TriState</a></td></tr>
<tr class="separator:ad14ca679827f9eac8b99f6833f314b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15355d6a3c2b9d06f9a15397c8c534eb" id="r_a15355d6a3c2b9d06f9a15397c8c534eb"><td class="memItemLeft" align="right" valign="top"><a id="a15355d6a3c2b9d06f9a15397c8c534eb" name="a15355d6a3c2b9d06f9a15397c8c534eb"></a>
gather_indirectly_referenced_memory&#160;</td><td class="memItemRight" valign="bottom"><b>DEFINE_GETTER</b> (uint32_t, IndirectlyReferencedMemoryCap, indirectly_referenced_memory_cap) DEFINE_GETTER(<a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a></td></tr>
<tr class="separator:a15355d6a3c2b9d06f9a15397c8c534eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2388c530540daf977829b751582d5624" id="r_a2388c530540daf977829b751582d5624"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2388c530540daf977829b751582d5624">IsMalformedCLKernelsModule</a> (uint32_t mach_o_file_type, const std::string &amp;module_name)</td></tr>
<tr class="memdesc:a2388c530540daf977829b751582d5624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a module appears to be a malformed OpenCL <code>cl_kernels</code> module based on its name and Mach-O file type.  <br /></td></tr>
<tr class="separator:a2388c530540daf977829b751582d5624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7b5be59c1293af50753130136aeb32" id="r_acb7b5be59c1293af50753130136aeb32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb7b5be59c1293af50753130136aeb32">LoggingDetermineMergedRange</a> (const <a class="el" href="classcrashpad_1_1MemorySnapshot.html">MemorySnapshot</a> *a, const <a class="el" href="classcrashpad_1_1MemorySnapshot.html">MemorySnapshot</a> *b, <a class="el" href="classcrashpad_1_1CheckedRange.html">CheckedRange</a>&lt; uint64_t, size_t &gt; *merged)</td></tr>
<tr class="memdesc:acb7b5be59c1293af50753130136aeb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two memory snapshots, checks if they're overlapping or abutting, and if so, returns the result of merging the two ranges.  <br /></td></tr>
<tr class="separator:acb7b5be59c1293af50753130136aeb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f17bed131c46938ca08241eebd5b520" id="r_a8f17bed131c46938ca08241eebd5b520"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f17bed131c46938ca08241eebd5b520">DetermineMergedRange</a> (const <a class="el" href="classcrashpad_1_1MemorySnapshot.html">MemorySnapshot</a> *a, const <a class="el" href="classcrashpad_1_1MemorySnapshot.html">MemorySnapshot</a> *b, <a class="el" href="classcrashpad_1_1CheckedRange.html">CheckedRange</a>&lt; uint64_t, size_t &gt; *merged)</td></tr>
<tr class="memdesc:a8f17bed131c46938ca08241eebd5b520"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as LoggingDetermineMergedRange but with no errors logged.  <br /></td></tr>
<tr class="separator:a8f17bed131c46938ca08241eebd5b520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f086bf42672cc9deccc4f93301478a" id="r_aa8f086bf42672cc9deccc4f93301478a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8f086bf42672cc9deccc4f93301478a">ReadAllowedAnnotations</a> (const <a class="el" href="classcrashpad_1_1ProcessMemoryRange.html">ProcessMemoryRange</a> &amp;memory, <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a> list_address, std::vector&lt; std::string &gt; *allowed_annotations)</td></tr>
<tr class="memdesc:aa8f086bf42672cc9deccc4f93301478a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a list of allowed annotations from another process.  <br /></td></tr>
<tr class="separator:aa8f086bf42672cc9deccc4f93301478a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f3d401cee57d9776ad3d338111a95c" id="r_af4f3d401cee57d9776ad3d338111a95c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4f3d401cee57d9776ad3d338111a95c">ReadAllowedMemoryRanges</a> (const <a class="el" href="classcrashpad_1_1ProcessMemoryRange.html">ProcessMemoryRange</a> &amp;memory, <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a> list_address, std::vector&lt; std::pair&lt; <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a>, <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a> &gt; &gt; *allowed_memory_ranges)</td></tr>
<tr class="memdesc:af4f3d401cee57d9776ad3d338111a95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a list of allowed memory ranges from another process.  <br /></td></tr>
<tr class="separator:af4f3d401cee57d9776ad3d338111a95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dde20e7d402286dc3f826cd64b5be78" id="r_a5dde20e7d402286dc3f826cd64b5be78"><td class="memItemLeft" align="right" valign="top"><a id="a5dde20e7d402286dc3f826cd64b5be78" name="a5dde20e7d402286dc3f826cd64b5be78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeX86Context</b> (const CONTEXT *context, <a class="el" href="structcrashpad_1_1CPUContextX86.html">CPUContextX86</a> *out)</td></tr>
<tr class="memdesc:a5dde20e7d402286dc3f826cd64b5be78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <a class="el" href="structcrashpad_1_1CPUContextX86.html" title="A context structure carrying 32-bit x86 CPU state.">CPUContextX86</a> structure from a native context structure on Windows. <br /></td></tr>
<tr class="separator:a5dde20e7d402286dc3f826cd64b5be78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41a65dd58f5c5e43ac4a5d5b1c7b7bd" id="r_ae41a65dd58f5c5e43ac4a5d5b1c7b7bd"><td class="memItemLeft" align="right" valign="top"><a id="ae41a65dd58f5c5e43ac4a5d5b1c7b7bd" name="ae41a65dd58f5c5e43ac4a5d5b1c7b7bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeX86Context</b> (const WOW64_CONTEXT *context, <a class="el" href="structcrashpad_1_1CPUContextX86.html">CPUContextX86</a> *out)</td></tr>
<tr class="memdesc:ae41a65dd58f5c5e43ac4a5d5b1c7b7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <a class="el" href="structcrashpad_1_1CPUContextX86.html" title="A context structure carrying 32-bit x86 CPU state.">CPUContextX86</a> structure from a native context structure on Windows. <br /></td></tr>
<tr class="separator:ae41a65dd58f5c5e43ac4a5d5b1c7b7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd6daca72baa04c7a65d8ef973fea9c" id="r_a5fd6daca72baa04c7a65d8ef973fea9c"><td class="memItemLeft" align="right" valign="top"><a id="a5fd6daca72baa04c7a65d8ef973fea9c" name="a5fd6daca72baa04c7a65d8ef973fea9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeX64Context</b> (const CONTEXT *context, <a class="el" href="structcrashpad_1_1CPUContextX86__64.html">CPUContextX86_64</a> *out)</td></tr>
<tr class="memdesc:a5fd6daca72baa04c7a65d8ef973fea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <a class="el" href="structcrashpad_1_1CPUContextX86__64.html" title="A context structure carrying x86_64 CPU state.">CPUContextX86_64</a> structure from a native context structure on Windows. Only reads a max of sizeof(CONTEXT) so will not initialize extended values. <br /></td></tr>
<tr class="separator:a5fd6daca72baa04c7a65d8ef973fea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f32e0bde4fa49bf36499009253a442" id="r_ae1f32e0bde4fa49bf36499009253a442"><td class="memItemLeft" align="right" valign="top"><a id="ae1f32e0bde4fa49bf36499009253a442" name="ae1f32e0bde4fa49bf36499009253a442"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeX64XStateCet</b> (const CONTEXT *context, XSAVE_CET_U_FORMAT *cet_u, <a class="el" href="structcrashpad_1_1CPUContextX86__64.html">CPUContextX86_64</a> *out)</td></tr>
<tr class="memdesc:ae1f32e0bde4fa49bf36499009253a442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes CET fields of a <a class="el" href="structcrashpad_1_1CPUContextX86__64.html" title="A context structure carrying x86_64 CPU state.">CPUContextX86_64</a> structure from an xsave location if |context| flags support cet_u values. <br /></td></tr>
<tr class="separator:ae1f32e0bde4fa49bf36499009253a442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce89fb78eafdcb6aec40b331276c059" id="r_a3ce89fb78eafdcb6aec40b331276c059"><td class="memItemLeft" align="right" valign="top"><a id="a3ce89fb78eafdcb6aec40b331276c059" name="a3ce89fb78eafdcb6aec40b331276c059"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsXStateFeatureEnabled</b> (DWORD64 feature)</td></tr>
<tr class="memdesc:a3ce89fb78eafdcb6aec40b331276c059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps GetXStateEnabledFeatures(), returns true if the specified set of flags are all supported. <br /></td></tr>
<tr class="separator:a3ce89fb78eafdcb6aec40b331276c059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2663ff1f24229be7da93598f6b9aa6bd" id="r_a2663ff1f24229be7da93598f6b9aa6bd"><td class="memItemLeft" align="right" valign="top"><a id="a2663ff1f24229be7da93598f6b9aa6bd" name="a2663ff1f24229be7da93598f6b9aa6bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeARM64Context</b> (const CONTEXT *context, <a class="el" href="structcrashpad_1_1CPUContextARM64.html">CPUContextARM64</a> *out)</td></tr>
<tr class="memdesc:a2663ff1f24229be7da93598f6b9aa6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <a class="el" href="structcrashpad_1_1CPUContextARM64.html" title="A context structure carrying ARM64 CPU state.">CPUContextARM64</a> structure from a native context structure on Windows. <br /></td></tr>
<tr class="separator:a2663ff1f24229be7da93598f6b9aa6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743f7c71d235eb21a742679a639f6aa7" id="r_a743f7c71d235eb21a742679a639f6aa7"><td class="memItemLeft" align="right" valign="top"><a id="a743f7c71d235eb21a742679a639f6aa7" name="a743f7c71d235eb21a742679a639f6aa7"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>PEImageReader::GetCrashpadInfo&lt; process_types::internal::Traits32 &gt;</b> (<a class="el" href="structcrashpad_1_1process__types_1_1CrashpadInfo.html">process_types::CrashpadInfo</a>&lt; <a class="el" href="structcrashpad_1_1process__types_1_1internal_1_1Traits32.html">process_types::internal::Traits32</a> &gt; *crashpad_info) const</td></tr>
<tr class="separator:a743f7c71d235eb21a742679a639f6aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a621015141b7331ca152909781cc29a" id="r_a0a621015141b7331ca152909781cc29a"><td class="memItemLeft" align="right" valign="top"><a id="a0a621015141b7331ca152909781cc29a" name="a0a621015141b7331ca152909781cc29a"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>PEImageReader::GetCrashpadInfo&lt; process_types::internal::Traits64 &gt;</b> (<a class="el" href="structcrashpad_1_1process__types_1_1CrashpadInfo.html">process_types::CrashpadInfo</a>&lt; <a class="el" href="structcrashpad_1_1process__types_1_1internal_1_1Traits64.html">process_types::internal::Traits64</a> &gt; *crashpad_info) const</td></tr>
<tr class="separator:a0a621015141b7331ca152909781cc29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1062220521ffc26daf21a3759dc4a0d8" id="r_a1062220521ffc26daf21a3759dc4a0d8"><td class="memItemLeft" align="right" valign="top"><a id="a1062220521ffc26daf21a3759dc4a0d8" name="a1062220521ffc26daf21a3759dc4a0d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyFileContent</b> (<a class="el" href="classcrashpad_1_1FileReaderInterface.html">FileReaderInterface</a> *file_reader, <a class="el" href="classcrashpad_1_1FileWriterInterface.html">FileWriterInterface</a> *file_writer)</td></tr>
<tr class="memdesc:a1062220521ffc26daf21a3759dc4a0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the file content from file_reader to file_writer. <br /></td></tr>
<tr class="separator:a1062220521ffc26daf21a3759dc4a0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e685af255d9b71fb46ed2679329dd7c" id="r_a6e685af255d9b71fb46ed2679329dd7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e685af255d9b71fb46ed2679329dd7c">ReadFileExactly</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a6e685af255d9b71fb46ed2679329dd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, retrying following a short read, ensuring that exactly <em class="arg">size</em> bytes are read. Does not log on failure.  <br /></td></tr>
<tr class="separator:a6e685af255d9b71fb46ed2679329dd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37c2677a36c7cf97be67103a3a5b5a6" id="r_ab37c2677a36c7cf97be67103a3a5b5a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9cbae3880f57681cd84026b2c5a042ca">FileOperationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab37c2677a36c7cf97be67103a3a5b5a6">ReadFileUntil</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, void *buffer, size_t size)</td></tr>
<tr class="memdesc:ab37c2677a36c7cf97be67103a3a5b5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, retrying following a short read. Does not log on failure.  <br /></td></tr>
<tr class="separator:ab37c2677a36c7cf97be67103a3a5b5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb8955565f605e08c1e30562fbdb7a" id="r_ac3fb8955565f605e08c1e30562fbdb7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3fb8955565f605e08c1e30562fbdb7a">LoggingReadFileExactly</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, void *buffer, size_t size)</td></tr>
<tr class="memdesc:ac3fb8955565f605e08c1e30562fbdb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, retrying following a short read, ensuring that exactly <em class="arg">size</em> bytes are read. Logs an error on failure.  <br /></td></tr>
<tr class="separator:ac3fb8955565f605e08c1e30562fbdb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13522930fa21f678aefd0bcd1ba2ce92" id="r_a13522930fa21f678aefd0bcd1ba2ce92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9cbae3880f57681cd84026b2c5a042ca">FileOperationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13522930fa21f678aefd0bcd1ba2ce92">LoggingReadFileUntil</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a13522930fa21f678aefd0bcd1ba2ce92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, retrying following a short read. Logs an error on failure.  <br /></td></tr>
<tr class="separator:a13522930fa21f678aefd0bcd1ba2ce92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada530c306bf30e9ed9274c20d05c0db4" id="r_ada530c306bf30e9ed9274c20d05c0db4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4">WriteFile</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:ada530c306bf30e9ed9274c20d05c0db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to a file, retrying when interrupted on POSIX or following a short write.  <br /></td></tr>
<tr class="separator:ada530c306bf30e9ed9274c20d05c0db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a91af9c690d2a280c463596bf82070b" id="r_a8a91af9c690d2a280c463596bf82070b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a91af9c690d2a280c463596bf82070b">LoggingWriteFile</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:a8a91af9c690d2a280c463596bf82070b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4" title="Writes to a file, retrying when interrupted on POSIX or following a short write.">WriteFile()</a>, ensuring that exactly <em class="arg">size</em> bytes are written.  <br /></td></tr>
<tr class="separator:a8a91af9c690d2a280c463596bf82070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e03e19185b0fde6301be6b113628cb" id="r_a00e03e19185b0fde6301be6b113628cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00e03e19185b0fde6301be6b113628cb">CheckedReadFileExactly</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a00e03e19185b0fde6301be6b113628cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, ensuring that exactly <em class="arg">size</em> bytes are read.  <br /></td></tr>
<tr class="separator:a00e03e19185b0fde6301be6b113628cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c74fefa3b1f5e0c1b885755c9f9cf6" id="r_a74c74fefa3b1f5e0c1b885755c9f9cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74c74fefa3b1f5e0c1b885755c9f9cf6">CheckedWriteFile</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:a74c74fefa3b1f5e0c1b885755c9f9cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4" title="Writes to a file, retrying when interrupted on POSIX or following a short write.">WriteFile()</a>, ensuring that exactly <em class="arg">size</em> bytes are written.  <br /></td></tr>
<tr class="separator:a74c74fefa3b1f5e0c1b885755c9f9cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e7e1b1a4b89b489964ffee54d0d9df" id="r_ac8e7e1b1a4b89b489964ffee54d0d9df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8e7e1b1a4b89b489964ffee54d0d9df">CheckedReadFileAtEOF</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file)</td></tr>
<tr class="memdesc:ac8e7e1b1a4b89b489964ffee54d0d9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, ensuring that it indicates end-of-file.  <br /></td></tr>
<tr class="separator:ac8e7e1b1a4b89b489964ffee54d0d9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52dab87e27350dd4c70ea4c8ac258cc" id="r_ae52dab87e27350dd4c70ea4c8ac258cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae52dab87e27350dd4c70ea4c8ac258cc">LoggingReadToEOF</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, std::string *contents)</td></tr>
<tr class="memdesc:ae52dab87e27350dd4c70ea4c8ac258cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> to read from the current file position to the end of the file into <em class="arg">contents</em>.  <br /></td></tr>
<tr class="separator:ae52dab87e27350dd4c70ea4c8ac258cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300ac399f9d33a4c47b4e4c148ebbe7c" id="r_a300ac399f9d33a4c47b4e4c148ebbe7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a300ac399f9d33a4c47b4e4c148ebbe7c">LoggingReadEntireFile</a> (const base::FilePath &amp;path, std::string *contents)</td></tr>
<tr class="memdesc:a300ac399f9d33a4c47b4e4c148ebbe7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#ab3712d59104f641109b170c78a912b4d" title="Wraps OpenFileForRead(), logging an error if the operation fails.">LoggingOpenFileForRead()</a> and <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> reading the entire file into <em class="arg">contents</em>.  <br /></td></tr>
<tr class="separator:a300ac399f9d33a4c47b4e4c148ebbe7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cb2e4837a6fda169cbe92d1603460f" id="r_ac7cb2e4837a6fda169cbe92d1603460f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7cb2e4837a6fda169cbe92d1603460f">CheckedCloseFile</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file)</td></tr>
<tr class="memdesc:ac7cb2e4837a6fda169cbe92d1603460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <code>close()</code> or <code>CloseHandle()</code>, ensuring that it succeeds.  <br /></td></tr>
<tr class="separator:ac7cb2e4837a6fda169cbe92d1603460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8599600814a17d622766decd5f122a96" id="r_a8599600814a17d622766decd5f122a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9cbae3880f57681cd84026b2c5a042ca">FileOperationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8599600814a17d622766decd5f122a96">ReadFile</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a8599600814a17d622766decd5f122a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads from a file, retrying when interrupted before reading any data on POSIX.  <br /></td></tr>
<tr class="separator:a8599600814a17d622766decd5f122a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7987df05e1260e6d8d93ee3a21e9b0eb" id="r_a7987df05e1260e6d8d93ee3a21e9b0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7987df05e1260e6d8d93ee3a21e9b0eb">OpenFileForRead</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:a7987df05e1260e6d8d93ee3a21e9b0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <code>open()</code> or <code>CreateFile()</code>, opening an existing file for reading.  <br /></td></tr>
<tr class="separator:a7987df05e1260e6d8d93ee3a21e9b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e8848af82384f7757108c8c445f18d" id="r_ad8e8848af82384f7757108c8c445f18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8e8848af82384f7757108c8c445f18d">OpenFileForWrite</a> (const base::FilePath &amp;path, <a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">FileWriteMode</a> mode, <a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a> permissions)</td></tr>
<tr class="memdesc:ad8e8848af82384f7757108c8c445f18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <code>open()</code> or <code>CreateFile()</code>, creating a file for output.  <br /></td></tr>
<tr class="separator:ad8e8848af82384f7757108c8c445f18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6238b18be49921772c14dd25a624de" id="r_abe6238b18be49921772c14dd25a624de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe6238b18be49921772c14dd25a624de">OpenFileForReadAndWrite</a> (const base::FilePath &amp;path, <a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">FileWriteMode</a> mode, <a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a> permissions)</td></tr>
<tr class="memdesc:abe6238b18be49921772c14dd25a624de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <code>open()</code> or <code>CreateFile()</code>, creating a file for both input and output.  <br /></td></tr>
<tr class="separator:abe6238b18be49921772c14dd25a624de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3712d59104f641109b170c78a912b4d" id="r_ab3712d59104f641109b170c78a912b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3712d59104f641109b170c78a912b4d">LoggingOpenFileForRead</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:ab3712d59104f641109b170c78a912b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#a7987df05e1260e6d8d93ee3a21e9b0eb" title="Wraps open() or CreateFile(), opening an existing file for reading.">OpenFileForRead()</a>, logging an error if the operation fails.  <br /></td></tr>
<tr class="separator:ab3712d59104f641109b170c78a912b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fc6876cc0c660f0ea8bd1dd0a07e82" id="r_a62fc6876cc0c660f0ea8bd1dd0a07e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62fc6876cc0c660f0ea8bd1dd0a07e82">LoggingOpenFileForWrite</a> (const base::FilePath &amp;path, <a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">FileWriteMode</a> mode, <a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a> permissions)</td></tr>
<tr class="memdesc:a62fc6876cc0c660f0ea8bd1dd0a07e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#ad8e8848af82384f7757108c8c445f18d" title="Wraps open() or CreateFile(), creating a file for output.">OpenFileForWrite()</a>, logging an error if the operation fails.  <br /></td></tr>
<tr class="separator:a62fc6876cc0c660f0ea8bd1dd0a07e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3e964bdba04aaf74e7a27a36efe108" id="r_aab3e964bdba04aaf74e7a27a36efe108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab3e964bdba04aaf74e7a27a36efe108">LoggingOpenFileForReadAndWrite</a> (const base::FilePath &amp;path, <a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">FileWriteMode</a> mode, <a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a> permissions)</td></tr>
<tr class="memdesc:aab3e964bdba04aaf74e7a27a36efe108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="#abe6238b18be49921772c14dd25a624de" title="Wraps open() or CreateFile(), creating a file for both input and output.">OpenFileForReadAndWrite()</a>, logging an error if the operation fails.  <br /></td></tr>
<tr class="separator:aab3e964bdba04aaf74e7a27a36efe108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6cedc10e24145d4a0c1000c33f8a10" id="r_a3d6cedc10e24145d4a0c1000c33f8a10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a73e870ea9156f1bfdff1b998a77cdd9e">FileOffset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d6cedc10e24145d4a0c1000c33f8a10">LoggingSeekFile</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, <a class="el" href="#a73e870ea9156f1bfdff1b998a77cdd9e">FileOffset</a> offset, int whence)</td></tr>
<tr class="memdesc:a3d6cedc10e24145d4a0c1000c33f8a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <code>lseek()</code> or <code>SetFilePointerEx()</code>. Logs an error if the operation fails.  <br /></td></tr>
<tr class="separator:a3d6cedc10e24145d4a0c1000c33f8a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ba30c1a4b2974f1d4ea842db55b068" id="r_a06ba30c1a4b2974f1d4ea842db55b068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ba30c1a4b2974f1d4ea842db55b068">LoggingTruncateFile</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file)</td></tr>
<tr class="memdesc:a06ba30c1a4b2974f1d4ea842db55b068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the given <em class="arg">file</em> to zero bytes in length.  <br /></td></tr>
<tr class="separator:a06ba30c1a4b2974f1d4ea842db55b068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9db00544fd57cfde0bb03d32b989221" id="r_ab9db00544fd57cfde0bb03d32b989221"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9db00544fd57cfde0bb03d32b989221">LoggingCloseFile</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file)</td></tr>
<tr class="memdesc:ab9db00544fd57cfde0bb03d32b989221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <code>close()</code> or <code>CloseHandle()</code>, logging an error if the operation fails.  <br /></td></tr>
<tr class="separator:ab9db00544fd57cfde0bb03d32b989221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0224d5a689cdb8c2315c255fd6ea6b5c" id="r_a0224d5a689cdb8c2315c255fd6ea6b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a73e870ea9156f1bfdff1b998a77cdd9e">FileOffset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0224d5a689cdb8c2315c255fd6ea6b5c">LoggingFileSizeByHandle</a> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file)</td></tr>
<tr class="memdesc:a0224d5a689cdb8c2315c255fd6ea6b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the size of a file.  <br /></td></tr>
<tr class="separator:a0224d5a689cdb8c2315c255fd6ea6b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eccc3b9b90d2dd74048a43c9002e88" id="r_ac6eccc3b9b90d2dd74048a43c9002e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6eccc3b9b90d2dd74048a43c9002e88">StdioFileHandle</a> (<a class="el" href="#a8402ddae562db04a8daf6bffecaded5b">StdioStream</a> stdio_stream)</td></tr>
<tr class="memdesc:ac6eccc3b9b90d2dd74048a43c9002e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> corresponding to the requested standard I/O stream.  <br /></td></tr>
<tr class="separator:ac6eccc3b9b90d2dd74048a43c9002e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4566e916a573abe91dbd3f3c25123f" id="r_a9a4566e916a573abe91dbd3f3c25123f"><td class="memItemLeft" align="right" valign="top"><a id="a9a4566e916a573abe91dbd3f3c25123f" name="a9a4566e916a573abe91dbd3f3c25123f"></a>
<a class="el" href="#a50dad59abd6bde82bf08419de636d580">FileLockingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LoggingLockFile</b> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file, <a class="el" href="#a3753a95b02e5c96c6e20017e467cef07">FileLocking</a> locking, <a class="el" href="#a5e435b88af637eb873950400d28bc9d4">FileLockingBlocking</a> blocking)</td></tr>
<tr class="separator:a9a4566e916a573abe91dbd3f3c25123f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c1f3a2c6f04e944fdca12e22b0cb6e" id="r_a15c1f3a2c6f04e944fdca12e22b0cb6e"><td class="memItemLeft" align="right" valign="top"><a id="a15c1f3a2c6f04e944fdca12e22b0cb6e" name="a15c1f3a2c6f04e944fdca12e22b0cb6e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>LoggingUnlockFile</b> (<a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> file)</td></tr>
<tr class="separator:a15c1f3a2c6f04e944fdca12e22b0cb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229b9a82773f5497a0f0c74aae3b8b3a" id="r_a229b9a82773f5497a0f0c74aae3b8b3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a229b9a82773f5497a0f0c74aae3b8b3a">FileModificationTime</a> (const base::FilePath &amp;path, timespec *mtime)</td></tr>
<tr class="memdesc:a229b9a82773f5497a0f0c74aae3b8b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the modification time for a file, directory, or symbolic link, logging a message on failure.  <br /></td></tr>
<tr class="separator:a229b9a82773f5497a0f0c74aae3b8b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae84cd353b237bfdf698d40da521568" id="r_a7ae84cd353b237bfdf698d40da521568"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ae84cd353b237bfdf698d40da521568">LoggingCreateDirectory</a> (const base::FilePath &amp;path, <a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a> permissions, bool may_reuse)</td></tr>
<tr class="memdesc:a7ae84cd353b237bfdf698d40da521568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory, logging a message on failure.  <br /></td></tr>
<tr class="separator:a7ae84cd353b237bfdf698d40da521568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5ef254327bfa348cc23cd21893b29e" id="r_a7e5ef254327bfa348cc23cd21893b29e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e5ef254327bfa348cc23cd21893b29e">MoveFileOrDirectory</a> (const base::FilePath &amp;source, const base::FilePath &amp;dest)</td></tr>
<tr class="memdesc:a7e5ef254327bfa348cc23cd21893b29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a file, symbolic link, or directory, logging a message on failure.  <br /></td></tr>
<tr class="separator:a7e5ef254327bfa348cc23cd21893b29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c69205d3a470099d1489f71cbfe7ba6" id="r_a3c69205d3a470099d1489f71cbfe7ba6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c69205d3a470099d1489f71cbfe7ba6">IsRegularFile</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:a3c69205d3a470099d1489f71cbfe7ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a path refers to a regular file, logging a message on failure.  <br /></td></tr>
<tr class="separator:a3c69205d3a470099d1489f71cbfe7ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12fac7cddd34499234ca6617e3e3aa3" id="r_af12fac7cddd34499234ca6617e3e3aa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af12fac7cddd34499234ca6617e3e3aa3">IsDirectory</a> (const base::FilePath &amp;path, bool allow_symlinks)</td></tr>
<tr class="memdesc:af12fac7cddd34499234ca6617e3e3aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a path refers to a directory, logging a message on failure.  <br /></td></tr>
<tr class="separator:af12fac7cddd34499234ca6617e3e3aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c5ccd8661bd87eed66eae26fb9e0d3" id="r_ac7c5ccd8661bd87eed66eae26fb9e0d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7c5ccd8661bd87eed66eae26fb9e0d3">LoggingRemoveFile</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:ac7c5ccd8661bd87eed66eae26fb9e0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a file or a symbolic link to a file or directory, logging a message on failure.  <br /></td></tr>
<tr class="separator:ac7c5ccd8661bd87eed66eae26fb9e0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc84fcc207cf0b718626997d11ad04" id="r_a7fdc84fcc207cf0b718626997d11ad04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fdc84fcc207cf0b718626997d11ad04">LoggingRemoveDirectory</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:a7fdc84fcc207cf0b718626997d11ad04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-recurseively removes an empty directory, logging a message on failure.  <br /></td></tr>
<tr class="separator:a7fdc84fcc207cf0b718626997d11ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0124db0942485ff3afb224f48cd765" id="r_a9e0124db0942485ff3afb224f48cd765"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e0124db0942485ff3afb224f48cd765">GetFileSize</a> (const base::FilePath &amp;filepath)</td></tr>
<tr class="memdesc:a9e0124db0942485ff3afb224f48cd765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the file at |filepath|. The function will ignore symlinks (not follow them, not add them to the returned size).  <br /></td></tr>
<tr class="separator:a9e0124db0942485ff3afb224f48cd765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c75452e519dc3715a6f7f30fc83805" id="r_a23c75452e519dc3715a6f7f30fc83805"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23c75452e519dc3715a6f7f30fc83805">GetDirectorySize</a> (const base::FilePath &amp;dirPath)</td></tr>
<tr class="memdesc:a23c75452e519dc3715a6f7f30fc83805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the recursive sum of the size of the files in |dirPath|. The function will ignore symlinks (not follow them, not add them to the returned size).  <br /></td></tr>
<tr class="separator:a23c75452e519dc3715a6f7f30fc83805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f31c2f8b1cfea873b757dc486281437" id="r_a4f31c2f8b1cfea873b757dc486281437"><td class="memItemLeft" align="right" valign="top">std::vector&lt; zx_koid_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f31c2f8b1cfea873b757dc486281437">GetChildKoids</a> (const zx::object_base &amp;parent, zx_object_info_topic_t child_kind)</td></tr>
<tr class="memdesc:a4f31c2f8b1cfea873b757dc486281437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of child koids for a parent handle.  <br /></td></tr>
<tr class="separator:a4f31c2f8b1cfea873b757dc486281437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b88f2d030f9da088707bc361045ff86" id="r_a1b88f2d030f9da088707bc361045ff86"><td class="memItemLeft" align="right" valign="top">std::vector&lt; zx::thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b88f2d030f9da088707bc361045ff86">GetThreadHandles</a> (const zx::process &amp;parent)</td></tr>
<tr class="memdesc:a1b88f2d030f9da088707bc361045ff86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get handles representing a list of child objects of a given parent.  <br /></td></tr>
<tr class="separator:a1b88f2d030f9da088707bc361045ff86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24450f6cd81133935420337540b4d62b" id="r_a24450f6cd81133935420337540b4d62b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; zx::thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24450f6cd81133935420337540b4d62b">GetHandlesForThreadKoids</a> (const zx::process &amp;parent, const std::vector&lt; zx_koid_t &gt; &amp;koids)</td></tr>
<tr class="memdesc:a24450f6cd81133935420337540b4d62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of koids that are all children of a particular process into thread handles.  <br /></td></tr>
<tr class="separator:a24450f6cd81133935420337540b4d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99a5273dd73373a439df42cc39a8da0" id="r_ae99a5273dd73373a439df42cc39a8da0"><td class="memItemLeft" align="right" valign="top">zx::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae99a5273dd73373a439df42cc39a8da0">GetThreadHandleByKoid</a> (const zx::process &amp;parent, zx_koid_t child_koid)</td></tr>
<tr class="memdesc:ae99a5273dd73373a439df42cc39a8da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the handle of a process' thread, based on koid.  <br /></td></tr>
<tr class="separator:ae99a5273dd73373a439df42cc39a8da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78f92ab17c2ca6a7a86edc949ac1fde" id="r_aa78f92ab17c2ca6a7a86edc949ac1fde"><td class="memItemLeft" align="right" valign="top">zx_koid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa78f92ab17c2ca6a7a86edc949ac1fde">GetKoidForHandle</a> (const zx::object_base &amp;object)</td></tr>
<tr class="memdesc:aa78f92ab17c2ca6a7a86edc949ac1fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the koid for a given object handle.  <br /></td></tr>
<tr class="separator:aa78f92ab17c2ca6a7a86edc949ac1fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2e6f185467f42cb17ce959a13cc482" id="r_a2a2e6f185467f42cb17ce959a13cc482"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a2e6f185467f42cb17ce959a13cc482">InitializeSignalDispositions</a> ()</td></tr>
<tr class="memdesc:a2a2e6f185467f42cb17ce959a13cc482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes signal dispositions for a process based on the platform.  <br /></td></tr>
<tr class="separator:a2a2e6f185467f42cb17ce959a13cc482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6420c8cbc71259c4d6737b622aa5f07e" id="r_a6420c8cbc71259c4d6737b622aa5f07e"><td class="memItemLeft" align="right" valign="top"><a id="a6420c8cbc71259c4d6737b622aa5f07e" name="a6420c8cbc71259c4d6737b622aa5f07e"></a>
<a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StripPACBits</b> (<a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a> address)</td></tr>
<tr class="memdesc:a6420c8cbc71259c4d6737b622aa5f07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips PAC bits from an address. <br /></td></tr>
<tr class="separator:a6420c8cbc71259c4d6737b622aa5f07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93766162f8810f02d1891951937aede" id="r_ae93766162f8810f02d1891951937aede"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae93766162f8810f02d1891951937aede">ReadThreadIDs</a> (pid_t pid, std::vector&lt; pid_t &gt; *tids)</td></tr>
<tr class="memdesc:ae93766162f8810f02d1891951937aede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the thread IDs of a process by reading <code>/proc/<em>pid</em>/task</code>.  <br /></td></tr>
<tr class="separator:ae93766162f8810f02d1891951937aede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad304b11e44d0683d30518e2d0e1f92f5" id="r_ad304b11e44d0683d30518e2d0e1f92f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad304b11e44d0683d30518e2d0e1f92f5">PtraceAttach</a> (pid_t pid, bool can_log=true)</td></tr>
<tr class="memdesc:ad304b11e44d0683d30518e2d0e1f92f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches to the process with process ID <em class="arg">pid</em> and blocks until the target process has stopped by calling <code>waitpid()</code>.  <br /></td></tr>
<tr class="separator:ad304b11e44d0683d30518e2d0e1f92f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84984fc383ee4c9e22e6cdc25fd700f" id="r_af84984fc383ee4c9e22e6cdc25fd700f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84984fc383ee4c9e22e6cdc25fd700f">PtraceDetach</a> (pid_t pid, bool can_log=true)</td></tr>
<tr class="memdesc:af84984fc383ee4c9e22e6cdc25fd700f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the process with process ID <em class="arg">pid</em>. The process must already be ptrace attached.  <br /></td></tr>
<tr class="separator:af84984fc383ee4c9e22e6cdc25fd700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616ed0784021ecbd2f0f14b7e75c068c" id="r_a616ed0784021ecbd2f0f14b7e75c068c"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a616ed0784021ecbd2f0f14b7e75c068c">CFPropertyToLaunchData</a> (CFPropertyListRef property_cf)</td></tr>
<tr class="memdesc:a616ed0784021ecbd2f0f14b7e75c068c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Core Foundation-type property list to a launchd-type <code>launch_data_t</code>.  <br /></td></tr>
<tr class="separator:a616ed0784021ecbd2f0f14b7e75c068c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce484227aa401de226e81e42b6dfabd" id="r_abce484227aa401de226e81e42b6dfabd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abce484227aa401de226e81e42b6dfabd">MacOSVersionNumber</a> ()</td></tr>
<tr class="memdesc:abce484227aa401de226e81e42b6dfabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version of the running operating system.  <br /></td></tr>
<tr class="separator:abce484227aa401de226e81e42b6dfabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458272b3e9c9b83b2643c6f3bdf72924" id="r_a458272b3e9c9b83b2643c6f3bdf72924"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a458272b3e9c9b83b2643c6f3bdf72924">MacOSVersionComponents</a> (int *major, int *minor, int *bugfix, std::string *build, std::string *version_string)</td></tr>
<tr class="memdesc:a458272b3e9c9b83b2643c6f3bdf72924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version of the running operating system.  <br /></td></tr>
<tr class="separator:a458272b3e9c9b83b2643c6f3bdf72924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c79500b827d06b190e30b7cc016c35" id="r_a71c79500b827d06b190e30b7cc016c35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71c79500b827d06b190e30b7cc016c35">MacModelAndBoard</a> (std::string *model, std::string *board_id)</td></tr>
<tr class="memdesc:a71c79500b827d06b190e30b7cc016c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the model name and board ID of the running system.  <br /></td></tr>
<tr class="separator:a71c79500b827d06b190e30b7cc016c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ebbbac4c7f27e2e3ba2b9c080ed0f3" id="r_a97ebbbac4c7f27e2e3ba2b9c080ed0f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97ebbbac4c7f27e2e3ba2b9c080ed0f3">ServiceManagementSubmitJob</a> (CFDictionaryRef job_cf)</td></tr>
<tr class="memdesc:a97ebbbac4c7f27e2e3ba2b9c080ed0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a job to the user launchd domain as in <code>SMJobSubmit()</code>.  <br /></td></tr>
<tr class="separator:a97ebbbac4c7f27e2e3ba2b9c080ed0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc130fecf996b7d7c76a56200afccb1" id="r_a8cc130fecf996b7d7c76a56200afccb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cc130fecf996b7d7c76a56200afccb1">ServiceManagementRemoveJob</a> (const std::string &amp;label, bool wait)</td></tr>
<tr class="memdesc:a8cc130fecf996b7d7c76a56200afccb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a job from the user launchd domain as in <code>SMJobRemove()</code>.  <br /></td></tr>
<tr class="separator:a8cc130fecf996b7d7c76a56200afccb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead5f04bd94549956a7f2826aeccf495" id="r_aead5f04bd94549956a7f2826aeccf495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aead5f04bd94549956a7f2826aeccf495">ServiceManagementIsJobLoaded</a> (const std::string &amp;label)</td></tr>
<tr class="memdesc:aead5f04bd94549956a7f2826aeccf495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a specified job is loaded in the user launchd domain.  <br /></td></tr>
<tr class="separator:aead5f04bd94549956a7f2826aeccf495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc3a94386dd27968d48619f42154463" id="r_a3bc3a94386dd27968d48619f42154463"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bc3a94386dd27968d48619f42154463">ServiceManagementIsJobRunning</a> (const std::string &amp;label)</td></tr>
<tr class="memdesc:a3bc3a94386dd27968d48619f42154463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a specified job is running in the user launchd domain.  <br /></td></tr>
<tr class="separator:a3bc3a94386dd27968d48619f42154463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fd86bc618d758d07c29304df9fbf4f" id="r_a33fd86bc618d758d07c29304df9fbf4f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33fd86bc618d758d07c29304df9fbf4f">ReadStringSysctlByName</a> (const char *name, bool may_log_enoent)</td></tr>
<tr class="memdesc:a33fd86bc618d758d07c29304df9fbf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>sysctlbyname</code> to read a string.  <br /></td></tr>
<tr class="separator:a33fd86bc618d758d07c29304df9fbf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86f028e5f175cccfcab418346d7bcfe" id="r_ac86f028e5f175cccfcab418346d7bcfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac86f028e5f175cccfcab418346d7bcfe">ReadXattr</a> (const base::FilePath &amp;file, const base::StringPiece &amp;name, std::string *value)</td></tr>
<tr class="memdesc:ac86f028e5f175cccfcab418346d7bcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an extended attribute on a file.  <br /></td></tr>
<tr class="separator:ac86f028e5f175cccfcab418346d7bcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6842e0ae3110f04477765c771c04dc60" id="r_a6842e0ae3110f04477765c771c04dc60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6842e0ae3110f04477765c771c04dc60">WriteXattr</a> (const base::FilePath &amp;file, const base::StringPiece &amp;name, const std::string &amp;value)</td></tr>
<tr class="memdesc:a6842e0ae3110f04477765c771c04dc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an extended attribute on a file.  <br /></td></tr>
<tr class="separator:a6842e0ae3110f04477765c771c04dc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c682ff6d5f00ca828640a72436e196" id="r_ab8c682ff6d5f00ca828640a72436e196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8c682ff6d5f00ca828640a72436e196">ReadXattrBool</a> (const base::FilePath &amp;file, const base::StringPiece &amp;name, bool *value)</td></tr>
<tr class="memdesc:ab8c682ff6d5f00ca828640a72436e196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an extended attribute on a file.     <br /></td></tr>
<tr class="separator:ab8c682ff6d5f00ca828640a72436e196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae086861e350e7225e4ea065d941e664f" id="r_ae086861e350e7225e4ea065d941e664f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae086861e350e7225e4ea065d941e664f">WriteXattrBool</a> (const base::FilePath &amp;file, const base::StringPiece &amp;name, bool value)</td></tr>
<tr class="memdesc:ae086861e350e7225e4ea065d941e664f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an extended attribute on a file.     <br /></td></tr>
<tr class="separator:ae086861e350e7225e4ea065d941e664f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c28700ce2629c13b5b8bb1392625ef4" id="r_a0c28700ce2629c13b5b8bb1392625ef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c28700ce2629c13b5b8bb1392625ef4">ReadXattrInt</a> (const base::FilePath &amp;file, const base::StringPiece &amp;name, int *value)</td></tr>
<tr class="memdesc:a0c28700ce2629c13b5b8bb1392625ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an extended attribute on a file.     <br /></td></tr>
<tr class="separator:a0c28700ce2629c13b5b8bb1392625ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a3551184d900a1d970bd8fa0be0ec3" id="r_a85a3551184d900a1d970bd8fa0be0ec3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a3551184d900a1d970bd8fa0be0ec3">WriteXattrInt</a> (const base::FilePath &amp;file, const base::StringPiece &amp;name, int value)</td></tr>
<tr class="memdesc:a85a3551184d900a1d970bd8fa0be0ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an extended attribute on a file.     <br /></td></tr>
<tr class="separator:a85a3551184d900a1d970bd8fa0be0ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71572c94f27aba3f34938d3a0d9030a3" id="r_a71572c94f27aba3f34938d3a0d9030a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71572c94f27aba3f34938d3a0d9030a3">ReadXattrTimeT</a> (const base::FilePath &amp;file, const base::StringPiece &amp;name, time_t *value)</td></tr>
<tr class="memdesc:a71572c94f27aba3f34938d3a0d9030a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an extended attribute on a file.     <br /></td></tr>
<tr class="separator:a71572c94f27aba3f34938d3a0d9030a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63f9a1eeeec00b78c216f72b1ca1327" id="r_ae63f9a1eeeec00b78c216f72b1ca1327"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae63f9a1eeeec00b78c216f72b1ca1327">WriteXattrTimeT</a> (const base::FilePath &amp;file, const base::StringPiece &amp;name, time_t value)</td></tr>
<tr class="memdesc:ae63f9a1eeeec00b78c216f72b1ca1327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an extended attribute on a file.     <br /></td></tr>
<tr class="separator:ae63f9a1eeeec00b78c216f72b1ca1327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354d84b9ce60fa7d437c2ee6f58ea05f" id="r_a354d84b9ce60fa7d437c2ee6f58ea05f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a354d84b9ce60fa7d437c2ee6f58ea05f">RemoveXattr</a> (const base::FilePath &amp;file, const base::StringPiece &amp;name)</td></tr>
<tr class="memdesc:a354d84b9ce60fa7d437c2ee6f58ea05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an extended attribute from a file.  <br /></td></tr>
<tr class="separator:a354d84b9ce60fa7d437c2ee6f58ea05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab289b6fa3f20ee1c96a54b24174b4c9e" id="r_ab289b6fa3f20ee1c96a54b24174b4c9e"><td class="memItemLeft" align="right" valign="top">base::apple::ScopedMachReceiveRight&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab289b6fa3f20ee1c96a54b24174b4c9e">BootstrapCheckIn</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:ab289b6fa3f20ee1c96a54b24174b4c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a <code>boostrap_check_in()</code> call to the process’ bootstrap server.  <br /></td></tr>
<tr class="separator:ab289b6fa3f20ee1c96a54b24174b4c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4abb1fe0e33a5a404f48510ba952347" id="r_ad4abb1fe0e33a5a404f48510ba952347"><td class="memItemLeft" align="right" valign="top">base::apple::ScopedMachSendRight&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4abb1fe0e33a5a404f48510ba952347">BootstrapLookUp</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:ad4abb1fe0e33a5a404f48510ba952347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a <code>boostrap_look_up()</code> call to the process’ bootstrap server.  <br /></td></tr>
<tr class="separator:ad4abb1fe0e33a5a404f48510ba952347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8f0c52904467bf6c534f78a52d5699" id="r_abf8f0c52904467bf6c534f78a52d5699"><td class="memItemLeft" align="right" valign="top">base::apple::ScopedMachSendRight&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf8f0c52904467bf6c534f78a52d5699">SystemCrashReporterHandler</a> ()</td></tr>
<tr class="memdesc:abf8f0c52904467bf6c534f78a52d5699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the system’s default Mach exception handler for crash-type exceptions.  <br /></td></tr>
<tr class="separator:abf8f0c52904467bf6c534f78a52d5699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34001ec0bfa5e0815fa478a8cf025c61" id="r_a34001ec0bfa5e0815fa478a8cf025c61"><td class="memItemLeft" align="right" valign="top">kern_return_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34001ec0bfa5e0815fa478a8cf025c61">UniversalExceptionRaise</a> (exception_behavior_t behavior, exception_handler_t exception_port, thread_t thread, task_t task, exception_type_t exception, const mach_exception_data_type_t *code, mach_msg_type_number_t code_count, thread_state_flavor_t *flavor, <a class="el" href="#ae8a2e5f928712c15766a756cd2035d90">ConstThreadState</a> old_state, mach_msg_type_number_t old_state_count, thread_state_t new_state, mach_msg_type_number_t *new_state_count)</td></tr>
<tr class="memdesc:a34001ec0bfa5e0815fa478a8cf025c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the appropriate <code>*exception_raise*()</code> function for the specified <em class="arg">behavior</em>.  <br /></td></tr>
<tr class="separator:a34001ec0bfa5e0815fa478a8cf025c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2112e7fcb6a2fc7f9b6b0ff8856e8466" id="r_a2112e7fcb6a2fc7f9b6b0ff8856e8466"><td class="memItemLeft" align="right" valign="top">kern_return_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2112e7fcb6a2fc7f9b6b0ff8856e8466">ExcServerSuccessfulReturnValue</a> (exception_type_t exception, exception_behavior_t behavior, bool set_thread_state)</td></tr>
<tr class="memdesc:a2112e7fcb6a2fc7f9b6b0ff8856e8466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an approriate successful return value for an exception handler function.  <br /></td></tr>
<tr class="separator:a2112e7fcb6a2fc7f9b6b0ff8856e8466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac192440e1d208f5dd348f0cba652d93a" id="r_ac192440e1d208f5dd348f0cba652d93a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac192440e1d208f5dd348f0cba652d93a">ExcServerCopyState</a> (exception_behavior_t behavior, <a class="el" href="#ae8a2e5f928712c15766a756cd2035d90">ConstThreadState</a> old_state, mach_msg_type_number_t old_state_count, thread_state_t new_state, mach_msg_type_number_t *new_state_count)</td></tr>
<tr class="memdesc:ac192440e1d208f5dd348f0cba652d93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the old state to the new state for state-carrying exceptions.  <br /></td></tr>
<tr class="separator:ac192440e1d208f5dd348f0cba652d93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea6434eb784ccde471620e9d79ba8c1" id="r_acea6434eb784ccde471620e9d79ba8c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea6434eb784ccde471620e9d79ba8c1">ExceptionBehaviorHasState</a> (exception_behavior_t behavior)</td></tr>
<tr class="memdesc:acea6434eb784ccde471620e9d79ba8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <em class="arg">behavior</em> indicates an exception behavior that carries thread state information.  <br /></td></tr>
<tr class="separator:acea6434eb784ccde471620e9d79ba8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d424769dc3683b809a9783f9319d4ab" id="r_a5d424769dc3683b809a9783f9319d4ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d424769dc3683b809a9783f9319d4ab">ExceptionBehaviorHasIdentity</a> (exception_behavior_t behavior)</td></tr>
<tr class="memdesc:a5d424769dc3683b809a9783f9319d4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <em class="arg">behavior</em> indicates an exception behavior that carries thread and task identities.  <br /></td></tr>
<tr class="separator:a5d424769dc3683b809a9783f9319d4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd35f65144317021b4ea09a2b779bfb" id="r_a6cd35f65144317021b4ea09a2b779bfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cd35f65144317021b4ea09a2b779bfb">ExceptionBehaviorHasMachExceptionCodes</a> (exception_behavior_t behavior)</td></tr>
<tr class="memdesc:a6cd35f65144317021b4ea09a2b779bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <em class="arg">behavior</em> indicates an exception behavior that carries 64-bit exception codes (“Mach exception codes”).  <br /></td></tr>
<tr class="separator:a6cd35f65144317021b4ea09a2b779bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26b5b9a8355ab15063b1c07fa6dff7" id="r_a2e26b5b9a8355ab15063b1c07fa6dff7"><td class="memItemLeft" align="right" valign="top">exception_behavior_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e26b5b9a8355ab15063b1c07fa6dff7">ExceptionBehaviorBasic</a> (exception_behavior_t behavior)</td></tr>
<tr class="memdesc:a2e26b5b9a8355ab15063b1c07fa6dff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the basic behavior value of <em class="arg">behavior</em>, its value without <code>MACH_EXCEPTION_CODES</code> set.  <br /></td></tr>
<tr class="separator:a2e26b5b9a8355ab15063b1c07fa6dff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830c754edaa401f7d866e69369f76ae1" id="r_a830c754edaa401f7d866e69369f76ae1"><td class="memItemLeft" align="right" valign="top">exception_type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a830c754edaa401f7d866e69369f76ae1">ExcCrashRecoverOriginalException</a> (mach_exception_code_t code_0, mach_exception_code_t *original_code_0, int *signal)</td></tr>
<tr class="memdesc:a830c754edaa401f7d866e69369f76ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers the original exception, first exception code, and signal from the encoded form of the first exception code delivered with <code>EXC_CRASH</code> exceptions.  <br /></td></tr>
<tr class="separator:a830c754edaa401f7d866e69369f76ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c8325c451170f4d3fb883014656af3" id="r_a83c8325c451170f4d3fb883014656af3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83c8325c451170f4d3fb883014656af3">ExcCrashCouldContainException</a> (exception_type_t exception)</td></tr>
<tr class="memdesc:a83c8325c451170f4d3fb883014656af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a given exception type could plausibly be carried within an <code>EXC_CRASH</code> exception.  <br /></td></tr>
<tr class="separator:a83c8325c451170f4d3fb883014656af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac448d0b014125dc8edd9c617836eb44c" id="r_ac448d0b014125dc8edd9c617836eb44c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac448d0b014125dc8edd9c617836eb44c">ExceptionCodeForMetrics</a> (exception_type_t exception, mach_exception_code_t code_0)</td></tr>
<tr class="memdesc:ac448d0b014125dc8edd9c617836eb44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exception code to report via a configured metrics system.  <br /></td></tr>
<tr class="separator:ac448d0b014125dc8edd9c617836eb44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ac0b9fe2a066fecac5e8d9b977e892" id="r_ad2ac0b9fe2a066fecac5e8d9b977e892"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2ac0b9fe2a066fecac5e8d9b977e892">IsExceptionNonfatalResource</a> (exception_type_t exception, mach_exception_code_t code_0, pid_t pid)</td></tr>
<tr class="memdesc:ad2ac0b9fe2a066fecac5e8d9b977e892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an exception is a non-fatal <code>EXC_RESOURCE</code>.  <br /></td></tr>
<tr class="separator:ad2ac0b9fe2a066fecac5e8d9b977e892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ee9764b34c0267b58f54404946275a" id="r_a79ee9764b34c0267b58f54404946275a"><td class="memItemLeft" align="right" valign="top">thread_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ee9764b34c0267b58f54404946275a">MachThreadSelf</a> ()</td></tr>
<tr class="memdesc:a79ee9764b34c0267b58f54404946275a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>mach_thread_self()</code>, but without the obligation to release the send right.  <br /></td></tr>
<tr class="separator:a79ee9764b34c0267b58f54404946275a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9bc6ad9973f794c425707617b63278" id="r_a9c9bc6ad9973f794c425707617b63278"><td class="memItemLeft" align="right" valign="top">mach_port_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c9bc6ad9973f794c425707617b63278">NewMachPort</a> (mach_port_right_t right)</td></tr>
<tr class="memdesc:a9c9bc6ad9973f794c425707617b63278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Mach port in the current task.  <br /></td></tr>
<tr class="separator:a9c9bc6ad9973f794c425707617b63278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194e0575e09db56e4107e1c41b27c941" id="r_a194e0575e09db56e4107e1c41b27c941"><td class="memItemLeft" align="right" valign="top">exception_mask_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a194e0575e09db56e4107e1c41b27c941">ExcMaskAll</a> ()</td></tr>
<tr class="memdesc:a194e0575e09db56e4107e1c41b27c941"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value for <code>EXC_MASK_ALL</code> appropriate for the operating system at run time.  <br /></td></tr>
<tr class="separator:a194e0575e09db56e4107e1c41b27c941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e47623f33e0c86fef1d08a82b28cc9" id="r_a18e47623f33e0c86fef1d08a82b28cc9"><td class="memItemLeft" align="right" valign="top">exception_mask_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18e47623f33e0c86fef1d08a82b28cc9">ExcMaskValid</a> ()</td></tr>
<tr class="memdesc:a18e47623f33e0c86fef1d08a82b28cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception mask containing every possible exception understood by the operating system at run time.  <br /></td></tr>
<tr class="separator:a18e47623f33e0c86fef1d08a82b28cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31f495c675536bcb30d1267c3a9b696" id="r_aa31f495c675536bcb30d1267c3a9b696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abd63ad5a7c13f493e8d1e37ef7801bce">MachMessageDeadline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa31f495c675536bcb30d1267c3a9b696">MachMessageDeadlineFromTimeout</a> (mach_msg_timeout_t timeout_ms)</td></tr>
<tr class="memdesc:aa31f495c675536bcb30d1267c3a9b696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the deadline for a specified timeout value.  <br /></td></tr>
<tr class="separator:aa31f495c675536bcb30d1267c3a9b696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35293418a0b7637a00631807ac4b431e" id="r_a35293418a0b7637a00631807ac4b431e"><td class="memItemLeft" align="right" valign="top">mach_msg_return_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35293418a0b7637a00631807ac4b431e">MachMessageWithDeadline</a> (mach_msg_header_t *message, mach_msg_option_t options, mach_msg_size_t receive_size, mach_port_name_t receive_port, <a class="el" href="#abd63ad5a7c13f493e8d1e37ef7801bce">MachMessageDeadline</a> deadline, mach_port_name_t notify_port, bool run_even_if_expired)</td></tr>
<tr class="memdesc:a35293418a0b7637a00631807ac4b431e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs <code>mach_msg()</code> with a deadline, as opposed to a timeout.  <br /></td></tr>
<tr class="separator:a35293418a0b7637a00631807ac4b431e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2274adc0459f68b93ffe51d8f975f14e" id="r_a2274adc0459f68b93ffe51d8f975f14e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2274adc0459f68b93ffe51d8f975f14e">PrepareMIGReplyFromRequest</a> (const mach_msg_header_t *in_header, mach_msg_header_t *out_header)</td></tr>
<tr class="memdesc:a2274adc0459f68b93ffe51d8f975f14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a reply message for a MIG server routine based on its corresponding request.  <br /></td></tr>
<tr class="separator:a2274adc0459f68b93ffe51d8f975f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa023691aedd4f3e6faa923e8d2095947" id="r_aa023691aedd4f3e6faa923e8d2095947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa023691aedd4f3e6faa923e8d2095947">SetMIGReplyError</a> (mach_msg_header_t *out_header, kern_return_t error)</td></tr>
<tr class="memdesc:aa023691aedd4f3e6faa923e8d2095947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the error code in a reply message for a MIG server routine.  <br /></td></tr>
<tr class="separator:aa023691aedd4f3e6faa923e8d2095947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979ca1d327dcf56488d3304efa9680eb" id="r_a979ca1d327dcf56488d3304efa9680eb"><td class="memItemLeft" align="right" valign="top">const mach_msg_trailer_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a979ca1d327dcf56488d3304efa9680eb">MachMessageTrailerFromHeader</a> (const mach_msg_header_t *header)</td></tr>
<tr class="memdesc:a979ca1d327dcf56488d3304efa9680eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Mach message trailer for a message that has been received.  <br /></td></tr>
<tr class="separator:a979ca1d327dcf56488d3304efa9680eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2670a96d46f33b0e88db50a6222c0b47" id="r_a2670a96d46f33b0e88db50a6222c0b47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2670a96d46f33b0e88db50a6222c0b47">MachMessageDestroyReceivedPort</a> (mach_port_t port, mach_msg_type_name_t port_right_type)</td></tr>
<tr class="memdesc:a2670a96d46f33b0e88db50a6222c0b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys or deallocates a Mach port received in a Mach message.  <br /></td></tr>
<tr class="separator:a2670a96d46f33b0e88db50a6222c0b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c18eae8148ec3304733581a28c2da3b" id="r_a2c18eae8148ec3304733581a28c2da3b"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c18eae8148ec3304733581a28c2da3b">AuditPIDFromMachMessageTrailer</a> (const mach_msg_trailer_t *trailer)</td></tr>
<tr class="memdesc:a2c18eae8148ec3304733581a28c2da3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the process ID of a Mach message’s sender from its audit trailer.  <br /></td></tr>
<tr class="separator:a2c18eae8148ec3304733581a28c2da3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05296bfd23550f42639067355410811e" id="r_a05296bfd23550f42639067355410811e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05296bfd23550f42639067355410811e">ExceptionToString</a> (exception_type_t exception, <a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a> options)</td></tr>
<tr class="memdesc:a05296bfd23550f42639067355410811e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Mach exception value to a textual representation.  <br /></td></tr>
<tr class="separator:a05296bfd23550f42639067355410811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229a9b5ddd24c6722e413e6132d0acf0" id="r_a229a9b5ddd24c6722e413e6132d0acf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a229a9b5ddd24c6722e413e6132d0acf0">StringToException</a> (const base::StringPiece &amp;string, <a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a> options, exception_type_t *exception)</td></tr>
<tr class="memdesc:a229a9b5ddd24c6722e413e6132d0acf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to its corresponding Mach exception value.  <br /></td></tr>
<tr class="separator:a229a9b5ddd24c6722e413e6132d0acf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee31102507c0f75d82496dcd6f6b53b" id="r_a8ee31102507c0f75d82496dcd6f6b53b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ee31102507c0f75d82496dcd6f6b53b">ExceptionMaskToString</a> (exception_mask_t exception_mask, <a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a> options)</td></tr>
<tr class="memdesc:a8ee31102507c0f75d82496dcd6f6b53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Mach exception mask value to a textual representation.  <br /></td></tr>
<tr class="separator:a8ee31102507c0f75d82496dcd6f6b53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab63868a738f3bfd4d2449e60607dec" id="r_a7ab63868a738f3bfd4d2449e60607dec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ab63868a738f3bfd4d2449e60607dec">StringToExceptionMask</a> (const base::StringPiece &amp;string, <a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a> options, exception_mask_t *exception_mask)</td></tr>
<tr class="memdesc:a7ab63868a738f3bfd4d2449e60607dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to its corresponding Mach exception mask value.  <br /></td></tr>
<tr class="separator:a7ab63868a738f3bfd4d2449e60607dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fd131112ba6eba0d81467733a7643a" id="r_a53fd131112ba6eba0d81467733a7643a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53fd131112ba6eba0d81467733a7643a">ExceptionBehaviorToString</a> (exception_behavior_t behavior, <a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a> options)</td></tr>
<tr class="memdesc:a53fd131112ba6eba0d81467733a7643a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Mach exception behavior value to a textual representation.  <br /></td></tr>
<tr class="separator:a53fd131112ba6eba0d81467733a7643a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957c7de6eb716bf1662c08333b1f7e21" id="r_a957c7de6eb716bf1662c08333b1f7e21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a957c7de6eb716bf1662c08333b1f7e21">StringToExceptionBehavior</a> (const base::StringPiece &amp;string, <a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a> options, exception_behavior_t *behavior)</td></tr>
<tr class="memdesc:a957c7de6eb716bf1662c08333b1f7e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to its corresponding Mach exception behavior value.  <br /></td></tr>
<tr class="separator:a957c7de6eb716bf1662c08333b1f7e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857f6b2f39cb21b22891242df26757e0" id="r_a857f6b2f39cb21b22891242df26757e0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a857f6b2f39cb21b22891242df26757e0">ThreadStateFlavorToString</a> (thread_state_flavor_t flavor, <a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a> options)</td></tr>
<tr class="memdesc:a857f6b2f39cb21b22891242df26757e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a thread state flavor value to a textual representation.  <br /></td></tr>
<tr class="separator:a857f6b2f39cb21b22891242df26757e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdb1f659a2813e80d5b644020a44208" id="r_a2fdb1f659a2813e80d5b644020a44208"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fdb1f659a2813e80d5b644020a44208">StringToThreadStateFlavor</a> (const base::StringPiece &amp;string, <a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a> options, thread_state_flavor_t *flavor)</td></tr>
<tr class="memdesc:a2fdb1f659a2813e80d5b644020a44208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to its corresponding thread state flavor value.  <br /></td></tr>
<tr class="separator:a2fdb1f659a2813e80d5b644020a44208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff94a266a84248b3ff0defae01efd8d" id="r_aeff94a266a84248b3ff0defae01efd8d"><td class="memItemLeft" align="right" valign="top">task_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeff94a266a84248b3ff0defae01efd8d">TaskForPID</a> (pid_t pid)</td></tr>
<tr class="memdesc:aeff94a266a84248b3ff0defae01efd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <code>task_for_pid()</code>.  <br /></td></tr>
<tr class="separator:aeff94a266a84248b3ff0defae01efd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fde6ff8bc97d9f84bf0cdee5413987" id="r_a89fde6ff8bc97d9f84bf0cdee5413987"><td class="memTemplParams" colspan="2">template&lt;typename From&gt; </td></tr>
<tr class="memitem:a89fde6ff8bc97d9f84bf0cdee5413987"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::underlying_type&lt; From &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89fde6ff8bc97d9f84bf0cdee5413987">AsUnderlyingType</a> (From from)</td></tr>
<tr class="memdesc:a89fde6ff8bc97d9f84bf0cdee5413987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a value to its underlying type.  <br /></td></tr>
<tr class="separator:a89fde6ff8bc97d9f84bf0cdee5413987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25486c6b4c38fc7c7868e978094edcf" id="r_ac25486c6b4c38fc7c7868e978094edcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac25486c6b4c38fc7c7868e978094edcf">CaptureContext</a> (NativeCPUContext *cpu_context)</td></tr>
<tr class="memdesc:ac25486c6b4c38fc7c7868e978094edcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the CPU context.  <br /></td></tr>
<tr class="separator:ac25486c6b4c38fc7c7868e978094edcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93af751a4a09c316fb3de1a90e03fe8" id="r_aa93af751a4a09c316fb3de1a90e03fe8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa93af751a4a09c316fb3de1a90e03fe8">ClockMonotonicNanoseconds</a> ()</td></tr>
<tr class="memdesc:aa93af751a4a09c316fb3de1a90e03fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the system’s monotonic clock.  <br /></td></tr>
<tr class="separator:aa93af751a4a09c316fb3de1a90e03fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1db976c6e43d3731c26df569368592" id="r_a8f1db976c6e43d3731c26df569368592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f1db976c6e43d3731c26df569368592">SleepNanoseconds</a> (uint64_t nanoseconds)</td></tr>
<tr class="memdesc:a8f1db976c6e43d3731c26df569368592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps for the specified duration.  <br /></td></tr>
<tr class="separator:a8f1db976c6e43d3731c26df569368592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84c4880b695542867ee6ac872f0f98f" id="r_aa84c4880b695542867ee6ac872f0f98f"><td class="memTemplParams" colspan="2">template&lt;typename To, typename From&gt; </td></tr>
<tr class="memitem:aa84c4880b695542867ee6ac872f0f98f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa84c4880b695542867ee6ac872f0f98f">FromPointerCast</a> (From from)</td></tr>
<tr class="memdesc:aa84c4880b695542867ee6ac872f0f98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts from a pointer type to an integer.  <br /></td></tr>
<tr class="separator:aa84c4880b695542867ee6ac872f0f98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eb7be14f9f8d0aea6621fddbd4ff07" id="r_a97eb7be14f9f8d0aea6621fddbd4ff07"><td class="memTemplParams" colspan="2"><a id="a97eb7be14f9f8d0aea6621fddbd4ff07" name="a97eb7be14f9f8d0aea6621fddbd4ff07"></a>
template&lt;typename To, typename From&gt; </td></tr>
<tr class="memitem:a97eb7be14f9f8d0aea6621fddbd4ff07"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>implicit_cast</b> (From const &amp;f)</td></tr>
<tr class="separator:a97eb7be14f9f8d0aea6621fddbd4ff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37351a34cc3b9282a1f590062b5368d" id="r_ad37351a34cc3b9282a1f590062b5368d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad37351a34cc3b9282a1f590062b5368d">AdvancePastPrefix</a> (const char **input, const char *pattern)</td></tr>
<tr class="memdesc:ad37351a34cc3b9282a1f590062b5368d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a pattern at the start of a char string.  <br /></td></tr>
<tr class="separator:ad37351a34cc3b9282a1f590062b5368d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2aeb6f5cc4e5b302c6da3141e1b9c4" id="r_a2a2aeb6f5cc4e5b302c6da3141e1b9c4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2a2aeb6f5cc4e5b302c6da3141e1b9c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a2aeb6f5cc4e5b302c6da3141e1b9c4">AdvancePastNumber</a> (const char **input, T *value)</td></tr>
<tr class="memdesc:a2a2aeb6f5cc4e5b302c6da3141e1b9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a prefix of a char string to a numeric value.  <br /></td></tr>
<tr class="separator:a2a2aeb6f5cc4e5b302c6da3141e1b9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c27a6c1cd102df597d0c61b2416987b" id="r_a0c27a6c1cd102df597d0c61b2416987b"><td class="memItemLeft" align="right" valign="top"><a id="a0c27a6c1cd102df597d0c61b2416987b" name="a0c27a6c1cd102df597d0c61b2416987b"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>AdvancePastNumber</b> (const char **input, int *value)</td></tr>
<tr class="separator:a0c27a6c1cd102df597d0c61b2416987b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7389c5df4bfa776ede4af3234b177f" id="r_ade7389c5df4bfa776ede4af3234b177f"><td class="memItemLeft" align="right" valign="top"><a id="ade7389c5df4bfa776ede4af3234b177f" name="ade7389c5df4bfa776ede4af3234b177f"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>AdvancePastNumber</b> (const char **input, unsigned int *value)</td></tr>
<tr class="separator:ade7389c5df4bfa776ede4af3234b177f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8008ce6dd10c2d8584bc0c2472a0ab" id="r_a5a8008ce6dd10c2d8584bc0c2472a0ab"><td class="memItemLeft" align="right" valign="top"><a id="a5a8008ce6dd10c2d8584bc0c2472a0ab" name="a5a8008ce6dd10c2d8584bc0c2472a0ab"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>AdvancePastNumber</b> (const char **input, int64_t *value)</td></tr>
<tr class="separator:a5a8008ce6dd10c2d8584bc0c2472a0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb210d6ced91b270efd2380b325bb61" id="r_aacb210d6ced91b270efd2380b325bb61"><td class="memItemLeft" align="right" valign="top"><a id="aacb210d6ced91b270efd2380b325bb61" name="aacb210d6ced91b270efd2380b325bb61"></a>
template bool&#160;</td><td class="memItemRight" valign="bottom"><b>AdvancePastNumber</b> (const char **input, uint64_t *value)</td></tr>
<tr class="separator:aacb210d6ced91b270efd2380b325bb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15d0aff86a0aafe6f33cbd8913441c7" id="r_ab15d0aff86a0aafe6f33cbd8913441c7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab15d0aff86a0aafe6f33cbd8913441c7">RandomString</a> ()</td></tr>
<tr class="memdesc:ab15d0aff86a0aafe6f33cbd8913441c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random string.  <br /></td></tr>
<tr class="separator:ab15d0aff86a0aafe6f33cbd8913441c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b73837f43334046a1b56763fefba55" id="r_a61b73837f43334046a1b56763fefba55"><td class="memTemplParams" colspan="2">template&lt;typename From, typename To&gt; </td></tr>
<tr class="memitem:a61b73837f43334046a1b56763fefba55"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61b73837f43334046a1b56763fefba55">ReinterpretBytes</a> (const From &amp;from, To *to)</td></tr>
<tr class="memdesc:a61b73837f43334046a1b56763fefba55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the bytes of <em class="arg">from</em> to <em class="arg">to</em>.  <br /></td></tr>
<tr class="separator:a61b73837f43334046a1b56763fefba55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32471533814718469f9ecf23eaa74944" id="r_a32471533814718469f9ecf23eaa74944"><td class="memItemLeft" align="right" valign="top"><a id="a32471533814718469f9ecf23eaa74944" name="a32471533814718469f9ecf23eaa74944"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddTimespec</b> (const timespec &amp;ts1, const timespec &amp;ts2, timespec *result)</td></tr>
<tr class="memdesc:a32471533814718469f9ecf23eaa74944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code>timespec</code> <em class="arg">ts1</em> and <em class="arg">ts2</em> and return the result in <em class="arg">result</em>. <br /></td></tr>
<tr class="separator:a32471533814718469f9ecf23eaa74944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746883826dd3de7b677f0a6579b14269" id="r_a746883826dd3de7b677f0a6579b14269"><td class="memItemLeft" align="right" valign="top"><a id="a746883826dd3de7b677f0a6579b14269" name="a746883826dd3de7b677f0a6579b14269"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SubtractTimespec</b> (const timespec &amp;ts1, const timespec &amp;ts2, timespec *result)</td></tr>
<tr class="memdesc:a746883826dd3de7b677f0a6579b14269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <code>timespec</code> <em class="arg">ts2</em> from <em class="arg">ts1</em> and return the result in <em class="arg">result</em>. <br /></td></tr>
<tr class="separator:a746883826dd3de7b677f0a6579b14269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7029dc1761d085612fdd6732d7130a" id="r_a6b7029dc1761d085612fdd6732d7130a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b7029dc1761d085612fdd6732d7130a">TimespecToTimeval</a> (const timespec &amp;ts, timeval *tv)</td></tr>
<tr class="memdesc:a6b7029dc1761d085612fdd6732d7130a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the timespec <em class="arg">ts</em> to a timeval <em class="arg">tv</em>.  <br /></td></tr>
<tr class="separator:a6b7029dc1761d085612fdd6732d7130a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038930079974fac8f61b6eda499a1054" id="r_a038930079974fac8f61b6eda499a1054"><td class="memItemLeft" align="right" valign="top"><a id="a038930079974fac8f61b6eda499a1054" name="a038930079974fac8f61b6eda499a1054"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TimevalToTimespec</b> (const timeval &amp;tv, timespec *ts)</td></tr>
<tr class="memdesc:a038930079974fac8f61b6eda499a1054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the timeval <em class="arg">tv</em> to a timespec <em class="arg">ts</em>. <br /></td></tr>
<tr class="separator:a038930079974fac8f61b6eda499a1054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e91135de65a20af65aded0217d6406" id="r_a53e91135de65a20af65aded0217d6406"><td class="memItemLeft" align="right" valign="top"><a id="a53e91135de65a20af65aded0217d6406" name="a53e91135de65a20af65aded0217d6406"></a>
FILETIME&#160;</td><td class="memItemRight" valign="bottom"><b>TimespecToFiletimeEpoch</b> (const timespec &amp;ts)</td></tr>
<tr class="memdesc:a53e91135de65a20af65aded0217d6406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <code>timespec</code> to a Windows <code>FILETIME</code>, converting from POSIX epoch to Windows epoch. <br /></td></tr>
<tr class="separator:a53e91135de65a20af65aded0217d6406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aab6472269d38857cd7c493b409cf3b" id="r_a4aab6472269d38857cd7c493b409cf3b"><td class="memItemLeft" align="right" valign="top"><a id="a4aab6472269d38857cd7c493b409cf3b" name="a4aab6472269d38857cd7c493b409cf3b"></a>
timespec&#160;</td><td class="memItemRight" valign="bottom"><b>FiletimeToTimespecEpoch</b> (const FILETIME &amp;filetime)</td></tr>
<tr class="memdesc:a4aab6472269d38857cd7c493b409cf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Windows <code>FILETIME</code> to <code>timespec</code>, converting from Windows epoch to POSIX epoch. <br /></td></tr>
<tr class="separator:a4aab6472269d38857cd7c493b409cf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12442a42a099c4b68211fd230e94f42c" id="r_a12442a42a099c4b68211fd230e94f42c"><td class="memItemLeft" align="right" valign="top"><a id="a12442a42a099c4b68211fd230e94f42c" name="a12442a42a099c4b68211fd230e94f42c"></a>
timeval&#160;</td><td class="memItemRight" valign="bottom"><b>FiletimeToTimevalEpoch</b> (const FILETIME &amp;filetime)</td></tr>
<tr class="memdesc:a12442a42a099c4b68211fd230e94f42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Windows <code>FILETIME</code> to <code>timeval</code>, converting from Windows epoch to POSIX epoch. <br /></td></tr>
<tr class="separator:a12442a42a099c4b68211fd230e94f42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2597c6565e3733dceb0f933cea2146a1" id="r_a2597c6565e3733dceb0f933cea2146a1"><td class="memItemLeft" align="right" valign="top"><a id="a2597c6565e3733dceb0f933cea2146a1" name="a2597c6565e3733dceb0f933cea2146a1"></a>
timeval&#160;</td><td class="memItemRight" valign="bottom"><b>FiletimeToTimevalInterval</b> (const FILETIME &amp;filetime)</td></tr>
<tr class="memdesc:a2597c6565e3733dceb0f933cea2146a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Windows <code>FILETIME</code> to <code>timeval</code>, treating the values as an interval of elapsed time. <br /></td></tr>
<tr class="separator:a2597c6565e3733dceb0f933cea2146a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad150794de658f3bec7f37aa33ac521c4" id="r_ad150794de658f3bec7f37aa33ac521c4"><td class="memItemLeft" align="right" valign="top"><a id="ad150794de658f3bec7f37aa33ac521c4" name="ad150794de658f3bec7f37aa33ac521c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetTimeOfDay</b> (timeval *tv)</td></tr>
<tr class="memdesc:ad150794de658f3bec7f37aa33ac521c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to POSIX <code>gettimeofday()</code>, gets the current system time in UTC. <br /></td></tr>
<tr class="separator:ad150794de658f3bec7f37aa33ac521c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546d3f9feba8be654adc0292f99e043a" id="r_a546d3f9feba8be654adc0292f99e043a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a546d3f9feba8be654adc0292f99e043a">GetBootTime</a> (timespec *ts)</td></tr>
<tr class="memdesc:a546d3f9feba8be654adc0292f99e043a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the kernel boot time. Subsequent calls to this function may return different results due to the system clock being changed or imprecision in measuring the boot time.  <br /></td></tr>
<tr class="separator:a546d3f9feba8be654adc0292f99e043a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a547efca1b5ea53e95a3a12047c38a" id="r_af9a547efca1b5ea53e95a3a12047c38a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9a547efca1b5ea53e95a3a12047c38a">ZlibWindowBitsWithGzipWrapper</a> (int window_bits)</td></tr>
<tr class="memdesc:af9a547efca1b5ea53e95a3a12047c38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a <em class="arg">window_bits</em> parameter to pass to <code>deflateInit2()</code> or <code>inflateInit2()</code> that specifies a <code>gzip</code> wrapper instead of the default zlib wrapper.  <br /></td></tr>
<tr class="separator:af9a547efca1b5ea53e95a3a12047c38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0634eb0299cf5b28f7a373454d97c51" id="r_ae0634eb0299cf5b28f7a373454d97c51"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0634eb0299cf5b28f7a373454d97c51">ZlibErrorString</a> (int zr)</td></tr>
<tr class="memdesc:ae0634eb0299cf5b28f7a373454d97c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string for an error received from the zlib library.  <br /></td></tr>
<tr class="separator:ae0634eb0299cf5b28f7a373454d97c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b771a34723da94fac698418232b1e2" id="r_a16b771a34723da94fac698418232b1e2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16b771a34723da94fac698418232b1e2">URLEncode</a> (const std::string &amp;url)</td></tr>
<tr class="memdesc:a16b771a34723da94fac698418232b1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs percent-encoding (URL encoding) on the input string, following RFC 3986 paragraph 2.  <br /></td></tr>
<tr class="separator:a16b771a34723da94fac698418232b1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89adfd6e277a5762f2e9b30e1af289e" id="r_ae89adfd6e277a5762f2e9b30e1af289e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae89adfd6e277a5762f2e9b30e1af289e">CrackURL</a> (const std::string &amp;url, std::string *scheme, std::string *host, std::string *port, std::string *rest)</td></tr>
<tr class="memdesc:ae89adfd6e277a5762f2e9b30e1af289e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crack a URL into component parts.  <br /></td></tr>
<tr class="separator:ae89adfd6e277a5762f2e9b30e1af289e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1b1c536af301cd418dad62348b1d29" id="r_a6e1b1c536af301cd418dad62348b1d29"><td class="memTemplParams" colspan="2">template&lt;typename Destination, typename Source&gt; </td></tr>
<tr class="memitem:a6e1b1c536af301cd418dad62348b1d29"><td class="memTemplItemLeft" align="right" valign="top">Destination&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e1b1c536af301cd418dad62348b1d29">InRangeCast</a> (Source source, Destination default_value)</td></tr>
<tr class="memdesc:a6e1b1c536af301cd418dad62348b1d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts to a different type if it can be done without data loss, logging a warning message and returing a default value otherwise.  <br /></td></tr>
<tr class="separator:a6e1b1c536af301cd418dad62348b1d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb040202b4562c8c4087b9c9db2ce430" id="r_aeb040202b4562c8c4087b9c9db2ce430"><td class="memTemplParams" colspan="2">template&lt;typename Destination, typename Source&gt; </td></tr>
<tr class="memitem:aeb040202b4562c8c4087b9c9db2ce430"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb040202b4562c8c4087b9c9db2ce430">AssignIfInRange</a> (Destination *destination, Source source)</td></tr>
<tr class="memdesc:aeb040202b4562c8c4087b9c9db2ce430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an assignment if it can be done safely, and signals if it cannot be done safely.  <br /></td></tr>
<tr class="separator:aeb040202b4562c8c4087b9c9db2ce430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003f563ef0fe26081b4520012e0c1ef8" id="r_a003f563ef0fe26081b4520012e0c1ef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a003f563ef0fe26081b4520012e0c1ef8">CloseMultipleNowOrOnExec</a> (int fd, int preserve_fd)</td></tr>
<tr class="memdesc:a003f563ef0fe26081b4520012e0c1ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close multiple file descriptors or mark them close-on-exec.  <br /></td></tr>
<tr class="separator:a003f563ef0fe26081b4520012e0c1ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a3145ce95463d1638428b2547cde4d" id="r_aa8a3145ce95463d1638428b2547cde4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8a3145ce95463d1638428b2547cde4d">CloseStdinAndStdout</a> ()</td></tr>
<tr class="memdesc:aa8a3145ce95463d1638428b2547cde4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes <code>stdin</code> and <code>stdout</code> by opening <code>/dev/null</code> over them.  <br /></td></tr>
<tr class="separator:aa8a3145ce95463d1638428b2547cde4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5ee7c62768446ceb8fa8a76db99952" id="r_a5e5ee7c62768446ceb8fa8a76db99952"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e5ee7c62768446ceb8fa8a76db99952">DropPrivileges</a> ()</td></tr>
<tr class="memdesc:a5e5ee7c62768446ceb8fa8a76db99952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently drops privileges conferred by being a setuid or setgid executable.  <br /></td></tr>
<tr class="separator:a5e5ee7c62768446ceb8fa8a76db99952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1a9edb4c9626920d9add1664acc631" id="r_aca1a9edb4c9626920d9add1664acc631"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca1a9edb4c9626920d9add1664acc631">SpawnSubprocess</a> (const std::vector&lt; std::string &gt; &amp;argv, const std::vector&lt; std::string &gt; *envp, int preserve_fd, bool use_path, void(*child_function)())</td></tr>
<tr class="memdesc:aca1a9edb4c9626920d9add1664acc631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a subprocess.  <br /></td></tr>
<tr class="separator:aca1a9edb4c9626920d9add1664acc631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b946d80de148d1fd2452af38b220f4" id="r_a97b946d80de148d1fd2452af38b220f4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97b946d80de148d1fd2452af38b220f4">SignalToString</a> (int signal, <a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a> options)</td></tr>
<tr class="memdesc:a97b946d80de148d1fd2452af38b220f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a POSIX signal value to a textual representation.  <br /></td></tr>
<tr class="separator:a97b946d80de148d1fd2452af38b220f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6249dd58c6a81b300d64b25a943fa25c" id="r_a6249dd58c6a81b300d64b25a943fa25c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6249dd58c6a81b300d64b25a943fa25c">StringToSignal</a> (const base::StringPiece &amp;string, <a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a> options, int *signal)</td></tr>
<tr class="memdesc:a6249dd58c6a81b300d64b25a943fa25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to its corresponding POSIX signal value.  <br /></td></tr>
<tr class="separator:a6249dd58c6a81b300d64b25a943fa25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8be7196ea1ef43c438be47b1f3bbf57" id="r_ab8be7196ea1ef43c438be47b1f3bbf57"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8be7196ea1ef43c438be47b1f3bbf57">AlignedAllocate</a> (size_t alignment, size_t size)</td></tr>
<tr class="memdesc:ab8be7196ea1ef43c438be47b1f3bbf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory with the specified alignment constraint.  <br /></td></tr>
<tr class="separator:ab8be7196ea1ef43c438be47b1f3bbf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4cc77fb390eed171c11c6e06b78c85" id="r_a4d4cc77fb390eed171c11c6e06b78c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d4cc77fb390eed171c11c6e06b78c85">AlignedFree</a> (void *pointer)</td></tr>
<tr class="memdesc:a4d4cc77fb390eed171c11c6e06b78c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated by <a class="el" href="#ab8be7196ea1ef43c438be47b1f3bbf57" title="Allocates memory with the specified alignment constraint.">AlignedAllocate()</a>.  <br /></td></tr>
<tr class="separator:a4d4cc77fb390eed171c11c6e06b78c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c02d0116a6584c2dbe07ccc932f1acf" id="r_a8c02d0116a6584c2dbe07ccc932f1acf"><td class="memTemplParams" colspan="2"><a id="a8c02d0116a6584c2dbe07ccc932f1acf" name="a8c02d0116a6584c2dbe07ccc932f1acf"></a>
template&lt;class T1, class T2, size_t Alignment&gt; </td></tr>
<tr class="memitem:a8c02d0116a6584c2dbe07ccc932f1acf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structcrashpad_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T1, Alignment &gt; &amp;lhs, const <a class="el" href="structcrashpad_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T2, Alignment &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8c02d0116a6584c2dbe07ccc932f1acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd5b93493013a882e5beb9f8bdc740d" id="r_a8cd5b93493013a882e5beb9f8bdc740d"><td class="memTemplParams" colspan="2"><a id="a8cd5b93493013a882e5beb9f8bdc740d" name="a8cd5b93493013a882e5beb9f8bdc740d"></a>
template&lt;class T1, class T2, size_t Alignment&gt; </td></tr>
<tr class="memitem:a8cd5b93493013a882e5beb9f8bdc740d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structcrashpad_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T1, Alignment &gt; &amp;lhs, const <a class="el" href="structcrashpad_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; T2, Alignment &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8cd5b93493013a882e5beb9f8bdc740d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0486df983d8e9cecbe1e46e0059806df" id="r_a0486df983d8e9cecbe1e46e0059806df"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0486df983d8e9cecbe1e46e0059806df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0486df983d8e9cecbe1e46e0059806df">MapInsertOrReplace</a> (T *map, const typename T::key_type &amp;key, const typename T::mapped_type &amp;value, typename T::mapped_type *old_value)</td></tr>
<tr class="memdesc:a0486df983d8e9cecbe1e46e0059806df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a mapping from <em class="arg">key</em> to <em class="arg">value</em> into <em class="arg">map</em>, or replaces an existing mapping so that <em class="arg">key</em> maps to <em class="arg">value</em>.  <br /></td></tr>
<tr class="separator:a0486df983d8e9cecbe1e46e0059806df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97634ff8f75404670da123e9453c170" id="r_ae97634ff8f75404670da123e9453c170"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae97634ff8f75404670da123e9453c170">c16lcpy</a> (char16_t *destination, const char16_t *source, size_t length)</td></tr>
<tr class="memdesc:ae97634ff8f75404670da123e9453c170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a <code>NUL</code>-terminated char16_t-based string to a fixed-size buffer.  <br /></td></tr>
<tr class="separator:ae97634ff8f75404670da123e9453c170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8605dea4710c2630ccdd21439e05999" id="r_ac8605dea4710c2630ccdd21439e05999"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8605dea4710c2630ccdd21439e05999">strnlen</a> (const char *string, size_t max_length)</td></tr>
<tr class="memdesc:ac8605dea4710c2630ccdd21439e05999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a string, not to exceed a maximum.  <br /></td></tr>
<tr class="separator:ac8605dea4710c2630ccdd21439e05999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3aaf00fdc6fef366afb2a00062c97f" id="r_a1b3aaf00fdc6fef366afb2a00062c97f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b3aaf00fdc6fef366afb2a00062c97f">SplitStringFirst</a> (const std::string &amp;string, char delimiter, std::string *left, std::string *right)</td></tr>
<tr class="memdesc:a1b3aaf00fdc6fef366afb2a00062c97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into two parts at the first delimiter found.  <br /></td></tr>
<tr class="separator:a1b3aaf00fdc6fef366afb2a00062c97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d05de37d3f1a92ce36c3ce37842b7" id="r_abb5d05de37d3f1a92ce36c3ce37842b7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb5d05de37d3f1a92ce36c3ce37842b7">SplitString</a> (const std::string &amp;string, char delimiter)</td></tr>
<tr class="memdesc:abb5d05de37d3f1a92ce36c3ce37842b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into multiple parts on the given delimiter.  <br /></td></tr>
<tr class="separator:abb5d05de37d3f1a92ce36c3ce37842b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a7dee343e392e5bf1794e8136df7f9" id="r_a52a7dee343e392e5bf1794e8136df7f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52a7dee343e392e5bf1794e8136df7f9">AppendCommandLineArgument</a> (const std::wstring &amp;argument, std::wstring *command_line)</td></tr>
<tr class="memdesc:a52a7dee343e392e5bf1794e8136df7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for building escaped command lines.  <br /></td></tr>
<tr class="separator:a52a7dee343e392e5bf1794e8136df7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa5d9ac0de12366db0f5e6a300c3e70" id="r_affa5d9ac0de12366db0f5e6a300c3e70"><td class="memItemLeft" align="right" valign="top"><a id="affa5d9ac0de12366db0f5e6a300c3e70" name="affa5d9ac0de12366db0f5e6a300c3e70"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>ProgramCounterFromCONTEXT</b> (const CONTEXT *context)</td></tr>
<tr class="memdesc:affa5d9ac0de12366db0f5e6a300c3e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve program counter from <code>CONTEXT</code> structure for different architectures supported by Windows. <br /></td></tr>
<tr class="separator:affa5d9ac0de12366db0f5e6a300c3e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8340c24a2983e788d2a3ba90d1d4846" id="r_af8340c24a2983e788d2a3ba90d1d4846"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8340c24a2983e788d2a3ba90d1d4846">InitializeCriticalSectionWithDebugInfoIfPossible</a> (CRITICAL_SECTION *critical_section)</td></tr>
<tr class="memdesc:af8340c24a2983e788d2a3ba90d1d4846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>InitializeCritialSection()</code>, but attempts to allocate with a valid <code>.DebugInfo</code> field on versions of Windows where it's possible to do so.  <br /></td></tr>
<tr class="separator:af8340c24a2983e788d2a3ba90d1d4846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3746e63a20ecf254ab6ec0a2a3fc9072" id="r_a3746e63a20ecf254ab6ec0a2a3fc9072"><td class="memItemLeft" align="right" valign="top"><a id="a3746e63a20ecf254ab6ec0a2a3fc9072" name="a3746e63a20ecf254ab6ec0a2a3fc9072"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>CrashpadGetModuleInformation</b> (HANDLE process, HMODULE module, MODULEINFO *module_info, DWORD cb)</td></tr>
<tr class="memdesc:a3746e63a20ecf254ab6ec0a2a3fc9072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy function for <code>GetModuleInformation()</code>. <br /></td></tr>
<tr class="separator:a3746e63a20ecf254ab6ec0a2a3fc9072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae643b5c6bce4e11a0f51eb2f4d5fa1de" id="r_ae643b5c6bce4e11a0f51eb2f4d5fa1de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae643b5c6bce4e11a0f51eb2f4d5fa1de">HandleToInt</a> (HANDLE handle)</td></tr>
<tr class="memdesc:ae643b5c6bce4e11a0f51eb2f4d5fa1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code>HANDLE</code> to an <code>int</code>.  <br /></td></tr>
<tr class="separator:ae643b5c6bce4e11a0f51eb2f4d5fa1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83df06f1e4dc470676c1f86e93b6bc63" id="r_a83df06f1e4dc470676c1f86e93b6bc63"><td class="memItemLeft" align="right" valign="top">HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83df06f1e4dc470676c1f86e93b6bc63">IntToHandle</a> (int handle_int)</td></tr>
<tr class="memdesc:a83df06f1e4dc470676c1f86e93b6bc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <code>int</code> to an <code>HANDLE</code>.  <br /></td></tr>
<tr class="separator:a83df06f1e4dc470676c1f86e93b6bc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0358455342226c7906f6d8f3016a6374" id="r_a0358455342226c7906f6d8f3016a6374"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0358455342226c7906f6d8f3016a6374">IsThreadInLoaderLock</a> ()</td></tr>
<tr class="separator:a0358455342226c7906f6d8f3016a6374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f4414be804bdcd71f57053d7147eff" id="r_af5f4414be804bdcd71f57053d7147eff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5f4414be804bdcd71f57053d7147eff">GetModuleVersionAndType</a> (const base::FilePath &amp;path, <a class="el" href="structVS__FIXEDFILEINFO.html">VS_FIXEDFILEINFO</a> *vs_fixedfileinfo)</td></tr>
<tr class="memdesc:af5f4414be804bdcd71f57053d7147eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the type and version information from a given module (exe, dll, etc.)  <br /></td></tr>
<tr class="separator:af5f4414be804bdcd71f57053d7147eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98625fc4ae740c7acf83914cb9d2eea" id="r_af98625fc4ae740c7acf83914cb9d2eea"><td class="memItemLeft" align="right" valign="top"><a id="af98625fc4ae740c7acf83914cb9d2eea" name="af98625fc4ae740c7acf83914cb9d2eea"></a>
NTSTATUS&#160;</td><td class="memItemRight" valign="bottom"><b>NtClose</b> (HANDLE handle)</td></tr>
<tr class="separator:af98625fc4ae740c7acf83914cb9d2eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd167fde965614b528333f1d6af3a17" id="r_a4fd167fde965614b528333f1d6af3a17"><td class="memItemLeft" align="right" valign="top"><a id="a4fd167fde965614b528333f1d6af3a17" name="a4fd167fde965614b528333f1d6af3a17"></a>
NTSTATUS&#160;</td><td class="memItemRight" valign="bottom"><b>NtCreateThreadEx</b> (PHANDLE thread_handle, ACCESS_MASK desired_access, POBJECT_ATTRIBUTES object_attributes, HANDLE process_handle, PVOID start_routine, PVOID argument, ULONG create_flags, SIZE_T zero_bits, SIZE_T stack_size, SIZE_T maximum_stack_size, PVOID attribute_list)</td></tr>
<tr class="separator:a4fd167fde965614b528333f1d6af3a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1362e2105b0e5a1a96908dff0bf17f1b" id="r_a1362e2105b0e5a1a96908dff0bf17f1b"><td class="memItemLeft" align="right" valign="top"><a id="a1362e2105b0e5a1a96908dff0bf17f1b" name="a1362e2105b0e5a1a96908dff0bf17f1b"></a>
NTSTATUS&#160;</td><td class="memItemRight" valign="bottom"><b>NtQuerySystemInformation</b> (SYSTEM_INFORMATION_CLASS system_information_class, PVOID system_information, ULONG system_information_length, PULONG return_length)</td></tr>
<tr class="separator:a1362e2105b0e5a1a96908dff0bf17f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadf7c489cec5aaec6941ed84349a687" id="r_aaadf7c489cec5aaec6941ed84349a687"><td class="memItemLeft" align="right" valign="top"><a id="aaadf7c489cec5aaec6941ed84349a687" name="aaadf7c489cec5aaec6941ed84349a687"></a>
NTSTATUS&#160;</td><td class="memItemRight" valign="bottom"><b>NtQueryInformationThread</b> (HANDLE thread_handle, THREADINFOCLASS thread_information_class, PVOID thread_information, ULONG thread_information_length, PULONG return_length)</td></tr>
<tr class="separator:aaadf7c489cec5aaec6941ed84349a687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf0b422cad7e39f59f33ba59e1c4f63" id="r_a9bf0b422cad7e39f59f33ba59e1c4f63"><td class="memTemplParams" colspan="2"><a id="a9bf0b422cad7e39f59f33ba59e1c4f63" name="a9bf0b422cad7e39f59f33ba59e1c4f63"></a>
template&lt;class Traits&gt; </td></tr>
<tr class="memitem:a9bf0b422cad7e39f59f33ba59e1c4f63"><td class="memTemplItemLeft" align="right" valign="top">NTSTATUS&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NtOpenThread</b> (PHANDLE thread_handle, ACCESS_MASK desired_access, POBJECT_ATTRIBUTES object_attributes, const <a class="el" href="structcrashpad_1_1process__types_1_1CLIENT__ID.html">process_types::CLIENT_ID</a>&lt; Traits &gt; *client_id)</td></tr>
<tr class="separator:a9bf0b422cad7e39f59f33ba59e1c4f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ddfe7ead9fb78e8dc69e3aef201591" id="r_a62ddfe7ead9fb78e8dc69e3aef201591"><td class="memItemLeft" align="right" valign="top"><a id="a62ddfe7ead9fb78e8dc69e3aef201591" name="a62ddfe7ead9fb78e8dc69e3aef201591"></a>
NTSTATUS&#160;</td><td class="memItemRight" valign="bottom"><b>NtQueryObject</b> (HANDLE handle, OBJECT_INFORMATION_CLASS object_information_class, void *object_information, ULONG object_information_length, ULONG *return_length)</td></tr>
<tr class="separator:a62ddfe7ead9fb78e8dc69e3aef201591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7f5dacb7838eff13fc227543946514" id="r_a0a7f5dacb7838eff13fc227543946514"><td class="memItemLeft" align="right" valign="top"><a id="a0a7f5dacb7838eff13fc227543946514" name="a0a7f5dacb7838eff13fc227543946514"></a>
NTSTATUS&#160;</td><td class="memItemRight" valign="bottom"><b>NtSuspendProcess</b> (HANDLE handle)</td></tr>
<tr class="separator:a0a7f5dacb7838eff13fc227543946514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4c03e99b85dc3f8bc3c9a0d13cea67" id="r_a4b4c03e99b85dc3f8bc3c9a0d13cea67"><td class="memItemLeft" align="right" valign="top"><a id="a4b4c03e99b85dc3f8bc3c9a0d13cea67" name="a4b4c03e99b85dc3f8bc3c9a0d13cea67"></a>
NTSTATUS&#160;</td><td class="memItemRight" valign="bottom"><b>NtResumeProcess</b> (HANDLE handle)</td></tr>
<tr class="separator:a4b4c03e99b85dc3f8bc3c9a0d13cea67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9a999e6e353ff4fc56466621a8ff0e" id="r_adc9a999e6e353ff4fc56466621a8ff0e"><td class="memItemLeft" align="right" valign="top"><a id="adc9a999e6e353ff4fc56466621a8ff0e" name="adc9a999e6e353ff4fc56466621a8ff0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RtlGetUnloadEventTraceEx</b> (ULONG **element_size, ULONG **element_count, void **event_trace)</td></tr>
<tr class="separator:adc9a999e6e353ff4fc56466621a8ff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbe51e96d3012cb4751d48d0c920d6c" id="r_abcbe51e96d3012cb4751d48d0c920d6c"><td class="memItemLeft" align="right" valign="top"><a id="abcbe51e96d3012cb4751d48d0c920d6c" name="abcbe51e96d3012cb4751d48d0c920d6c"></a>
template NTSTATUS&#160;</td><td class="memItemRight" valign="bottom"><b>NtOpenThread&lt; process_types::internal::Traits32 &gt;</b> (PHANDLE thread_handle, ACCESS_MASK desired_access, POBJECT_ATTRIBUTES object_attributes, const <a class="el" href="structcrashpad_1_1process__types_1_1CLIENT__ID.html">process_types::CLIENT_ID</a>&lt; <a class="el" href="structcrashpad_1_1process__types_1_1internal_1_1Traits32.html">process_types::internal::Traits32</a> &gt; *client_id)</td></tr>
<tr class="separator:abcbe51e96d3012cb4751d48d0c920d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78cb91133d0fd98a7895856e36eaf74" id="r_ac78cb91133d0fd98a7895856e36eaf74"><td class="memItemLeft" align="right" valign="top"><a id="ac78cb91133d0fd98a7895856e36eaf74" name="ac78cb91133d0fd98a7895856e36eaf74"></a>
template NTSTATUS&#160;</td><td class="memItemRight" valign="bottom"><b>NtOpenThread&lt; process_types::internal::Traits64 &gt;</b> (PHANDLE thread_handle, ACCESS_MASK desired_access, POBJECT_ATTRIBUTES object_attributes, const <a class="el" href="structcrashpad_1_1process__types_1_1CLIENT__ID.html">process_types::CLIENT_ID</a>&lt; <a class="el" href="structcrashpad_1_1process__types_1_1internal_1_1Traits64.html">process_types::internal::Traits64</a> &gt; *client_id)</td></tr>
<tr class="separator:ac78cb91133d0fd98a7895856e36eaf74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04af5fe26b32e7a7bdd363017251fe00" id="r_a04af5fe26b32e7a7bdd363017251fe00"><td class="memTemplParams" colspan="2"><a id="a04af5fe26b32e7a7bdd363017251fe00" name="a04af5fe26b32e7a7bdd363017251fe00"></a>
template&lt;class Traits&gt; </td></tr>
<tr class="memitem:a04af5fe26b32e7a7bdd363017251fe00"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetProcessBasicInformation</b> (HANDLE process, bool is_wow64, <a class="el" href="classcrashpad_1_1ProcessInfo.html">ProcessInfo</a> *process_info, <a class="el" href="#ac5872ff07ebe5bda9f532e8d3d752d77">WinVMAddress</a> *peb_address, <a class="el" href="#aa24b456d735f72df6141fd110542b24f">WinVMSize</a> *peb_size)</td></tr>
<tr class="separator:a04af5fe26b32e7a7bdd363017251fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e1c8286ac56df129481b4d26b1aa9d" id="r_ab0e1c8286ac56df129481b4d26b1aa9d"><td class="memTemplParams" colspan="2"><a id="ab0e1c8286ac56df129481b4d26b1aa9d" name="ab0e1c8286ac56df129481b4d26b1aa9d"></a>
template&lt;class Traits&gt; </td></tr>
<tr class="memitem:ab0e1c8286ac56df129481b4d26b1aa9d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ReadProcessData</b> (HANDLE process, <a class="el" href="#ac5872ff07ebe5bda9f532e8d3d752d77">WinVMAddress</a> peb_address_vmaddr, <a class="el" href="classcrashpad_1_1ProcessInfo.html">ProcessInfo</a> *process_info)</td></tr>
<tr class="separator:ab0e1c8286ac56df129481b4d26b1aa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ff5b9a1ac8271ebf0977880ec95ac3" id="r_a44ff5b9a1ac8271ebf0977880ec95ac3"><td class="memItemLeft" align="right" valign="top"><a id="a44ff5b9a1ac8271ebf0977880ec95ac3" name="a44ff5b9a1ac8271ebf0977880ec95ac3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadMemoryInfo</b> (HANDLE process, bool is_64_bit, <a class="el" href="classcrashpad_1_1ProcessInfo.html">ProcessInfo</a> *process_info)</td></tr>
<tr class="separator:a44ff5b9a1ac8271ebf0977880ec95ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794c1a44de599deb3e261eab0bd6c03b" id="r_a794c1a44de599deb3e261eab0bd6c03b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcrashpad_1_1CheckedRange.html">CheckedRange</a>&lt; <a class="el" href="#ac5872ff07ebe5bda9f532e8d3d752d77">WinVMAddress</a>, <a class="el" href="#aa24b456d735f72df6141fd110542b24f">WinVMSize</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a794c1a44de599deb3e261eab0bd6c03b">GetReadableRangesOfMemoryMap</a> (const <a class="el" href="classcrashpad_1_1CheckedRange.html">CheckedRange</a>&lt; <a class="el" href="#ac5872ff07ebe5bda9f532e8d3d752d77">WinVMAddress</a>, <a class="el" href="#aa24b456d735f72df6141fd110542b24f">WinVMSize</a> &gt; &amp;range, const <a class="el" href="classcrashpad_1_1ProcessInfo.html#a8b50ad8796b1e43eed798c6c717bcbdf">ProcessInfo::MemoryBasicInformation64Vector</a> &amp;memory_info)</td></tr>
<tr class="memdesc:a794c1a44de599deb3e261eab0bd6c03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a memory map of a process, and a range to be read from the target process, returns a vector of ranges, representing the readable portions of the original range.  <br /></td></tr>
<tr class="separator:a794c1a44de599deb3e261eab0bd6c03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d993c28de1644014bf81bac75817757" id="r_a0d993c28de1644014bf81bac75817757"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d993c28de1644014bf81bac75817757">SendToCrashHandlerServer</a> (const std::wstring &amp;pipe_name, const <a class="el" href="structcrashpad_1_1ClientToServerMessage.html">ClientToServerMessage</a> &amp;message, <a class="el" href="unioncrashpad_1_1ServerToClientMessage.html">ServerToClientMessage</a> *response)</td></tr>
<tr class="memdesc:a0d993c28de1644014bf81bac75817757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect over the given <em class="arg">pipe_name</em>, passing <em class="arg">message</em> to the server, storing the server's reply into <em class="arg">response</em>.  <br /></td></tr>
<tr class="separator:a0d993c28de1644014bf81bac75817757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb7596acd0c7d75d0608ffafc6028e8" id="r_a1bb7596acd0c7d75d0608ffafc6028e8"><td class="memItemLeft" align="right" valign="top">HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bb7596acd0c7d75d0608ffafc6028e8">CreateNamedPipeInstance</a> (const std::wstring &amp;pipe_name, bool first_instance)</td></tr>
<tr class="memdesc:a1bb7596acd0c7d75d0608ffafc6028e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps CreateNamedPipe() to create a single named pipe instance.  <br /></td></tr>
<tr class="separator:a1bb7596acd0c7d75d0608ffafc6028e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dec2ab03620dcacc0b0d60ae0845f3c" id="r_a8dec2ab03620dcacc0b0d60ae0845f3c"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dec2ab03620dcacc0b0d60ae0845f3c">GetFallbackSecurityDescriptorForNamedPipeInstance</a> (size_t *size)</td></tr>
<tr class="memdesc:a8dec2ab03620dcacc0b0d60ae0845f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>SECURITY_DESCRIPTOR</code> blob that will be used for creating the connection pipe in <a class="el" href="#a1bb7596acd0c7d75d0608ffafc6028e8" title="Wraps CreateNamedPipe() to create a single named pipe instance.">CreateNamedPipeInstance()</a> if the full descriptor can't be created.  <br /></td></tr>
<tr class="separator:a8dec2ab03620dcacc0b0d60ae0845f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22242667ee950fe12a99b298dda5e08" id="r_af22242667ee950fe12a99b298dda5e08"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af22242667ee950fe12a99b298dda5e08">GetSecurityDescriptorForNamedPipeInstance</a> (size_t *size)</td></tr>
<tr class="memdesc:af22242667ee950fe12a99b298dda5e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>SECURITY_DESCRIPTOR</code> blob that will be used for creating the connection pipe in <a class="el" href="#a1bb7596acd0c7d75d0608ffafc6028e8" title="Wraps CreateNamedPipe() to create a single named pipe instance.">CreateNamedPipeInstance()</a>.  <br /></td></tr>
<tr class="separator:af22242667ee950fe12a99b298dda5e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8efd0f50febdf3c8461fb93de8191f7" id="r_ad8efd0f50febdf3c8461fb93de8191f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8efd0f50febdf3c8461fb93de8191f7">SafeTerminateProcess</a> (HANDLE process, UINT exit_code)</td></tr>
<tr class="memdesc:ad8efd0f50febdf3c8461fb93de8191f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>TerminateProcess()</code>.  <br /></td></tr>
<tr class="separator:ad8efd0f50febdf3c8461fb93de8191f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aec89d58359f33bb2ba3671feea0c15f4" id="r_aec89d58359f33bb2ba3671feea0c15f4"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec89d58359f33bb2ba3671feea0c15f4">LaunchDataAlloc</a> (launch_data_type_t type)</td></tr>
<tr class="memdesc:aec89d58359f33bb2ba3671feea0c15f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:aec89d58359f33bb2ba3671feea0c15f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765503fd97e9e3d622d3b30bff543fb9" id="r_a765503fd97e9e3d622d3b30bff543fb9"><td class="memItemLeft" align="right" valign="top">launch_data_type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a765503fd97e9e3d622d3b30bff543fb9">LaunchDataGetType</a> (const launch_data_t data)</td></tr>
<tr class="memdesc:a765503fd97e9e3d622d3b30bff543fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a765503fd97e9e3d622d3b30bff543fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6075a91ef08754a4f6f1d1cc4f4243d2" id="r_a6075a91ef08754a4f6f1d1cc4f4243d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6075a91ef08754a4f6f1d1cc4f4243d2">LaunchDataFree</a> (launch_data_t data)</td></tr>
<tr class="memdesc:a6075a91ef08754a4f6f1d1cc4f4243d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a6075a91ef08754a4f6f1d1cc4f4243d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5637f13db21865305a5d09b123647ee0" id="r_a5637f13db21865305a5d09b123647ee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5637f13db21865305a5d09b123647ee0">LaunchDataDictInsert</a> (launch_data_t dict, const launch_data_t value, const char *key)</td></tr>
<tr class="memdesc:a5637f13db21865305a5d09b123647ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a5637f13db21865305a5d09b123647ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4549b38faef80da81a53b88b1a27ac" id="r_a7d4549b38faef80da81a53b88b1a27ac"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d4549b38faef80da81a53b88b1a27ac">LaunchDataDictLookup</a> (const launch_data_t dict, const char *key)</td></tr>
<tr class="memdesc:a7d4549b38faef80da81a53b88b1a27ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a7d4549b38faef80da81a53b88b1a27ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb99d12b989d048f972d843a2aea013" id="r_aedb99d12b989d048f972d843a2aea013"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedb99d12b989d048f972d843a2aea013">LaunchDataDictGetCount</a> (launch_data_t dict)</td></tr>
<tr class="memdesc:aedb99d12b989d048f972d843a2aea013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:aedb99d12b989d048f972d843a2aea013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075be3843e4294e446c40022ba6661c4" id="r_a075be3843e4294e446c40022ba6661c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075be3843e4294e446c40022ba6661c4">LaunchDataArraySetIndex</a> (launch_data_t array, const launch_data_t value, size_t index)</td></tr>
<tr class="memdesc:a075be3843e4294e446c40022ba6661c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a075be3843e4294e446c40022ba6661c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e5304477aab0ad1d165869557eb3b5" id="r_a46e5304477aab0ad1d165869557eb3b5"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46e5304477aab0ad1d165869557eb3b5">LaunchDataArrayGetIndex</a> (launch_data_t array, size_t index)</td></tr>
<tr class="memdesc:a46e5304477aab0ad1d165869557eb3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a46e5304477aab0ad1d165869557eb3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb060347d9343e720856380234cd6ff" id="r_abeb060347d9343e720856380234cd6ff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeb060347d9343e720856380234cd6ff">LaunchDataArrayGetCount</a> (launch_data_t array)</td></tr>
<tr class="memdesc:abeb060347d9343e720856380234cd6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:abeb060347d9343e720856380234cd6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4bfcaae95ef3a81e3ec2d27f059bab" id="r_a7b4bfcaae95ef3a81e3ec2d27f059bab"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b4bfcaae95ef3a81e3ec2d27f059bab">LaunchDataNewInteger</a> (long long integer)</td></tr>
<tr class="memdesc:a7b4bfcaae95ef3a81e3ec2d27f059bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a7b4bfcaae95ef3a81e3ec2d27f059bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e679e954d2d8ca88ace03ccab5c4df" id="r_a19e679e954d2d8ca88ace03ccab5c4df"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e679e954d2d8ca88ace03ccab5c4df">LaunchDataNewBool</a> (bool boolean)</td></tr>
<tr class="memdesc:a19e679e954d2d8ca88ace03ccab5c4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a19e679e954d2d8ca88ace03ccab5c4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78698056108819fe4bd268cc55801c3" id="r_aa78698056108819fe4bd268cc55801c3"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa78698056108819fe4bd268cc55801c3">LaunchDataNewReal</a> (double real)</td></tr>
<tr class="memdesc:aa78698056108819fe4bd268cc55801c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:aa78698056108819fe4bd268cc55801c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae48002caa906acb164114bc290b048" id="r_a7ae48002caa906acb164114bc290b048"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ae48002caa906acb164114bc290b048">LaunchDataNewString</a> (const char *string)</td></tr>
<tr class="memdesc:a7ae48002caa906acb164114bc290b048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a7ae48002caa906acb164114bc290b048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af22dade75539fd9e5032acf799c945" id="r_a5af22dade75539fd9e5032acf799c945"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af22dade75539fd9e5032acf799c945">LaunchDataNewOpaque</a> (const void *opaque, size_t size)</td></tr>
<tr class="memdesc:a5af22dade75539fd9e5032acf799c945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a5af22dade75539fd9e5032acf799c945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54549da20f78530f300712625fc0ba5a" id="r_a54549da20f78530f300712625fc0ba5a"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54549da20f78530f300712625fc0ba5a">LaunchDataGetInteger</a> (const launch_data_t data)</td></tr>
<tr class="memdesc:a54549da20f78530f300712625fc0ba5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a54549da20f78530f300712625fc0ba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd262daa89e57ffd897e4b583d44d44" id="r_a6fd262daa89e57ffd897e4b583d44d44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fd262daa89e57ffd897e4b583d44d44">LaunchDataGetBool</a> (const launch_data_t data)</td></tr>
<tr class="memdesc:a6fd262daa89e57ffd897e4b583d44d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a6fd262daa89e57ffd897e4b583d44d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21114f1a9f28bfb065033f569d466a09" id="r_a21114f1a9f28bfb065033f569d466a09"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21114f1a9f28bfb065033f569d466a09">LaunchDataGetReal</a> (const launch_data_t data)</td></tr>
<tr class="memdesc:a21114f1a9f28bfb065033f569d466a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a21114f1a9f28bfb065033f569d466a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f39dab15fdc32b5e2b2264aeba2480" id="r_a00f39dab15fdc32b5e2b2264aeba2480"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00f39dab15fdc32b5e2b2264aeba2480">LaunchDataGetString</a> (const launch_data_t data)</td></tr>
<tr class="memdesc:a00f39dab15fdc32b5e2b2264aeba2480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a00f39dab15fdc32b5e2b2264aeba2480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f99732a5ea3f2cbc2435e3b3a5ef1ba" id="r_a2f99732a5ea3f2cbc2435e3b3a5ef1ba"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f99732a5ea3f2cbc2435e3b3a5ef1ba">LaunchDataGetOpaque</a> (const launch_data_t data)</td></tr>
<tr class="memdesc:a2f99732a5ea3f2cbc2435e3b3a5ef1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a2f99732a5ea3f2cbc2435e3b3a5ef1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed0f2e24befe2e6faa94445bb03e054" id="r_a6ed0f2e24befe2e6faa94445bb03e054"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ed0f2e24befe2e6faa94445bb03e054">LaunchDataGetOpaqueSize</a> (const launch_data_t data)</td></tr>
<tr class="memdesc:a6ed0f2e24befe2e6faa94445bb03e054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a6ed0f2e24befe2e6faa94445bb03e054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5637cdc78caedaaadb2c0e47857ccf78" id="r_a5637cdc78caedaaadb2c0e47857ccf78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5637cdc78caedaaadb2c0e47857ccf78">LaunchDataGetErrno</a> (const launch_data_t data)</td></tr>
<tr class="memdesc:a5637cdc78caedaaadb2c0e47857ccf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:a5637cdc78caedaaadb2c0e47857ccf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae541f07925a67de751502b903af919b4" id="r_ae541f07925a67de751502b903af919b4"><td class="memItemLeft" align="right" valign="top">launch_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae541f07925a67de751502b903af919b4">LaunchMsg</a> (const launch_data_t data)</td></tr>
<tr class="memdesc:ae541f07925a67de751502b903af919b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the <code>&lt;launch.h&gt;</code> function of the same name.  <br /></td></tr>
<tr class="separator:ae541f07925a67de751502b903af919b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a32029d4f41770a8fafb8efdc896e5e4d" id="r_a32029d4f41770a8fafb8efdc896e5e4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32029d4f41770a8fafb8efdc896e5e4d">StringToNumber</a> (const std::string &amp;string, int *number)</td></tr>
<tr class="memdesc:a32029d4f41770a8fafb8efdc896e5e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number.  <br /></td></tr>
<tr class="separator:a32029d4f41770a8fafb8efdc896e5e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8d160b70c0f608add225d2be928f7c" id="r_abc8d160b70c0f608add225d2be928f7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc8d160b70c0f608add225d2be928f7c">StringToNumber</a> (const std::string &amp;string, unsigned int *number)</td></tr>
<tr class="memdesc:abc8d160b70c0f608add225d2be928f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number.  <br /></td></tr>
<tr class="separator:abc8d160b70c0f608add225d2be928f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6879fca357a65d0ea93e06a48399a36a" id="r_a6879fca357a65d0ea93e06a48399a36a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6879fca357a65d0ea93e06a48399a36a">StringToNumber</a> (const std::string &amp;string, long *number)</td></tr>
<tr class="memdesc:a6879fca357a65d0ea93e06a48399a36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number.  <br /></td></tr>
<tr class="separator:a6879fca357a65d0ea93e06a48399a36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91f5fe164e391c950c3e3a456f5f008" id="r_ad91f5fe164e391c950c3e3a456f5f008"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad91f5fe164e391c950c3e3a456f5f008">StringToNumber</a> (const std::string &amp;string, unsigned long *number)</td></tr>
<tr class="memdesc:ad91f5fe164e391c950c3e3a456f5f008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number.  <br /></td></tr>
<tr class="separator:ad91f5fe164e391c950c3e3a456f5f008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0803f07288b43b385a4cf8f44d9f737c" id="r_a0803f07288b43b385a4cf8f44d9f737c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0803f07288b43b385a4cf8f44d9f737c">StringToNumber</a> (const std::string &amp;string, long long *number)</td></tr>
<tr class="memdesc:a0803f07288b43b385a4cf8f44d9f737c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number.  <br /></td></tr>
<tr class="separator:a0803f07288b43b385a4cf8f44d9f737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca97fc8e5a3b10053b624bf9b8ac65c4" id="r_aca97fc8e5a3b10053b624bf9b8ac65c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca97fc8e5a3b10053b624bf9b8ac65c4">StringToNumber</a> (const std::string &amp;string, unsigned long long *number)</td></tr>
<tr class="memdesc:aca97fc8e5a3b10053b624bf9b8ac65c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number.  <br /></td></tr>
<tr class="separator:aca97fc8e5a3b10053b624bf9b8ac65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a77b69be523b4c70469e1d48e6c0bd3bc" id="r_a77b69be523b4c70469e1d48e6c0bd3bc"><td class="memItemLeft" align="right" valign="top"><a id="a77b69be523b4c70469e1d48e6c0bd3bc" name="a77b69be523b4c70469e1d48e6c0bd3bc"></a>
<a class="el" href="structcrashpad_1_1CrashpadInfo.html">CrashpadInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_crashpad_info</b></td></tr>
<tr class="separator:a77b69be523b4c70469e1d48e6c0bd3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08c753dbd9cf58c74e8d4d2380f44f1" id="r_ab08c753dbd9cf58c74e8d4d2380f44f1"><td class="memItemLeft" align="right" valign="top"><a id="ab08c753dbd9cf58c74e8d4d2380f44f1" name="ab08c753dbd9cf58c74e8d4d2380f44f1"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>CRASHPAD_NOTE_REFERENCE</b></td></tr>
<tr class="separator:ab08c753dbd9cf58c74e8d4d2380f44f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a1ba1ae6a675fbe7cb244f95260530" id="r_ab3a1ba1ae6a675fbe7cb244f95260530"><td class="memItemLeft" align="right" valign="top"><a id="ab3a1ba1ae6a675fbe7cb244f95260530" name="ab3a1ba1ae6a675fbe7cb244f95260530"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>g_extra_memory_pointer</b></td></tr>
<tr class="separator:ab3a1ba1ae6a675fbe7cb244f95260530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314c4255fd5f08cb08696f33807cca8a" id="r_a314c4255fd5f08cb08696f33807cca8a"><td class="memItemLeft" align="right" valign="top"><a id="a314c4255fd5f08cb08696f33807cca8a" name="a314c4255fd5f08cb08696f33807cca8a"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>g_extra_memory_not_saved</b></td></tr>
<tr class="separator:a314c4255fd5f08cb08696f33807cca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab297f205afaeb8ba801c36c32607fae1" id="r_ab297f205afaeb8ba801c36c32607fae1"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab297f205afaeb8ba801c36c32607fae1">kMinidumpAMD64XSaveOffset</a> = 0x550</td></tr>
<tr class="memdesc:ab297f205afaeb8ba801c36c32607fae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of first xsave feature in the full extended context.  <br /></td></tr>
<tr class="separator:ab297f205afaeb8ba801c36c32607fae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e976d5cb60cef3f5412fa9e55cb915" id="r_ad1e976d5cb60cef3f5412fa9e55cb915"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1e976d5cb60cef3f5412fa9e55cb915">kXSaveAreaFirstOffset</a> = 0x240</td></tr>
<tr class="memdesc:ad1e976d5cb60cef3f5412fa9e55cb915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of first xsave feature within the extended context area.  <br /></td></tr>
<tr class="separator:ad1e976d5cb60cef3f5412fa9e55cb915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38551501b8f5006f1f4ac602b87e2724" id="r_a38551501b8f5006f1f4ac602b87e2724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcrashpad_1_1TestCrashpadInfo.html">TestCrashpadInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38551501b8f5006f1f4ac602b87e2724">g_test_crashpad_info</a></td></tr>
<tr class="separator:a38551501b8f5006f1f4ac602b87e2724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfaf3e08a4fd8619dfd48e9156d22b8" id="r_a4dfaf3e08a4fd8619dfd48e9156d22b8"><td class="memItemLeft" align="right" valign="top"><a id="a4dfaf3e08a4fd8619dfd48e9156d22b8" name="a4dfaf3e08a4fd8619dfd48e9156d22b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GatherIndirectlyReferencedMemory</b></td></tr>
<tr class="separator:a4dfaf3e08a4fd8619dfd48e9156d22b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699e7614ee001ea71ae4416809ce9c80" id="r_a699e7614ee001ea71ae4416809ce9c80"><td class="memItemLeft" align="right" valign="top"><a id="a699e7614ee001ea71ae4416809ce9c80" name="a699e7614ee001ea71ae4416809ce9c80"></a>
gather_indirectly_referenced_memory&#160;</td><td class="memItemRight" valign="bottom"><b>UserDataMinidumpStreamHead</b></td></tr>
<tr class="separator:a699e7614ee001ea71ae4416809ce9c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83421817896ef24623f0f1cf10268843" id="r_a83421817896ef24623f0f1cf10268843"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83421817896ef24623f0f1cf10268843">kMaxNumberOfAnnotations</a> = 400</td></tr>
<tr class="memdesc:a83421817896ef24623f0f1cf10268843"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of crashpad::Annotations that will be read from a client process.  <br /></td></tr>
<tr class="separator:a83421817896ef24623f0f1cf10268843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add54baa0f53825b93f3aab2fcafce367" id="r_add54baa0f53825b93f3aab2fcafce367"><td class="memItemLeft" align="right" valign="top"><a id="add54baa0f53825b93f3aab2fcafce367" name="add54baa0f53825b93f3aab2fcafce367"></a>
const <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kInvalidFileHandle</b> = -1</td></tr>
<tr class="memdesc:add54baa0f53825b93f3aab2fcafce367"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value that can never be a valid <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>. <br /></td></tr>
<tr class="separator:add54baa0f53825b93f3aab2fcafce367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253712a6760b4b8a54dbcc8943692731" id="r_a253712a6760b4b8a54dbcc8943692731"><td class="memItemLeft" align="right" valign="top">constexpr mach_port_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a253712a6760b4b8a54dbcc8943692731">kMachPortNull</a> = MACH_PORT_NULL</td></tr>
<tr class="memdesc:a253712a6760b4b8a54dbcc8943692731"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>MACH_PORT_NULL</code> with the correct type for a Mach port, <code>mach_port_t</code>.  <br /></td></tr>
<tr class="separator:a253712a6760b4b8a54dbcc8943692731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0999f3c072971348f71f196848fcde12" id="r_a0999f3c072971348f71f196848fcde12"><td class="memItemLeft" align="right" valign="top">constexpr exception_behavior_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0999f3c072971348f71f196848fcde12">kMachExceptionCodes</a> = MACH_EXCEPTION_CODES</td></tr>
<tr class="memdesc:a0999f3c072971348f71f196848fcde12"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>MACH_EXCEPTION_CODES</code> with the correct type for a Mach exception behavior, <code>exception_behavior_t</code>.  <br /></td></tr>
<tr class="separator:a0999f3c072971348f71f196848fcde12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0a6740778f04fe2d190dbcd080d55b" id="r_a9e0a6740778f04fe2d190dbcd080d55b"><td class="memItemLeft" align="right" valign="top"><a id="a9e0a6740778f04fe2d190dbcd080d55b" name="a9e0a6740778f04fe2d190dbcd080d55b"></a>
constexpr exception_type_t&#160;</td><td class="memItemRight" valign="bottom"><b>kMachExceptionSimulated</b> = 'CPsx'</td></tr>
<tr class="memdesc:a9e0a6740778f04fe2d190dbcd080d55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception type to use for simulated exceptions. <br /></td></tr>
<tr class="separator:a9e0a6740778f04fe2d190dbcd080d55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9ddc514849a27867255058d48ca605" id="r_a5b9ddc514849a27867255058d48ca605"><td class="memItemLeft" align="right" valign="top"><a id="a5b9ddc514849a27867255058d48ca605" name="a5b9ddc514849a27867255058d48ca605"></a>
constexpr exception_type_t&#160;</td><td class="memItemRight" valign="bottom"><b>kMachExceptionFromNSException</b> = 'CPnx'</td></tr>
<tr class="memdesc:a5b9ddc514849a27867255058d48ca605"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception type to use for uncaught NSExceptions. <br /></td></tr>
<tr class="separator:a5b9ddc514849a27867255058d48ca605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c87c3ca622c253c84e9b557a0abe034" id="r_a2c87c3ca622c253c84e9b557a0abe034"><td class="memItemLeft" align="right" valign="top">constexpr mach_msg_option_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c87c3ca622c253c84e9b557a0abe034">kMachMessageReceiveAuditTrailer</a></td></tr>
<tr class="memdesc:a2c87c3ca622c253c84e9b557a0abe034"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Mach message option specifying that an audit trailer should be delivered during a receive operation.  <br /></td></tr>
<tr class="separator:a2c87c3ca622c253c84e9b557a0abe034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a2e7edbbf8d61af6b3cea8a4a552ba" id="r_a24a2e7edbbf8d61af6b3cea8a4a552ba"><td class="memItemLeft" align="right" valign="top"><a id="a24a2e7edbbf8d61af6b3cea8a4a552ba" name="a24a2e7edbbf8d61af6b3cea8a4a552ba"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>kNanosecondsPerSecond</b> = static_cast&lt;uint64_t&gt;(1E9)</td></tr>
<tr class="separator:a24a2e7edbbf8d61af6b3cea8a4a552ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c879b0fe1012a256a0cc00d953f8aac" id="r_a6c879b0fe1012a256a0cc00d953f8aac"><td class="memItemLeft" align="right" valign="top"><a id="a6c879b0fe1012a256a0cc00d953f8aac" name="a6c879b0fe1012a256a0cc00d953f8aac"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>kContentType</b> [] = &quot;Content-Type&quot;</td></tr>
<tr class="memdesc:a6c879b0fe1012a256a0cc00d953f8aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header name <code>"Content-Type"</code>. <br /></td></tr>
<tr class="separator:a6c879b0fe1012a256a0cc00d953f8aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5e0afd19a628a323c9a5529c66e623" id="r_a4c5e0afd19a628a323c9a5529c66e623"><td class="memItemLeft" align="right" valign="top"><a id="a4c5e0afd19a628a323c9a5529c66e623" name="a4c5e0afd19a628a323c9a5529c66e623"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>kContentLength</b> [] = &quot;Content-Length&quot;</td></tr>
<tr class="memdesc:a4c5e0afd19a628a323c9a5529c66e623"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header name <code>"Content-Length"</code>. <br /></td></tr>
<tr class="separator:a4c5e0afd19a628a323c9a5529c66e623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f39d4abd7b533a4a89585d65cc22fb8" id="r_a5f39d4abd7b533a4a89585d65cc22fb8"><td class="memItemLeft" align="right" valign="top"><a id="a5f39d4abd7b533a4a89585d65cc22fb8" name="a5f39d4abd7b533a4a89585d65cc22fb8"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>kContentEncoding</b> [] = &quot;Content-Encoding&quot;</td></tr>
<tr class="memdesc:a5f39d4abd7b533a4a89585d65cc22fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header name <code>"Content-Encoding"</code>. <br /></td></tr>
<tr class="separator:a5f39d4abd7b533a4a89585d65cc22fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0afa0e9f45cf18efd764d2dc034cb3" id="r_acb0afa0e9f45cf18efd764d2dc034cb3"><td class="memItemLeft" align="right" valign="top"><a id="acb0afa0e9f45cf18efd764d2dc034cb3" name="acb0afa0e9f45cf18efd764d2dc034cb3"></a>
constexpr <a class="el" href="#ad772b944721fbe2c2cc4df22705bb6ec">ProcessID</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kInvalidProcessID</b> = -1</td></tr>
<tr class="separator:acb0afa0e9f45cf18efd764d2dc034cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a22c828ade5104707eb2b9e3d4141778b" name="a22c828ade5104707eb2b9e3d4141778b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c828ade5104707eb2b9e3d4141778b">&#9670;&#160;</a></span>AlignedVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t Alignment = alignof(T)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a22c828ade5104707eb2b9e3d4141778b">crashpad::AlignedVector</a> = std::vector&lt;T, <a class="el" href="structcrashpad_1_1AlignedAllocator.html">AlignedAllocator</a>&lt;T, Alignment&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code>std::vector</code> using <a class="el" href="structcrashpad_1_1AlignedAllocator.html" title="A standard allocator that aligns its allocations as requested, suitable for use as an allocator in st...">AlignedAllocator</a>. </p>
<p>This is similar to <code>std::vector&lt;T&gt;</code>, with the addition of an alignment guarantee. <em class="arg">Alignment</em> must be a power of 2. If <em class="arg">Alignment</em> is not specified, the default alignment for type <em class="arg">T</em> is used. </p>

</div>
</div>
<a id="a39b6bbc20b0887c35b955e2898b968fd" name="a39b6bbc20b0887c35b955e2898b968fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b6bbc20b0887c35b955e2898b968fd">&#9670;&#160;</a></span>CheckedLinuxAddressRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a39b6bbc20b0887c35b955e2898b968fd">crashpad::CheckedLinuxAddressRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classcrashpad_1_1internal_1_1CheckedAddressRangeGeneric.html">internal::CheckedAddressRangeGeneric&lt;LinuxVMAddress, LinuxVMSize&gt;</a></div>
<div class="ttc" id="aclasscrashpad_1_1internal_1_1CheckedAddressRangeGeneric_html"><div class="ttname"><a href="classcrashpad_1_1internal_1_1CheckedAddressRangeGeneric.html">crashpad::internal::CheckedAddressRangeGeneric</a></div><div class="ttdoc">Ensures that a range, composed of a base and a size, does not overflow the pointer type of the proces...</div><div class="ttdef"><b>Definition</b> checked_address_range.h:39</div></div>
</div><!-- fragment -->
<p>Ensures that a range, composed of a base and a size, does not overflow the pointer type of the process it describes a range in. </p>
<p>This class checks bases of type <a class="el" href="#ac349d7ee7fdd6c312073c0e9d9af3db6" title="Type used to represent an address in a process, potentially across bitness.">LinuxVMAddress</a> and sizes of type <a class="el" href="#af03f17b393b7a4f00279d2c37550b441" title="Type used to represent the size of a memory range (with a LinuxVMAddress), potentially across bitness...">LinuxVMSize</a> against a process whose pointer type is either 32 or 64 bits wide.</p>
<p>Aside from varying the overall range on the basis of a process’ pointer type width, this class functions very similarly to <a class="el" href="classcrashpad_1_1CheckedRange.html" title="Ensures that a range, composed of a base and size, does not overflow its data type.">CheckedRange</a>. </p>

</div>
</div>
<a id="a9746092c7c995c911caf433b7f1abd15" name="a9746092c7c995c911caf433b7f1abd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9746092c7c995c911caf433b7f1abd15">&#9670;&#160;</a></span>CheckedMachAddressRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9746092c7c995c911caf433b7f1abd15">crashpad::CheckedMachAddressRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classcrashpad_1_1internal_1_1CheckedAddressRangeGeneric.html">internal::CheckedAddressRangeGeneric&lt;mach_vm_address_t, mach_vm_size_t&gt;</a></div>
</div><!-- fragment -->
<p>Ensures that a range, composed of a base and a size, does not overflow the pointer type of the process it describes a range in. </p>
<p>This class checks bases of type <code>mach_vm_address_t</code> and sizes of type <code>mach_vm_address_t</code> against a process whose pointer type is either 32 or 64 bits wide.</p>
<p>Aside from varying the overall range on the basis of a process’ pointer type width, this class functions very similarly to <a class="el" href="classcrashpad_1_1CheckedRange.html" title="Ensures that a range, composed of a base and size, does not overflow its data type.">CheckedRange</a>. </p>

</div>
</div>
<a id="a20680b609955bd1ed0f60f2c7ff46678" name="a20680b609955bd1ed0f60f2c7ff46678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20680b609955bd1ed0f60f2c7ff46678">&#9670;&#160;</a></span>CheckedVMAddressRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a20680b609955bd1ed0f60f2c7ff46678">crashpad::CheckedVMAddressRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classcrashpad_1_1internal_1_1CheckedAddressRangeGeneric.html">internal::CheckedAddressRangeGeneric&lt;VMAddress, VMSize&gt;</a></div>
</div><!-- fragment -->
<p>Ensures that a range, composed of a base and a size, does not overflow the pointer type of the process it describes a range in. </p>
<p>This class checks bases of type <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256" title="Type used to represent an address in a process, potentially across bitness.">VMAddress</a> and sizes of type <a class="el" href="#afc29d9e6679a899150179ba3ce896072" title="Type used to represent the size of a memory range (with a VMAddress), potentially across bitness.">VMSize</a> against a process whose pointer type is either 32 or 64 bits wide.</p>
<p>Aside from varying the overall range on the basis of a process’ pointer type width, this class functions very similarly to <a class="el" href="classcrashpad_1_1CheckedRange.html" title="Ensures that a range, composed of a base and size, does not overflow its data type.">CheckedRange</a>. </p>

</div>
</div>
<a id="aee4f562873b273c153c1b9b92c39eafd" name="aee4f562873b273c153c1b9b92c39eafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4f562873b273c153c1b9b92c39eafd">&#9670;&#160;</a></span>CheckedWinAddressRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aee4f562873b273c153c1b9b92c39eafd">crashpad::CheckedWinAddressRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classcrashpad_1_1internal_1_1CheckedAddressRangeGeneric.html">internal::CheckedAddressRangeGeneric&lt;WinVMAddress, WinVMSize&gt;</a></div>
</div><!-- fragment -->
<p>Ensures that a range, composed of a base and a size, does not overflow the pointer type of the process it describes a range in. </p>
<p>This class checks bases of type <a class="el" href="#ac5872ff07ebe5bda9f532e8d3d752d77" title="Type used to represent an address in a process, potentially across bitness.">WinVMAddress</a> and sizes of type <a class="el" href="#aa24b456d735f72df6141fd110542b24f" title="Type used to represent the size of a memory range (with a WinVMAddress), potentially across bitness.">WinVMSize</a> against a process whose pointer type is either 32 or 64 bits wide.</p>
<p>Aside from varying the overall range on the basis of a process' pointer type width, this class functions very similarly to <a class="el" href="classcrashpad_1_1CheckedRange.html" title="Ensures that a range, composed of a base and size, does not overflow its data type.">CheckedRange</a>. </p>

</div>
</div>
<a id="ae8a2e5f928712c15766a756cd2035d90" name="ae8a2e5f928712c15766a756cd2035d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a2e5f928712c15766a756cd2035d90">&#9670;&#160;</a></span>ConstThreadState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae8a2e5f928712c15766a756cd2035d90">crashpad::ConstThreadState</a> = const natural_t*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A const version of <code>thread_state_t</code>. </p>
<p>This is useful as the <em class="arg">old_state</em> parameter to exception handler functions. Normally, these parameters are of type <code>thread_state_t</code>, but this allows modification of the state, which is conceptually <code>const</code>. </p>

</div>
</div>
<a id="abd63ad5a7c13f493e8d1e37ef7801bce" name="abd63ad5a7c13f493e8d1e37ef7801bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd63ad5a7c13f493e8d1e37ef7801bce">&#9670;&#160;</a></span>MachMessageDeadline</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abd63ad5a7c13f493e8d1e37ef7801bce">crashpad::MachMessageDeadline</a> = uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The time before which a <a class="el" href="#a35293418a0b7637a00631807ac4b431e" title="Runs mach_msg() with a deadline, as opposed to a timeout.">MachMessageWithDeadline()</a> call should complete. </p>
<p>A value of this type may be one of the special constants <a class="el" href="#a1aaf1be45de9c694fb5e4169b963a64da6461bf9de012b5f2305fb3da6d0f82d5" title="MachMessageWithDeadline() should not block at all in its operation.">kMachMessageDeadlineNonblocking</a> or <a class="el" href="#a1aaf1be45de9c694fb5e4169b963a64da848a739b3c252f4565161a6bd3f070d6" title="MachMessageWithDeadline() should wait indefinitely for the requested operation to complete.">kMachMessageDeadlineWaitIndefinitely</a>. Any other values should be produced by calling <a class="el" href="#aa31f495c675536bcb30d1267c3a9b696" title="Computes the deadline for a specified timeout value.">MachMessageDeadlineFromTimeout()</a>.</p>
<p>Internally, these are currently specified on the same time base as <a class="el" href="#aa93af751a4a09c316fb3de1a90e03fe8" title="Returns the value of the system’s monotonic clock.">ClockMonotonicNanoseconds()</a>, although this is an implementation detail. </p>

</div>
</div>
<a id="a6e1c44f1c92c4ae031829f6f1b255268" name="a6e1c44f1c92c4ae031829f6f1b255268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1c44f1c92c4ae031829f6f1b255268">&#9670;&#160;</a></span>MinidumpThreadIDMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6e1c44f1c92c4ae031829f6f1b255268">crashpad::MinidumpThreadIDMap</a> = std::map&lt;uint64_t, uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map that connects 64-bit snapshot thread IDs to 32-bit minidump thread IDs. </p>
<p>64-bit snapshot thread IDs are obtained from <a class="el" href="classcrashpad_1_1ThreadSnapshot.html#a3c953575fadb934cd5f163560df149da" title="Returns the thread’s identifier.">ThreadSnapshot::ThreadID()</a>. 32-bit minidump thread IDs are stored in <a class="el" href="structMINIDUMP__THREAD.html#a1d2508187af6c3ec09e5836badb56fd2" title="The thread’s ID. This may be referenced by MINIDUMP_EXCEPTION_STREAM::ThreadId.">MINIDUMP_THREAD::ThreadId</a>.</p>
<p>A ThreadIDMap ensures that there are no collisions among the set of 32-bit minidump thread IDs. </p>

</div>
</div>
<a id="a5f88ce9692185d6885a6ca33d9a1769a" name="a5f88ce9692185d6885a6ca33d9a1769a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f88ce9692185d6885a6ca33d9a1769a">&#9670;&#160;</a></span>MinidumpUTF16StringListWriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcrashpad_1_1internal_1_1MinidumpStringListWriter.html">crashpad::MinidumpUTF16StringListWriter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_class" href="classcrashpad_1_1internal_1_1MinidumpStringListWriter.html">internal::MinidumpStringListWriter</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classcrashpad_1_1internal_1_1MinidumpUTF16StringWriter.html">internal::MinidumpUTF16StringWriter</a>&gt;</div>
<div class="ttc" id="aclasscrashpad_1_1internal_1_1MinidumpStringListWriter_html"><div class="ttname"><a href="classcrashpad_1_1internal_1_1MinidumpStringListWriter.html">crashpad::internal::MinidumpStringListWriter</a></div><div class="ttdoc">The writer for a MinidumpRVAList object in a minidump file, containing a list of MinidumpStringWriter...</div><div class="ttdef"><b>Definition</b> minidump_string_writer.h:138</div></div>
<div class="ttc" id="aclasscrashpad_1_1internal_1_1MinidumpUTF16StringWriter_html"><div class="ttname"><a href="classcrashpad_1_1internal_1_1MinidumpUTF16StringWriter.html">crashpad::internal::MinidumpUTF16StringWriter</a></div><div class="ttdoc">Writes a variable-length UTF-16-encoded MINIDUMP_STRING to a minidump file.</div><div class="ttdef"><b>Definition</b> minidump_string_writer.h:92</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae51b94450e9ed369f88eb5145b79a294" name="ae51b94450e9ed369f88eb5145b79a294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51b94450e9ed369f88eb5145b79a294">&#9670;&#160;</a></span>MinidumpUTF8StringListWriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcrashpad_1_1internal_1_1MinidumpStringListWriter.html">crashpad::MinidumpUTF8StringListWriter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_class" href="classcrashpad_1_1internal_1_1MinidumpStringListWriter.html">internal::MinidumpStringListWriter</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classcrashpad_1_1internal_1_1MinidumpUTF8StringWriter.html">internal::MinidumpUTF8StringWriter</a>&gt;</div>
<div class="ttc" id="aclasscrashpad_1_1internal_1_1MinidumpUTF8StringWriter_html"><div class="ttname"><a href="classcrashpad_1_1internal_1_1MinidumpUTF8StringWriter.html">crashpad::internal::MinidumpUTF8StringWriter</a></div><div class="ttdoc">Writes a variable-length UTF-8-encoded MinidumpUTF8String to a minidump file.</div><div class="ttdef"><b>Definition</b> minidump_string_writer.h:115</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab78e3cfff43d8e9e512f30955e370bb3" name="ab78e3cfff43d8e9e512f30955e370bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78e3cfff43d8e9e512f30955e370bb3">&#9670;&#160;</a></span>ScopedDIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab78e3cfff43d8e9e512f30955e370bb3">crashpad::ScopedDIR</a> = base::ScopedGeneric&lt;DIR*, <a class="el" href="structcrashpad_1_1internal_1_1ScopedDIRCloseTraits.html">internal::ScopedDIRCloseTraits</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maintains a directory opened by <code>opendir</code>. </p>
<p>On destruction, the directory will be closed by calling <code>closedir</code>. </p>

</div>
</div>
<a id="a9d238d84679f94a3ff54990a046c9d97" name="a9d238d84679f94a3ff54990a046c9d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d238d84679f94a3ff54990a046c9d97">&#9670;&#160;</a></span>ScopedFileHANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using crashpad::ScopedFileHANDLE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    base::ScopedGeneric&lt;HANDLE, internal::ScopedFileHANDLECloseTraits&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b575c25dd6883dbbc08db53642cc2a9" name="a0b575c25dd6883dbbc08db53642cc2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b575c25dd6883dbbc08db53642cc2a9">&#9670;&#160;</a></span>ScopedKernelHANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using crashpad::ScopedKernelHANDLE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    base::ScopedGeneric&lt;HANDLE, internal::ScopedKernelHANDLECloseTraits&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a44b03ee3dc50e580c62f657e6f6d0061" name="a44b03ee3dc50e580c62f657e6f6d0061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b03ee3dc50e580c62f657e6f6d0061">&#9670;&#160;</a></span>ScopedLocalAlloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using crashpad::ScopedLocalAlloc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    base::ScopedGeneric&lt;HLOCAL, internal::LocalAllocTraits&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a37c3328971c7ec0e4924bdafdfabc92c" name="a37c3328971c7ec0e4924bdafdfabc92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c3328971c7ec0e4924bdafdfabc92c">&#9670;&#160;</a></span>ScopedRegistryKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using crashpad::ScopedRegistryKey</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    base::ScopedGeneric&lt;HKEY, ScopedRegistryKeyCloseTraits&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="af1196c8542180d5e524acf5c12c70400" name="af1196c8542180d5e524acf5c12c70400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1196c8542180d5e524acf5c12c70400">&#9670;&#160;</a></span>ScopedRemoveFile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using crashpad::ScopedRemoveFile</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    base::ScopedGeneric&lt;base::FilePath, ScopedRemoveFileTraits&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9fa0022ad87e59bd944006a415df67d6" name="a9fa0022ad87e59bd944006a415df67d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa0022ad87e59bd944006a415df67d6">&#9670;&#160;</a></span>ScopedSearchHANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using crashpad::ScopedSearchHANDLE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    base::ScopedGeneric&lt;HANDLE, internal::ScopedSearchHANDLECloseTraits&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="af880f0a616015d21f84fe942637b98ce" name="af880f0a616015d21f84fe942637b98ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af880f0a616015d21f84fe942637b98ce">&#9670;&#160;</a></span>ScopedVectoredExceptionRegistration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using crashpad::ScopedVectoredExceptionRegistration</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> base::ScopedGeneric&lt;</div>
<div class="line">    PVOID,</div>
<div class="line">    <a class="code hl_struct" href="structcrashpad_1_1internal_1_1ScopedVectoredExceptionRegistrationCloseTraits.html">internal::ScopedVectoredExceptionRegistrationCloseTraits</a>&gt;</div>
<div class="ttc" id="astructcrashpad_1_1internal_1_1ScopedVectoredExceptionRegistrationCloseTraits_html"><div class="ttname"><a href="structcrashpad_1_1internal_1_1ScopedVectoredExceptionRegistrationCloseTraits.html">crashpad::internal::ScopedVectoredExceptionRegistrationCloseTraits</a></div><div class="ttdef"><b>Definition</b> scoped_handle.h:41</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a234f585958271d359e8f1a4ae3f95553" name="a234f585958271d359e8f1a4ae3f95553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234f585958271d359e8f1a4ae3f95553">&#9670;&#160;</a></span>SimpleStringDictionary</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a234f585958271d359e8f1a4ae3f95553">crashpad::SimpleStringDictionary</a> = <a class="el" href="classcrashpad_1_1TSimpleStringDictionary.html">TSimpleStringDictionary</a>&lt;256, 256, 64&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classcrashpad_1_1TSimpleStringDictionary.html" title="A map/dictionary collection implementation using a fixed amount of storage, so that it does not perfo...">TSimpleStringDictionary</a> with default template parameters. </p>
<p>For historical reasons this specialized version is available with the same size factors as a previous implementation. </p>

</div>
</div>
<a id="a3893b3669fe314ad5485f98446ae7dc0" name="a3893b3669fe314ad5485f98446ae7dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3893b3669fe314ad5485f98446ae7dc0">&#9670;&#160;</a></span>UserStreamDataSources</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using crashpad::UserStreamDataSources</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;UserStreamDataSource&gt;&gt;</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="add7dde662bc884d716c35ee765db725e" name="add7dde662bc884d716c35ee765db725e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7dde662bc884d716c35ee765db725e">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add7dde662bc884d716c35ee765db725eae4f1a3b637ac392d76826131e72ac832" name="add7dde662bc884d716c35ee765db725eae4f1a3b637ac392d76826131e72ac832"></a>kXPProcessAllAccess&#160;</td><td class="fielddoc"><p>This is the XP-suitable value of <code>PROCESS_ALL_ACCESS</code>. </p>
<p>Requesting <code>PROCESS_ALL_ACCESS</code> with the value defined when building against a Vista+ SDK results in <code>ERROR_ACCESS_DENIED</code> when running on XP. See <a href="https://msdn.microsoft.com/library/ms684880.aspx">https://msdn.microsoft.com/library/ms684880.aspx</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="add7dde662bc884d716c35ee765db725eaf4736ae0e9abf32de684ad33895eec0e" name="add7dde662bc884d716c35ee765db725eaf4736ae0e9abf32de684ad33895eec0e"></a>kXPThreadAllAccess&#160;</td><td class="fielddoc"><p>This is the XP-suitable value of <code>THREAD_ALL_ACCESS</code>. </p>
<p>Requesting <code>THREAD_ALL_ACCESS</code> with the value defined when building against a Vista+ SDK results in <code>ERROR_ACCESS_DENIED</code> when running on XP. See <a href="https://msdn.microsoft.com/library/ms686769.aspx">https://msdn.microsoft.com/library/ms686769.aspx</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="af2bdc8a7a2af1fc2459cad703879884d" name="af2bdc8a7a2af1fc2459cad703879884d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bdc8a7a2af1fc2459cad703879884d">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : mach_msg_timeout_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special constants used as <code>mach_msg_timeout_t</code> values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af2bdc8a7a2af1fc2459cad703879884da15aaf8991271871ab08493449c00a048" name="af2bdc8a7a2af1fc2459cad703879884da15aaf8991271871ab08493449c00a048"></a>kMachMessageTimeoutNonblocking&#160;</td><td class="fielddoc"><p>When passed to <a class="el" href="#aa31f495c675536bcb30d1267c3a9b696" title="Computes the deadline for a specified timeout value.">MachMessageDeadlineFromTimeout()</a>, that function will return <a class="el" href="#a1aaf1be45de9c694fb5e4169b963a64da6461bf9de012b5f2305fb3da6d0f82d5" title="MachMessageWithDeadline() should not block at all in its operation.">kMachMessageDeadlineNonblocking</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2bdc8a7a2af1fc2459cad703879884daaf4f2c8a649ea6bcfe896e77c312315f" name="af2bdc8a7a2af1fc2459cad703879884daaf4f2c8a649ea6bcfe896e77c312315f"></a>kMachMessageTimeoutWaitIndefinitely&#160;</td><td class="fielddoc"><p>When passed to <a class="el" href="#aa31f495c675536bcb30d1267c3a9b696" title="Computes the deadline for a specified timeout value.">MachMessageDeadlineFromTimeout()</a>, that function will return <a class="el" href="#a1aaf1be45de9c694fb5e4169b963a64da848a739b3c252f4565161a6bd3f070d6" title="MachMessageWithDeadline() should wait indefinitely for the requested operation to complete.">kMachMessageDeadlineWaitIndefinitely</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1aaf1be45de9c694fb5e4169b963a64d" name="a1aaf1be45de9c694fb5e4169b963a64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aaf1be45de9c694fb5e4169b963a64d">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : <a class="el" href="#abd63ad5a7c13f493e8d1e37ef7801bce">MachMessageDeadline</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special constants used as <a class="el" href="#abd63ad5a7c13f493e8d1e37ef7801bce">MachMessageDeadline</a> values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1aaf1be45de9c694fb5e4169b963a64da6461bf9de012b5f2305fb3da6d0f82d5" name="a1aaf1be45de9c694fb5e4169b963a64da6461bf9de012b5f2305fb3da6d0f82d5"></a>kMachMessageDeadlineNonblocking&#160;</td><td class="fielddoc"><p><a class="el" href="#a35293418a0b7637a00631807ac4b431e" title="Runs mach_msg() with a deadline, as opposed to a timeout.">MachMessageWithDeadline()</a> should not block at all in its operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1aaf1be45de9c694fb5e4169b963a64da848a739b3c252f4565161a6bd3f070d6" name="a1aaf1be45de9c694fb5e4169b963a64da848a739b3c252f4565161a6bd3f070d6"></a>kMachMessageDeadlineWaitIndefinitely&#160;</td><td class="fielddoc"><p><a class="el" href="#a35293418a0b7637a00631807ac4b431e" title="Runs mach_msg() with a deadline, as opposed to a timeout.">MachMessageWithDeadline()</a> should wait indefinitely for the requested operation to complete. </p>
</td></tr>
</table>

</div>
</div>
<a id="a270e290ba558e948eb6690bd217cbb71" name="a270e290ba558e948eb6690bd217cbb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270e290ba558e948eb6690bd217cbb71">&#9670;&#160;</a></span>CPUArchitecture</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a270e290ba558e948eb6690bd217cbb71">crashpad::CPUArchitecture</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A system’s CPU architecture. </p>
<p>This can be used to represent the CPU architecture of an entire system as in SystemSnapshot::CPUArchitecture(). It can also be used to represent the architecture of a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structure in its <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union.">CPUContext::architecture</a> field without reference to external data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a270e290ba558e948eb6690bd217cbb71a4a3c395099ca8e31f9bd9511e058c73c" name="a270e290ba558e948eb6690bd217cbb71a4a3c395099ca8e31f9bd9511e058c73c"></a>kCPUArchitectureUnknown&#160;</td><td class="fielddoc"><p>The CPU architecture is unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="a270e290ba558e948eb6690bd217cbb71a35adbd1bc0b19ef37c520d078cf0df15" name="a270e290ba558e948eb6690bd217cbb71a35adbd1bc0b19ef37c520d078cf0df15"></a>kCPUArchitectureX86&#160;</td><td class="fielddoc"><p>32-bit x86. </p>
</td></tr>
<tr><td class="fieldname"><a id="a270e290ba558e948eb6690bd217cbb71addee685df867aea490719783e56baf0a" name="a270e290ba558e948eb6690bd217cbb71addee685df867aea490719783e56baf0a"></a>kCPUArchitectureX86_64&#160;</td><td class="fielddoc"><p>x86_64. </p>
</td></tr>
<tr><td class="fieldname"><a id="a270e290ba558e948eb6690bd217cbb71a0f76d97bac2e52e39caf1cd6bbe4e7ec" name="a270e290ba558e948eb6690bd217cbb71a0f76d97bac2e52e39caf1cd6bbe4e7ec"></a>kCPUArchitectureARM&#160;</td><td class="fielddoc"><p>32-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a270e290ba558e948eb6690bd217cbb71a5fe27bac5abf4fb8220cd95b9319ec6e" name="a270e290ba558e948eb6690bd217cbb71a5fe27bac5abf4fb8220cd95b9319ec6e"></a>kCPUArchitectureARM64&#160;</td><td class="fielddoc"><p>64-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a270e290ba558e948eb6690bd217cbb71a22e519bc132f9b4060f1c3805d6e3f23" name="a270e290ba558e948eb6690bd217cbb71a22e519bc132f9b4060f1c3805d6e3f23"></a>kCPUArchitectureMIPSEL&#160;</td><td class="fielddoc"><p>32-bit MIPSEL. </p>
</td></tr>
<tr><td class="fieldname"><a id="a270e290ba558e948eb6690bd217cbb71a16162f32d9347391a58bed50a1d60c5b" name="a270e290ba558e948eb6690bd217cbb71a16162f32d9347391a58bed50a1d60c5b"></a>kCPUArchitectureMIPS64EL&#160;</td><td class="fielddoc"><p>64-bit MIPSEL. </p>
</td></tr>
<tr><td class="fieldname"><a id="a270e290ba558e948eb6690bd217cbb71a14a09874af1fa6d4c4919a09e35ce11f" name="a270e290ba558e948eb6690bd217cbb71a14a09874af1fa6d4c4919a09e35ce11f"></a>kCPUArchitectureRISCV64&#160;</td><td class="fielddoc"><p>64-bit RISC-V. </p>
</td></tr>
</table>

</div>
</div>
<a id="a62f81158149497e656e97ce1b1565185" name="a62f81158149497e656e97ce1b1565185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f81158149497e656e97ce1b1565185">&#9670;&#160;</a></span>ExceptionCodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a62f81158149497e656e97ce1b1565185">crashpad::ExceptionCodes</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crashpad-specific exception codes that are used as arguments to <code>RaiseException()</code> in unusual circumstances. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a62f81158149497e656e97ce1b1565185a3ed01c48efee58fce110c419058b5d88" name="a62f81158149497e656e97ce1b1565185a3ed01c48efee58fce110c419058b5d88"></a>kTriggeredExceptionCode&#160;</td><td class="fielddoc"><p>The exception code (roughly "Client called") used when DumpAndCrashTargetProcess() triggers an exception in a target process. </p>
<dl class="section note"><dt>Note</dt><dd>This value does not have any bits of the top nibble set, to avoid confusion with real exception codes which tend to have those bits set. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="a3753a95b02e5c96c6e20017e467cef07" name="a3753a95b02e5c96c6e20017e467cef07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3753a95b02e5c96c6e20017e467cef07">&#9670;&#160;</a></span>FileLocking</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a3753a95b02e5c96c6e20017e467cef07">crashpad::FileLocking</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the locking mode that LoggingLockFile() uses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3753a95b02e5c96c6e20017e467cef07a767e1337acb2aa20d7ce4e903a75ca16" name="a3753a95b02e5c96c6e20017e467cef07a767e1337acb2aa20d7ce4e903a75ca16"></a>kShared&#160;</td><td class="fielddoc"><p>Equivalent to <code>flock()</code> with <code>LOCK_SH</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3753a95b02e5c96c6e20017e467cef07a9d38b79e17ebc3239ca19ba517174b5b" name="a3753a95b02e5c96c6e20017e467cef07a9d38b79e17ebc3239ca19ba517174b5b"></a>kExclusive&#160;</td><td class="fielddoc"><p>Equivalent to <code>flock()</code> with <code>LOCK_EX</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5e435b88af637eb873950400d28bc9d4" name="a5e435b88af637eb873950400d28bc9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e435b88af637eb873950400d28bc9d4">&#9670;&#160;</a></span>FileLockingBlocking</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a5e435b88af637eb873950400d28bc9d4">crashpad::FileLockingBlocking</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if LoggingLockFile will block. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e435b88af637eb873950400d28bc9d4aff7c2d49aab9f84465f8f60ef696141b" name="a5e435b88af637eb873950400d28bc9d4aff7c2d49aab9f84465f8f60ef696141b"></a>kBlocking&#160;</td><td class="fielddoc"><p>Block until the lock is acquired. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e435b88af637eb873950400d28bc9d4ad7be212a11c84aaa34c42f05de311709" name="a5e435b88af637eb873950400d28bc9d4ad7be212a11c84aaa34c42f05de311709"></a>kNonBlocking&#160;</td><td class="fielddoc"><p>Do not block when attempting to acquire a lock. </p>
</td></tr>
</table>

</div>
</div>
<a id="a50dad59abd6bde82bf08419de636d580" name="a50dad59abd6bde82bf08419de636d580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dad59abd6bde82bf08419de636d580">&#9670;&#160;</a></span>FileLockingResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a50dad59abd6bde82bf08419de636d580">crashpad::FileLockingResult</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The return value for LoggingLockFile. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a50dad59abd6bde82bf08419de636d580a8c632159fa131f09d04f94e3cbcd8782" name="a50dad59abd6bde82bf08419de636d580a8c632159fa131f09d04f94e3cbcd8782"></a>kSuccess&#160;</td><td class="fielddoc"><p>The lock was acquired successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dad59abd6bde82bf08419de636d580a887f88f6bbd20efb38ea376316c36a02" name="a50dad59abd6bde82bf08419de636d580a887f88f6bbd20efb38ea376316c36a02"></a>kWouldBlock&#160;</td><td class="fielddoc"><p>In non-blocking mode only, the file was already locked. Locking would block, so the lock was not acquired. </p>
</td></tr>
<tr><td class="fieldname"><a id="a50dad59abd6bde82bf08419de636d580a45d5f642bcbee805302334d856c54259" name="a50dad59abd6bde82bf08419de636d580a45d5f642bcbee805302334d856c54259"></a>kFailure&#160;</td><td class="fielddoc"><p>The lock was not acquired. </p>
</td></tr>
</table>

</div>
</div>
<a id="a034ccc90eb0d1f587ee89275d822175d" name="a034ccc90eb0d1f587ee89275d822175d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034ccc90eb0d1f587ee89275d822175d">&#9670;&#160;</a></span>FilePermissions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">crashpad::FilePermissions</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the permissions bits for files created on POSIX systems. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a034ccc90eb0d1f587ee89275d822175dab73168a18962d7b0ed6b67f2e0ade611" name="a034ccc90eb0d1f587ee89275d822175dab73168a18962d7b0ed6b67f2e0ade611"></a>kOwnerOnly&#160;</td><td class="fielddoc"><p>Equivalent to <code>0600</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a034ccc90eb0d1f587ee89275d822175da5368ce91b6c60534fe1187a23e98924d" name="a034ccc90eb0d1f587ee89275d822175da5368ce91b6c60534fe1187a23e98924d"></a>kWorldReadable&#160;</td><td class="fielddoc"><p>Equivalent to <code>0644</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="afa69b0967d9a6df659ff5d2a02ff3e51" name="afa69b0967d9a6df659ff5d2a02ff3e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa69b0967d9a6df659ff5d2a02ff3e51">&#9670;&#160;</a></span>FileWriteMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">crashpad::FileWriteMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the mode that <a class="el" href="#a62fc6876cc0c660f0ea8bd1dd0a07e82" title="Wraps OpenFileForWrite(), logging an error if the operation fails.">LoggingOpenFileForWrite()</a> uses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afa69b0967d9a6df659ff5d2a02ff3e51aafde8ca07d267d05bcec5df8b0fc6c22" name="afa69b0967d9a6df659ff5d2a02ff3e51aafde8ca07d267d05bcec5df8b0fc6c22"></a>kReuseOrFail&#160;</td><td class="fielddoc"><p>Opens the file if it exists, or fails if it does not. </p>
</td></tr>
<tr><td class="fieldname"><a id="afa69b0967d9a6df659ff5d2a02ff3e51ae32f90c7a8d4224749e4e99f11e5eee7" name="afa69b0967d9a6df659ff5d2a02ff3e51ae32f90c7a8d4224749e4e99f11e5eee7"></a>kReuseOrCreate&#160;</td><td class="fielddoc"><p>Opens the file if it exists, or creates a new file. </p>
</td></tr>
<tr><td class="fieldname"><a id="afa69b0967d9a6df659ff5d2a02ff3e51a751805077642855501f572c876e1d907" name="afa69b0967d9a6df659ff5d2a02ff3e51a751805077642855501f572c876e1d907"></a>kTruncateOrCreate&#160;</td><td class="fielddoc"><p>Creates a new file. If the file already exists, it will be overwritten. </p>
</td></tr>
<tr><td class="fieldname"><a id="afa69b0967d9a6df659ff5d2a02ff3e51a4ece9fd054e01c35ba925186adcf0c71" name="afa69b0967d9a6df659ff5d2a02ff3e51a4ece9fd054e01c35ba925186adcf0c71"></a>kCreateOrFail&#160;</td><td class="fielddoc"><p>Creates a new file. If the file already exists, the open will fail. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa197c419950bae99f1ba663f10b1891c" name="aa197c419950bae99f1ba663f10b1891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa197c419950bae99f1ba663f10b1891c">&#9670;&#160;</a></span>MinidumpContextAMD64Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aa197c419950bae99f1ba663f10b1891c">crashpad::MinidumpContextAMD64Flags</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>x86_64-specific flags for <a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html#a086c5c2655800e91e080241317aa3ace" title="A bitfield composed of values of MinidumpContextFlags and MinidumpContextAMD64Flags.">MinidumpContextAMD64::context_flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa197c419950bae99f1ba663f10b1891caaa3c47e2ec7565ce81b7cda3a4c101c6" name="aa197c419950bae99f1ba663f10b1891caaa3c47e2ec7565ce81b7cda3a4c101c6"></a>kMinidumpContextAMD64&#160;</td><td class="fielddoc"><p>Identifies the context structure as x86_64. This is the same as <code>CONTEXT_AMD64</code> on Windows for this architecture. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa197c419950bae99f1ba663f10b1891ca7aaf3a9f32414c379444f75a341f61f6" name="aa197c419950bae99f1ba663f10b1891ca7aaf3a9f32414c379444f75a341f61f6"></a>kMinidumpContextAMD64Control&#160;</td><td class="fielddoc"><p>Indicates the validity of control registers (<code>CONTEXT_CONTROL</code>). </p>
<p>The <code>cs</code>, <code>ss</code>, <code>eflags</code>, <code>rsp</code>, and <code>rip</code> fields are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa197c419950bae99f1ba663f10b1891ca3231a2e73f13021707e1dd5465124c94" name="aa197c419950bae99f1ba663f10b1891ca3231a2e73f13021707e1dd5465124c94"></a>kMinidumpContextAMD64Integer&#160;</td><td class="fielddoc"><p>Indicates the validity of non-control integer registers (<code>CONTEXT_INTEGER</code>). </p>
<p>The <code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rbx</code>, <code>rbp</code>, <code>rsi</code>, <code>rdi</code>, and <code>r8</code> through <code>r15</code> fields are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa197c419950bae99f1ba663f10b1891ca087fcb89147fcb03a42917257d7c95d8" name="aa197c419950bae99f1ba663f10b1891ca087fcb89147fcb03a42917257d7c95d8"></a>kMinidumpContextAMD64Segment&#160;</td><td class="fielddoc"><p>Indicates the validity of non-control segment registers (<code>CONTEXT_SEGMENTS</code>). </p>
<p>The <code>ds</code>, <code>es</code>, <code>fs</code>, and <code>gs</code> fields are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa197c419950bae99f1ba663f10b1891ca80855829a791a48417d0599bda56685c" name="aa197c419950bae99f1ba663f10b1891ca80855829a791a48417d0599bda56685c"></a>kMinidumpContextAMD64FloatingPoint&#160;</td><td class="fielddoc"><p>Indicates the validity of floating-point state (<code>CONTEXT_FLOATING_POINT</code>). </p>
<p>The <code>xmm0</code> through <code>xmm15</code> fields are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa197c419950bae99f1ba663f10b1891ca0a6187be426495350ac54f8eec044770" name="aa197c419950bae99f1ba663f10b1891ca0a6187be426495350ac54f8eec044770"></a>kMinidumpContextAMD64Debug&#160;</td><td class="fielddoc"><p>Indicates the validity of debug registers (<code>CONTEXT_DEBUG_REGISTERS</code>). </p>
<p>The <code>dr0</code> through <code>dr3</code>, <code>dr6</code>, and <code>dr7</code> fields are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa197c419950bae99f1ba663f10b1891cae39eafc6efd87afc7c6977ae3cc0fc96" name="aa197c419950bae99f1ba663f10b1891cae39eafc6efd87afc7c6977ae3cc0fc96"></a>kMinidumpContextAMD64Xstate&#160;</td><td class="fielddoc"><p>Indicates the validity of <code>xsave</code> data (<code>CONTEXT_XSTATE</code>). </p>
<p>The context contains <code>xsave</code> data. This is used with an extended context structure which is partly implemented for CET state only. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa197c419950bae99f1ba663f10b1891ca7d67332dea79c652a93e592341ab5e51" name="aa197c419950bae99f1ba663f10b1891ca7d67332dea79c652a93e592341ab5e51"></a>kMinidumpContextAMD64Full&#160;</td><td class="fielddoc"><p>Indicates the validity of control, integer, and floating-point registers (<code>CONTEXT_FULL</code>). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa197c419950bae99f1ba663f10b1891cac84b1d90bf34dbb26631ca77d942abf8" name="aa197c419950bae99f1ba663f10b1891cac84b1d90bf34dbb26631ca77d942abf8"></a>kMinidumpContextAMD64All&#160;</td><td class="fielddoc"><p>Indicates the validity of all registers except <code>xsave</code> data (<code>CONTEXT_ALL</code>). </p>
</td></tr>
</table>

</div>
</div>
<a id="a52002589247bce8e16fc48857f31ec8a" name="a52002589247bce8e16fc48857f31ec8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52002589247bce8e16fc48857f31ec8a">&#9670;&#160;</a></span>MinidumpContextARM64Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a52002589247bce8e16fc48857f31ec8a">crashpad::MinidumpContextARM64Flags</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit ARM-specifc flags for MinidumpContextARM64::context_flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a52002589247bce8e16fc48857f31ec8aa860b1410179a698c64ea8adbcd2a8cb4" name="a52002589247bce8e16fc48857f31ec8aa860b1410179a698c64ea8adbcd2a8cb4"></a>kMinidumpContextARM64&#160;</td><td class="fielddoc"><p>Identifies the context structure as 64-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52002589247bce8e16fc48857f31ec8aaaf724e06ee919fed0178cc155aa1406e" name="a52002589247bce8e16fc48857f31ec8aaaf724e06ee919fed0178cc155aa1406e"></a>kMinidumpContextARM64Control&#160;</td><td class="fielddoc"><p>Indicates the validity of control registers. </p>
<p>Registers <code>fp</code>, <code>lr</code>, <code>sp</code>, <code>pc</code>, and <code>cpsr</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52002589247bce8e16fc48857f31ec8aaf29250bf4d5e080a580aca580fcf1e14" name="a52002589247bce8e16fc48857f31ec8aaf29250bf4d5e080a580aca580fcf1e14"></a>kMinidumpContextARM64Integer&#160;</td><td class="fielddoc"><p>Indicates the validty of integer registers. </p>
<p>Registers <code>x0</code>-<code>x28</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52002589247bce8e16fc48857f31ec8aa2a1def4d4157278945efa666dfb887eb" name="a52002589247bce8e16fc48857f31ec8aa2a1def4d4157278945efa666dfb887eb"></a>kMinidumpContextARM64Fpsimd&#160;</td><td class="fielddoc"><p>Indicates the validity of fpsimd registers. </p>
<p>Registers <code>v0</code>-<code>v31</code>, <code>fpsr</code>, and <code>fpcr</code> are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52002589247bce8e16fc48857f31ec8aa4dbcf3fa604d026d050cf10386424125" name="a52002589247bce8e16fc48857f31ec8aa4dbcf3fa604d026d050cf10386424125"></a>kMinidumpContextARM64Debug&#160;</td><td class="fielddoc"><p>Indicates the validity of debug registers. </p>
<p><code>bcr</code>, <code>bvr</code>, <code>wcr</code>, and <code>wvr</code> are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52002589247bce8e16fc48857f31ec8aa460e2780dd5879d428983c1c435b9225" name="a52002589247bce8e16fc48857f31ec8aa460e2780dd5879d428983c1c435b9225"></a>kMinidumpContextARM64Full&#160;</td><td class="fielddoc"><p>Indicates the validity of control, integer and floating point registers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52002589247bce8e16fc48857f31ec8aa1db064490788cb2288580d3ba1969ec0" name="a52002589247bce8e16fc48857f31ec8aa1db064490788cb2288580d3ba1969ec0"></a>kMinidumpContextARM64All&#160;</td><td class="fielddoc"><p>Indicates the validity of all registers. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab7077f40e8cf5fae1f668085248efe77" name="ab7077f40e8cf5fae1f668085248efe77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7077f40e8cf5fae1f668085248efe77">&#9670;&#160;</a></span>MinidumpContextARMFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab7077f40e8cf5fae1f668085248efe77">crashpad::MinidumpContextARMFlags</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit ARM-specifc flags for <a class="el" href="structcrashpad_1_1MinidumpContextARM.html#ab5462d7d1c2b1b484ae9fdaf286aeee8" title="A bitfield composed of values of MinidumpContextFlags and MinidumpContextARMFlags.">MinidumpContextARM::context_flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab7077f40e8cf5fae1f668085248efe77a5facfc8bdb6f794df0c4794fb8b353c1" name="ab7077f40e8cf5fae1f668085248efe77a5facfc8bdb6f794df0c4794fb8b353c1"></a>kMinidumpContextARM&#160;</td><td class="fielddoc"><p>Identifies the context structure as 32-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7077f40e8cf5fae1f668085248efe77afab8bf9f637e396902fc7df7164ae807" name="ab7077f40e8cf5fae1f668085248efe77afab8bf9f637e396902fc7df7164ae807"></a>kMinidumpContextARMInteger&#160;</td><td class="fielddoc"><p>Indicates the validity of integer regsiters. </p>
<p>Regsiters <code>r0</code>-<code>r15</code> and <code>cpsr</code> are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7077f40e8cf5fae1f668085248efe77ab43d522ed5648c9635959a69cc71ed8f" name="ab7077f40e8cf5fae1f668085248efe77ab43d522ed5648c9635959a69cc71ed8f"></a>kMinidumpContextARMVFP&#160;</td><td class="fielddoc"><p>Inidicates the validity of VFP regsiters. </p>
<p>Registers <code>d0</code>-<code>d31</code> and <code>fpscr</code> are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7077f40e8cf5fae1f668085248efe77a202bd40d0dff96c51379932e4149a1af" name="ab7077f40e8cf5fae1f668085248efe77a202bd40d0dff96c51379932e4149a1af"></a>kMinidumpContextARMAll&#160;</td><td class="fielddoc"><p>Indicates the validity of all registers. </p>
</td></tr>
</table>

</div>
</div>
<a id="a835e6bd6cb3f97c99c572596878c1573" name="a835e6bd6cb3f97c99c572596878c1573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835e6bd6cb3f97c99c572596878c1573">&#9670;&#160;</a></span>MinidumpContextFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a835e6bd6cb3f97c99c572596878c1573">crashpad::MinidumpContextFlags</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Architecture-independent flags for <code>context_flags</code> fields in Minidump context structures. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a835e6bd6cb3f97c99c572596878c1573ac76899aed0f9a5f331fcdc9343a1bc68" name="a835e6bd6cb3f97c99c572596878c1573ac76899aed0f9a5f331fcdc9343a1bc68"></a>kMinidumpContextExceptionActive&#160;</td><td class="fielddoc"><p>The thread was executing a trap handler in kernel mode (<code>CONTEXT_EXCEPTION_ACTIVE</code>). </p>
<p>If this bit is set, it indicates that the context is from a thread that was executing a trap handler in the kernel. This bit is only valid when <a class="el" href="#a835e6bd6cb3f97c99c572596878c1573ae8cd92df6bc89b12ba3a4f7fe8529f10" title="Kernel-mode state reporting is provided (CONTEXT_EXCEPTION_REPORTING).">kMinidumpContextExceptionReporting</a> is also set. This bit is only used on Windows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a835e6bd6cb3f97c99c572596878c1573ac0a5b0f61a08eae36fc1ed26fa929ebb" name="a835e6bd6cb3f97c99c572596878c1573ac0a5b0f61a08eae36fc1ed26fa929ebb"></a>kMinidumpContextServiceActive&#160;</td><td class="fielddoc"><p>The thread was executing a system call in kernel mode (<code>CONTEXT_SERVICE_ACTIVE</code>). </p>
<p>If this bit is set, it indicates that the context is from a thread that was executing a system call in the kernel. This bit is only valid when <a class="el" href="#a835e6bd6cb3f97c99c572596878c1573ae8cd92df6bc89b12ba3a4f7fe8529f10" title="Kernel-mode state reporting is provided (CONTEXT_EXCEPTION_REPORTING).">kMinidumpContextExceptionReporting</a> is also set. This bit is only used on Windows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a835e6bd6cb3f97c99c572596878c1573a86fb4b3183b9ec5acb7798246f2de9e5" name="a835e6bd6cb3f97c99c572596878c1573a86fb4b3183b9ec5acb7798246f2de9e5"></a>kMinidumpContextExceptionRequest&#160;</td><td class="fielddoc"><p>Kernel-mode state reporting is desired (<code>CONTEXT_EXCEPTION_REQUEST</code>). </p>
<p>This bit is not used in context structures containing snapshots of thread CPU context. It used when calling <code>GetThreadContext()</code> on Windows to specify that kernel-mode state reporting (<a class="el" href="#a835e6bd6cb3f97c99c572596878c1573ae8cd92df6bc89b12ba3a4f7fe8529f10" title="Kernel-mode state reporting is provided (CONTEXT_EXCEPTION_REPORTING).">kMinidumpContextExceptionReporting</a>) is desired in the returned context structure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a835e6bd6cb3f97c99c572596878c1573ae8cd92df6bc89b12ba3a4f7fe8529f10" name="a835e6bd6cb3f97c99c572596878c1573ae8cd92df6bc89b12ba3a4f7fe8529f10"></a>kMinidumpContextExceptionReporting&#160;</td><td class="fielddoc"><p>Kernel-mode state reporting is provided (<code>CONTEXT_EXCEPTION_REPORTING</code>). </p>
<p>If this bit is set, it indicates that the bits indicating how the thread had entered kernel mode (<a class="el" href="#a835e6bd6cb3f97c99c572596878c1573ac76899aed0f9a5f331fcdc9343a1bc68" title="The thread was executing a trap handler in kernel mode (CONTEXT_EXCEPTION_ACTIVE).">kMinidumpContextExceptionActive</a> and <a class="el" href="#a835e6bd6cb3f97c99c572596878c1573ac0a5b0f61a08eae36fc1ed26fa929ebb" title="The thread was executing a system call in kernel mode (CONTEXT_SERVICE_ACTIVE).">kMinidumpContextServiceActive</a>) are valid. This bit is only used on Windows. </p>
</td></tr>
</table>

</div>
</div>
<a id="a34392d7c57fce1cdcc10bb1f026a79e6" name="a34392d7c57fce1cdcc10bb1f026a79e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34392d7c57fce1cdcc10bb1f026a79e6">&#9670;&#160;</a></span>MinidumpContextMIPS64Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a34392d7c57fce1cdcc10bb1f026a79e6">crashpad::MinidumpContextMIPS64Flags</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64bit MIPS-specifc flags for MinidumpContextMIPS64::context_flags. Based on minidump_cpu_mips.h from breakpad </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a34392d7c57fce1cdcc10bb1f026a79e6ac66ed0e3d38b9f9a1407141e369f2eab" name="a34392d7c57fce1cdcc10bb1f026a79e6ac66ed0e3d38b9f9a1407141e369f2eab"></a>kMinidumpContextMIPS64&#160;</td><td class="fielddoc"><p>Identifies the context structure as MIPS64EL. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34392d7c57fce1cdcc10bb1f026a79e6a1103efd9dcca8d9e93b8b374ce4f4159" name="a34392d7c57fce1cdcc10bb1f026a79e6a1103efd9dcca8d9e93b8b374ce4f4159"></a>kMinidumpContextMIPS64Integer&#160;</td><td class="fielddoc"><p>Indicates the validity of integer registers. </p>
<p>Registers <code>0</code>-<code>31</code>, <code>mdhi</code>, <code>mdlo</code>, <code>epc</code>, <code>badvaddr</code>, <code>status</code> and <code>cause</code> are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34392d7c57fce1cdcc10bb1f026a79e6a9ea3d63f20eb98526330c2116f7c6592" name="a34392d7c57fce1cdcc10bb1f026a79e6a9ea3d63f20eb98526330c2116f7c6592"></a>kMinidumpContextMIPS64FloatingPoint&#160;</td><td class="fielddoc"><p>Indicates the validity of floating point registers. </p>
<p>Floating point registers <code>0</code>-<code>31</code>, <code>fpcsr</code> and <code>fir</code> are valid </p>
</td></tr>
<tr><td class="fieldname"><a id="a34392d7c57fce1cdcc10bb1f026a79e6aa8257cf820054f7b302fb43f2095f593" name="a34392d7c57fce1cdcc10bb1f026a79e6aa8257cf820054f7b302fb43f2095f593"></a>kMinidumpContextMIPS64DSP&#160;</td><td class="fielddoc"><p>Indicates the validity of DSP registers. </p>
<p>Registers <code>hi0</code>-<code>hi2</code>, <code>lo0</code>-<code>lo2</code> and <code>dsp_control</code> are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34392d7c57fce1cdcc10bb1f026a79e6a63a0cacd444668373017ee893f3ace7d" name="a34392d7c57fce1cdcc10bb1f026a79e6a63a0cacd444668373017ee893f3ace7d"></a>kMinidumpContextMIPS64All&#160;</td><td class="fielddoc"><p>Indicates the validity of all registers. </p>
</td></tr>
</table>

</div>
</div>
<a id="add06cd316d6db039af0fd3607be18dec" name="add06cd316d6db039af0fd3607be18dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add06cd316d6db039af0fd3607be18dec">&#9670;&#160;</a></span>MinidumpContextMIPSFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#add06cd316d6db039af0fd3607be18dec">crashpad::MinidumpContextMIPSFlags</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32bit MIPS-specifc flags for MinidumpContextMIPS::context_flags. Based on minidump_cpu_mips.h from breakpad </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add06cd316d6db039af0fd3607be18decabd6c62963c9acee1da68ccd34a229854" name="add06cd316d6db039af0fd3607be18decabd6c62963c9acee1da68ccd34a229854"></a>kMinidumpContextMIPS&#160;</td><td class="fielddoc"><p>Identifies the context structure as MIPSEL. </p>
</td></tr>
<tr><td class="fieldname"><a id="add06cd316d6db039af0fd3607be18deca90e0dc6dcdab7f3de6c5410ddd402309" name="add06cd316d6db039af0fd3607be18deca90e0dc6dcdab7f3de6c5410ddd402309"></a>kMinidumpContextMIPSInteger&#160;</td><td class="fielddoc"><p>Indicates the validity of integer registers. </p>
<p>Registers <code>0</code>-<code>31</code>, <code>mdhi</code>, <code>mdlo</code>, <code>epc</code>, <code>badvaddr</code>, <code>status</code> and <code>cause</code> are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="add06cd316d6db039af0fd3607be18deca54be4bbf692b8e39decc1d170f83cf19" name="add06cd316d6db039af0fd3607be18deca54be4bbf692b8e39decc1d170f83cf19"></a>kMinidumpContextMIPSFloatingPoint&#160;</td><td class="fielddoc"><p>Indicates the validity of floating point registers. </p>
<p>Floating point registers <code>0</code>-<code>31</code>, <code>fpcsr</code> and <code>fir</code> are valid </p>
</td></tr>
<tr><td class="fieldname"><a id="add06cd316d6db039af0fd3607be18deca1f3992fb8cabdb968cd785a387d0ea66" name="add06cd316d6db039af0fd3607be18deca1f3992fb8cabdb968cd785a387d0ea66"></a>kMinidumpContextMIPSDSP&#160;</td><td class="fielddoc"><p>Indicates the validity of DSP registers. </p>
<p>Registers <code>hi0</code>-<code>hi2</code>, <code>lo0</code>-<code>lo2</code> and <code>dsp_control</code> are valid </p>
</td></tr>
<tr><td class="fieldname"><a id="add06cd316d6db039af0fd3607be18deca54a16324b94a737c312c6cac04c5cfd6" name="add06cd316d6db039af0fd3607be18deca54a16324b94a737c312c6cac04c5cfd6"></a>kMinidumpContextMIPSAll&#160;</td><td class="fielddoc"><p>Indicates the validity of all registers. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2b038cf2475f6e27660050f8907a309e" name="a2b038cf2475f6e27660050f8907a309e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b038cf2475f6e27660050f8907a309e">&#9670;&#160;</a></span>MinidumpContextRISCV64Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a2b038cf2475f6e27660050f8907a309e">crashpad::MinidumpContextRISCV64Flags</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit RISCV-specific flags for <a class="el" href="structcrashpad_1_1MinidumpContextRISCV64.html#ac752081e03276e68983ee95678f2ac75" title="Indicates the validity of fields in this structure.">MinidumpContextRISCV64::context_flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2b038cf2475f6e27660050f8907a309eabaa8ad56f455cda868603b3b137e4c0f" name="a2b038cf2475f6e27660050f8907a309eabaa8ad56f455cda868603b3b137e4c0f"></a>kMinidumpContextRISCV64&#160;</td><td class="fielddoc"><p>Identifies the context structure as RISCV64. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b038cf2475f6e27660050f8907a309ea2a99842db540243a5910fcddd17b8d9c" name="a2b038cf2475f6e27660050f8907a309ea2a99842db540243a5910fcddd17b8d9c"></a>kMinidumpContextRISCV64Integer&#160;</td><td class="fielddoc"><p>Indicates the validity of integer registers. </p>
<p>Registers 'pc' and <code>x1</code>-<code>x31</code> are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b038cf2475f6e27660050f8907a309eace104bd9a85be0d2cbd4b1be0a8bf398" name="a2b038cf2475f6e27660050f8907a309eace104bd9a85be0d2cbd4b1be0a8bf398"></a>kMinidumpContextRISCV64FloatingPoint&#160;</td><td class="fielddoc"><p>Indicates the validity of floating point registers. </p>
<p>Floating point registers <code>f0</code>-<code>f31</code> are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b038cf2475f6e27660050f8907a309eae40432fdbe03f1b3d047318d96234643" name="a2b038cf2475f6e27660050f8907a309eae40432fdbe03f1b3d047318d96234643"></a>kMinidumpContextRISCV64All&#160;</td><td class="fielddoc"><p>Indicates the validity of all registers. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2a503f0a39ec98188b60178edbc1fc55" name="a2a503f0a39ec98188b60178edbc1fc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a503f0a39ec98188b60178edbc1fc55">&#9670;&#160;</a></span>MinidumpContextX86Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a2a503f0a39ec98188b60178edbc1fc55">crashpad::MinidumpContextX86Flags</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit x86-specifc flags for <a class="el" href="structcrashpad_1_1MinidumpContextX86.html#a0b4f61874b6d7bf6bb750e270ceaad80" title="A bitfield composed of values of MinidumpContextFlags and MinidumpContextX86Flags.">MinidumpContextX86::context_flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55a2f6918d087ba8042f2df2342e4fb3875" name="a2a503f0a39ec98188b60178edbc1fc55a2f6918d087ba8042f2df2342e4fb3875"></a>kMinidumpContextX86&#160;</td><td class="fielddoc"><p>Identifies the context structure as 32-bit x86. This is the same as <code>CONTEXT_i386</code> and <code>CONTEXT_i486</code> on Windows for this architecture. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55ada1e4c9c9232467b3f2d3784bceecb7b" name="a2a503f0a39ec98188b60178edbc1fc55ada1e4c9c9232467b3f2d3784bceecb7b"></a>kMinidumpContextX86Control&#160;</td><td class="fielddoc"><p>Indicates the validity of control registers (<code>CONTEXT_CONTROL</code>). </p>
<p>The <code>ebp</code>, <code>eip</code>, <code>cs</code>, <code>eflags</code>, <code>esp</code>, and <code>ss</code> fields are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55a8cee96af57fd2f7e45350dadd97743ad" name="a2a503f0a39ec98188b60178edbc1fc55a8cee96af57fd2f7e45350dadd97743ad"></a>kMinidumpContextX86Integer&#160;</td><td class="fielddoc"><p>Indicates the validity of non-control integer registers (<code>CONTEXT_INTEGER</code>). </p>
<p>The <code>edi</code>, <code>esi</code>, <code>ebx</code>, <code>edx</code>, <code>ecx</code>, and <code>eax</code> fields are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55a351a40dfb28c1bed5d3efbaa5109f69e" name="a2a503f0a39ec98188b60178edbc1fc55a351a40dfb28c1bed5d3efbaa5109f69e"></a>kMinidumpContextX86Segment&#160;</td><td class="fielddoc"><p>Indicates the validity of non-control segment registers (<code>CONTEXT_SEGMENTS</code>). </p>
<p>The <code>gs</code>, <code>fs</code>, <code>es</code>, and <code>ds</code> fields are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55aab6d4add027b8667770e914b21e22471" name="a2a503f0a39ec98188b60178edbc1fc55aab6d4add027b8667770e914b21e22471"></a>kMinidumpContextX86FloatingPoint&#160;</td><td class="fielddoc"><p>Indicates the validity of floating-point state (<code>CONTEXT_FLOATING_POINT</code>). </p>
<p>The <code>fsave</code> field is valid. The <code>float_save</code> field is included in this definition, but its members have no practical use asdie from <code>fsave</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55a9cab86cf2d37ab8bc0f6ec0fa9a1442e" name="a2a503f0a39ec98188b60178edbc1fc55a9cab86cf2d37ab8bc0f6ec0fa9a1442e"></a>kMinidumpContextX86Debug&#160;</td><td class="fielddoc"><p>Indicates the validity of debug registers (<code>CONTEXT_DEBUG_REGISTERS</code>). </p>
<p>The <code>dr0</code> through <code>dr3</code>, <code>dr6</code>, and <code>dr7</code> fields are valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55afbe5d3708e41ca9b92a6d3acb6f6f322" name="a2a503f0a39ec98188b60178edbc1fc55afbe5d3708e41ca9b92a6d3acb6f6f322"></a>kMinidumpContextX86Extended&#160;</td><td class="fielddoc"><p>Indicates the validity of extended registers in <code>fxsave</code> format (<code>CONTEXT_EXTENDED_REGISTERS</code>). </p>
<p>The <code>extended_registers</code> field is valid and contains <code>fxsave</code> data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55a2e59094ad192c7388e85ca768d741dd4" name="a2a503f0a39ec98188b60178edbc1fc55a2e59094ad192c7388e85ca768d741dd4"></a>kMinidumpContextX86Xstate&#160;</td><td class="fielddoc"><p>Indicates the validity of <code>xsave</code> data (<code>CONTEXT_XSTATE</code>). </p>
<p>The context contains <code>xsave</code> data. This is used with an extended context structure not currently defined here. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55a8dd8413af4852a4ca699b17a4d39d7bd" name="a2a503f0a39ec98188b60178edbc1fc55a8dd8413af4852a4ca699b17a4d39d7bd"></a>kMinidumpContextX86Full&#160;</td><td class="fielddoc"><p>Indicates the validity of control, integer, and segment registers. (<code>CONTEXT_FULL</code>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a503f0a39ec98188b60178edbc1fc55a49dd96e7cd1bb82c676a38eece63d63f" name="a2a503f0a39ec98188b60178edbc1fc55a49dd96e7cd1bb82c676a38eece63d63f"></a>kMinidumpContextX86All&#160;</td><td class="fielddoc"><p>Indicates the validity of all registers except <code>xsave</code> data. (<code>CONTEXT_ALL</code>). </p>
</td></tr>
</table>

</div>
</div>
<a id="a98e532bb06fc5ffdd93e0ceb6d789eb1" name="a98e532bb06fc5ffdd93e0ceb6d789eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e532bb06fc5ffdd93e0ceb6d789eb1">&#9670;&#160;</a></span>MinidumpCPUArchitecture</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a98e532bb06fc5ffdd93e0ceb6d789eb1">crashpad::MinidumpCPUArchitecture</a> : uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CPU type values for <a class="el" href="structMINIDUMP__SYSTEM__INFO.html#adc85b29d7df8943baf1a96af23051ca8" title="The system’s CPU architecture. This may be a PROCESSOR_ARCHITECTURE_* value, or a member of crashpad:...">MINIDUMP_SYSTEM_INFO::ProcessorArchitecture</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="winnt_8h.html#PROCESSOR_ARCHITECTURE_x">PROCESSOR_ARCHITECTURE_*</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1a667f84537acd054ce17f527bcd41c885" name="a98e532bb06fc5ffdd93e0ceb6d789eb1a667f84537acd054ce17f527bcd41c885"></a>kMinidumpCPUArchitectureX86&#160;</td><td class="fielddoc"><p>32-bit x86. </p>
<p>These systems identify their CPUs generically as “x86” or “ia32”, or with more specific names such as “i386”, “i486”, “i586”, and “i686”. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1a37feeb34e5df713f24a65f8687d23def" name="a98e532bb06fc5ffdd93e0ceb6d789eb1a37feeb34e5df713f24a65f8687d23def"></a>kMinidumpCPUArchitecturePPC&#160;</td><td class="fielddoc"><p>32-bit PowerPC. </p>
<p>These systems identify their CPUs generically as “ppc”, or with more specific names such as “ppc6xx”, “ppc7xx”, and “ppc74xx”. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1a8ab29cb3332c3c583c4d60b2c308361c" name="a98e532bb06fc5ffdd93e0ceb6d789eb1a8ab29cb3332c3c583c4d60b2c308361c"></a>kMinidumpCPUArchitectureARM&#160;</td><td class="fielddoc"><p>32-bit ARM. </p>
<p>These systems identify their CPUs generically as “arm”, or with more specific names such as “armv6” and “armv7”. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1a74c0fcddcbf1502d7dedc7cd965550df" name="a98e532bb06fc5ffdd93e0ceb6d789eb1a74c0fcddcbf1502d7dedc7cd965550df"></a>kMinidumpCPUArchitectureAMD64&#160;</td><td class="fielddoc"><p>64-bit x86. </p>
<p>These systems identify their CPUs as “x86_64”, “amd64”, or “x64”. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1a492f53b6303f91d08192bbfb9341e3cb" name="a98e532bb06fc5ffdd93e0ceb6d789eb1a492f53b6303f91d08192bbfb9341e3cb"></a>kMinidumpCPUArchitectureX86Win64&#160;</td><td class="fielddoc"><p>A 32-bit x86 process running on IA-64 (Itanium). </p>
<dl class="section note"><dt>Note</dt><dd>This value is not used in minidump files for 32-bit x86 processes running on a 64-bit-capable x86 CPU and operating system. In that configuration, <a class="el" href="#a98e532bb06fc5ffdd93e0ceb6d789eb1a667f84537acd054ce17f527bcd41c885" title="32-bit x86.">kMinidumpCPUArchitectureX86</a> is used instead. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1aa58a9c127a74412bdcbce29f0ac6d9f5" name="a98e532bb06fc5ffdd93e0ceb6d789eb1aa58a9c127a74412bdcbce29f0ac6d9f5"></a>kMinidumpCPUArchitectureARM64&#160;</td><td class="fielddoc"><p>64-bit ARM. </p>
<p>These systems identify their CPUs generically as “arm64” or “aarch64”, or with more specific names such as “armv8”.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a98e532bb06fc5ffdd93e0ceb6d789eb1af06c5024168bed0a96de94e665ba2e70" title="Used by Breakpad for 64-bit ARM.">kMinidumpCPUArchitectureARM64Breakpad</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1a96f1b70341467cfcaabaac225345716b" name="a98e532bb06fc5ffdd93e0ceb6d789eb1a96f1b70341467cfcaabaac225345716b"></a>kMinidumpCPUArchitecturePPC64&#160;</td><td class="fielddoc"><p>64-bit PowerPC. </p>
<p>These systems identify their CPUs generically as “ppc64”, or with more specific names such as “ppc970”. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1af06c5024168bed0a96de94e665ba2e70" name="a98e532bb06fc5ffdd93e0ceb6d789eb1af06c5024168bed0a96de94e665ba2e70"></a>kMinidumpCPUArchitectureARM64Breakpad&#160;</td><td class="fielddoc"><p>Used by Breakpad for 64-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1ae8dad33bd7c3694959d3f01661e51016" name="a98e532bb06fc5ffdd93e0ceb6d789eb1ae8dad33bd7c3694959d3f01661e51016"></a>kMinidumpCPUArchitectureRISCV64Breakpad&#160;</td><td class="fielddoc"><p>Used by Breakpad for 64-bit RISC-V. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98e532bb06fc5ffdd93e0ceb6d789eb1a1d0ecd96474945b642af3568bc43ab92" name="a98e532bb06fc5ffdd93e0ceb6d789eb1a1d0ecd96474945b642af3568bc43ab92"></a>kMinidumpCPUArchitectureUnknown&#160;</td><td class="fielddoc"><p>Unknown CPU architecture. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9be77c6f7868f00c2f279006a1abe26a" name="a9be77c6f7868f00c2f279006a1abe26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be77c6f7868f00c2f279006a1abe26a">&#9670;&#160;</a></span>MinidumpOS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9be77c6f7868f00c2f279006a1abe26a">crashpad::MinidumpOS</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operating system family values for <a class="el" href="structMINIDUMP__SYSTEM__INFO.html#a214e7bd61a89343a80a3c9a265fbbe96" title="The system’s operating system family. This may be a VER_PLATFORM_* value, or a member of crashpad::Mi...">MINIDUMP_SYSTEM_INFO::PlatformId</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="winnt_8h.html#VER_PLATFORM_x">VER_PLATFORM_*</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aaca1cab5b93dabab4c83400fd74dc61f9" name="a9be77c6f7868f00c2f279006a1abe26aaca1cab5b93dabab4c83400fd74dc61f9"></a>kMinidumpOSWin32s&#160;</td><td class="fielddoc"><p>Windows 3.1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aa652417bb9221b48e7086f8b5e7055e72" name="a9be77c6f7868f00c2f279006a1abe26aa652417bb9221b48e7086f8b5e7055e72"></a>kMinidumpOSWin32Windows&#160;</td><td class="fielddoc"><p>Windows 95, Windows 98, and Windows Me. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aa00fdfb21197a2b114e5ffeb51f53e3df" name="a9be77c6f7868f00c2f279006a1abe26aa00fdfb21197a2b114e5ffeb51f53e3df"></a>kMinidumpOSWin32NT&#160;</td><td class="fielddoc"><p>Windows NT, Windows 2000, and later. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aa03b20aa69a12cad7a9c08b3335b309d3" name="a9be77c6f7868f00c2f279006a1abe26aa03b20aa69a12cad7a9c08b3335b309d3"></a>kMinidumpOSMacOSX&#160;</td><td class="fielddoc"><p>macOS, Darwin for traditional systems. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aaa2bd6cb000781ac60ed0b769cd8fb524" name="a9be77c6f7868f00c2f279006a1abe26aaa2bd6cb000781ac60ed0b769cd8fb524"></a>kMinidumpOSIOS&#160;</td><td class="fielddoc"><p>iOS, Darwin for mobile devices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aa126dc921b6c301f5ce7d111a29b72d4f" name="a9be77c6f7868f00c2f279006a1abe26aa126dc921b6c301f5ce7d111a29b72d4f"></a>kMinidumpOSLinux&#160;</td><td class="fielddoc"><p>Linux, not including Android. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aa071bb71519a869fa5cf7004114b979d9" name="a9be77c6f7868f00c2f279006a1abe26aa071bb71519a869fa5cf7004114b979d9"></a>kMinidumpOSAndroid&#160;</td><td class="fielddoc"><p>Android. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aaf352d155051b508a5452a18e29f473bb" name="a9be77c6f7868f00c2f279006a1abe26aaf352d155051b508a5452a18e29f473bb"></a>kMinidumpOSNaCl&#160;</td><td class="fielddoc"><p>Native Client (NaCl). </p>
</td></tr>
<tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aa294f08220dc09d02f03b25db81b8c5cf" name="a9be77c6f7868f00c2f279006a1abe26aa294f08220dc09d02f03b25db81b8c5cf"></a>kMinidumpOSFuchsia&#160;</td><td class="fielddoc"><p>Fuchsia. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9be77c6f7868f00c2f279006a1abe26aa7f4f96b9f35fbad451bb4c09cedfba07" name="a9be77c6f7868f00c2f279006a1abe26aa7f4f96b9f35fbad451bb4c09cedfba07"></a>kMinidumpOSUnknown&#160;</td><td class="fielddoc"><p>Unknown operating system. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3bf5a6562c9ccee9b4ef3ae4d9ac0be7" name="a3bf5a6562c9ccee9b4ef3ae4d9ac0be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf5a6562c9ccee9b4ef3ae4d9ac0be7">&#9670;&#160;</a></span>MinidumpOSType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a3bf5a6562c9ccee9b4ef3ae4d9ac0be7">crashpad::MinidumpOSType</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operating system type values for <a class="el" href="structMINIDUMP__SYSTEM__INFO.html#a9aac8ed4707ea43563fed1776454bad5" title="The system’s operating system type, which distinguishes between “desktop” or “workstation” systems an...">MINIDUMP_SYSTEM_INFO::ProductType</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="winnt_8h.html#VER_NT_x">VER_NT_*</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3bf5a6562c9ccee9b4ef3ae4d9ac0be7a622c5cb563f37f8861f7c58e3ec64a05" name="a3bf5a6562c9ccee9b4ef3ae4d9ac0be7a622c5cb563f37f8861f7c58e3ec64a05"></a>kMinidumpOSTypeWorkstation&#160;</td><td class="fielddoc"><p>A “desktop” or “workstation” system. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3bf5a6562c9ccee9b4ef3ae4d9ac0be7a4d37fbae0e055c62b5bfe36797b8a592" name="a3bf5a6562c9ccee9b4ef3ae4d9ac0be7a4d37fbae0e055c62b5bfe36797b8a592"></a>kMinidumpOSTypeDomainController&#160;</td><td class="fielddoc"><p>A “domain controller” system. Windows-specific. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3bf5a6562c9ccee9b4ef3ae4d9ac0be7aaf31279bbe240bb77304d8d0f4a8f949" name="a3bf5a6562c9ccee9b4ef3ae4d9ac0be7aaf31279bbe240bb77304d8d0f4a8f949"></a>kMinidumpOSTypeServer&#160;</td><td class="fielddoc"><p>A “server” system. </p>
</td></tr>
</table>

</div>
</div>
<a id="a88363a45a4af1a16f542a8c1ff522ab9" name="a88363a45a4af1a16f542a8c1ff522ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88363a45a4af1a16f542a8c1ff522ab9">&#9670;&#160;</a></span>MinidumpStreamType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a88363a45a4af1a16f542a8c1ff522ab9">crashpad::MinidumpStreamType</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minidump stream type values for <a class="el" href="structMINIDUMP__DIRECTORY.html#a425b8b68da6810a126c759c5f5a94f7d" title="The type of stream referenced, a value of MINIDUMP_STREAM_TYPE.">MINIDUMP_DIRECTORY::StreamType</a>. Each stream structure has a corresponding stream type value to identify it. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08" title="Minidump stream type values for MINIDUMP_DIRECTORY::StreamType. Each stream structure has a correspon...">MINIDUMP_STREAM_TYPE</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9af87c478a3f2ce198936d817e98d87531" name="a88363a45a4af1a16f542a8c1ff522ab9af87c478a3f2ce198936d817e98d87531"></a>kMinidumpStreamTypeThreadList&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structMINIDUMP__THREAD__LIST.html" title="Information about all threads within the process.">MINIDUMP_THREAD_LIST</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08a4dd234223e39c89f93aabce77e649d2c" title="The stream type for MINIDUMP_THREAD_LIST.">ThreadListStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9a226cb7d075ec01c79f233d098e9a9e3f" name="a88363a45a4af1a16f542a8c1ff522ab9a226cb7d075ec01c79f233d098e9a9e3f"></a>kMinidumpStreamTypeModuleList&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structMINIDUMP__MODULE__LIST.html" title="Information about all modules loaded within the process at the time the snapshot was taken.">MINIDUMP_MODULE_LIST</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08ad404c18554f01aa57ac0af1a7674060b" title="The stream type for MINIDUMP_MODULE_LIST.">ModuleListStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9ac9923e6a5c46946ba2cdc8ce4272c181" name="a88363a45a4af1a16f542a8c1ff522ab9ac9923e6a5c46946ba2cdc8ce4272c181"></a>kMinidumpStreamTypeMemoryList&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structMINIDUMP__MEMORY__LIST.html" title="Information about memory regions within the process.">MINIDUMP_MEMORY_LIST</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08a1511624630cd9150436de906ae033cbd" title="The stream type for MINIDUMP_MEMORY_LIST.">MemoryListStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9a445b370a989c63b41f4080c2584912e7" name="a88363a45a4af1a16f542a8c1ff522ab9a445b370a989c63b41f4080c2584912e7"></a>kMinidumpStreamTypeException&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structMINIDUMP__EXCEPTION__STREAM.html" title="Information about the exception that triggered a minidump file’s generation.">MINIDUMP_EXCEPTION_STREAM</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08a5ddc831e2440dfcfd112cb19401bbd60" title="The stream type for MINIDUMP_EXCEPTION_STREAM.">ExceptionStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9a57ae6ef428bb48fdc877d92bc8046bd3" name="a88363a45a4af1a16f542a8c1ff522ab9a57ae6ef428bb48fdc877d92bc8046bd3"></a>kMinidumpStreamTypeSystemInfo&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structMINIDUMP__SYSTEM__INFO.html" title="Information about the system that hosted the process that the minidump file contains a snapshot of.">MINIDUMP_SYSTEM_INFO</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08a36ca9398c8a42fa4ec2b4baf9c3d3474" title="The stream type for MINIDUMP_SYSTEM_INFO.">SystemInfoStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9a956e21d34f0d97aa5b3b640b1676ef37" name="a88363a45a4af1a16f542a8c1ff522ab9a956e21d34f0d97aa5b3b640b1676ef37"></a>kMinidumpStreamTypeHandleData&#160;</td><td class="fielddoc"><p>The stream type for MINIDUMP_HANDLE_DATA_STREAM. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08ad7775c9c100abafc1b864499acf84757" title="The stream contains information about active HANDLEs.">HandleDataStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9afab92691d30e4386b008dab71fe359f6" name="a88363a45a4af1a16f542a8c1ff522ab9afab92691d30e4386b008dab71fe359f6"></a>kMinidumpStreamTypeUnloadedModuleList&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structMINIDUMP__UNLOADED__MODULE__LIST.html" title="Information about all modules recorded as unloaded when the snapshot was taken.">MINIDUMP_UNLOADED_MODULE_LIST</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08ac9a369c7cfd7b0c05208e4af380c4bba" title="The stream type for MINIDUMP_UNLOADED_MODULE_LIST.">UnloadedModuleListStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9a631532de9316c7cb41cf27b2df2f802f" name="a88363a45a4af1a16f542a8c1ff522ab9a631532de9316c7cb41cf27b2df2f802f"></a>kMinidumpStreamTypeMiscInfo&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structMINIDUMP__MISC__INFO.html" title="Information about the process that the minidump file contains a snapshot of, as well as the system th...">MINIDUMP_MISC_INFO</a>, <a class="el" href="structMINIDUMP__MISC__INFO__2.html" title="Information about the process that the minidump file contains a snapshot of, as well as the system th...">MINIDUMP_MISC_INFO_2</a>, <a class="el" href="structMINIDUMP__MISC__INFO__3.html" title="Information about the process that the minidump file contains a snapshot of, as well as the system th...">MINIDUMP_MISC_INFO_3</a>, and <a class="el" href="structMINIDUMP__MISC__INFO__4.html" title="Information about the process that the minidump file contains a snapshot of, as well as the system th...">MINIDUMP_MISC_INFO_4</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08a02e9fb2f037d09f1cdb4eb0c9f115b33" title="The stream type for MINIDUMP_MISC_INFO, MINIDUMP_MISC_INFO_2, MINIDUMP_MISC_INFO_3,...">MiscInfoStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9ab6f692da21dc09fb3c17a186fdc3271b" name="a88363a45a4af1a16f542a8c1ff522ab9ab6f692da21dc09fb3c17a186fdc3271b"></a>kMinidumpStreamTypeMemoryInfoList&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structMINIDUMP__MEMORY__INFO__LIST.html" title="Contains a list of memory regions.">MINIDUMP_MEMORY_INFO_LIST</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08ab3437fce4862d62ca22f4933cada4d43" title="The stream type for MINIDUMP_MEMORY_INFO_LIST.">MemoryInfoListStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9a7b11413deb5c30ae0520c7280e4e2209" name="a88363a45a4af1a16f542a8c1ff522ab9a7b11413deb5c30ae0520c7280e4e2209"></a>kMinidumpStreamTypeThreadNameList&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structMINIDUMP__THREAD__NAME__LIST.html" title="Variable-sized struct which contains a list of MINIDUMP_THREAD_NAME structs.">MINIDUMP_THREAD_NAME_LIST</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08a48eadbd0e4d5fad1e60632f31dd0fea1" title="The stream type for MINIDUMP_THREAD_NAME_LIST.">ThreadNamesStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9a1733d8eaab5c094b526725b95f6953e8" name="a88363a45a4af1a16f542a8c1ff522ab9a1733d8eaab5c094b526725b95f6953e8"></a>kMinidumpStreamTypeLastReservedStream&#160;</td><td class="fielddoc"><p>The last reserved minidump stream. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dbghelp_8h.html#a64711234318a4a002f399dffb474ca08ab3437fce4862d62ca22f4933cada4d43" title="The stream type for MINIDUMP_MEMORY_INFO_LIST.">MemoryInfoListStream</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9af1056a1f748bba4c88fa8f4104771d00" name="a88363a45a4af1a16f542a8c1ff522ab9af1056a1f748bba4c88fa8f4104771d00"></a>kMinidumpStreamTypeCrashpadInfo&#160;</td><td class="fielddoc"><p>The stream type for <a class="el" href="structcrashpad_1_1MinidumpCrashpadInfo.html" title="Additional Crashpad-specific information carried within a minidump file.">MinidumpCrashpadInfo</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88363a45a4af1a16f542a8c1ff522ab9ad1eb36ce2b22223914b2479a450304a9" name="a88363a45a4af1a16f542a8c1ff522ab9ad1eb36ce2b22223914b2479a450304a9"></a>kMinidumpStreamTypeCrashpadLastReservedStream&#160;</td><td class="fielddoc"><p>The last reserved crashpad stream. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab96bb7edb42a2e1ce28eda205a18a17a" name="ab96bb7edb42a2e1ce28eda205a18a17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96bb7edb42a2e1ce28eda205a18a17a">&#9670;&#160;</a></span>ProcessSuspensionState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ab96bb7edb42a2e1ce28eda205a18a17a">crashpad::ProcessSuspensionState</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State of process being read by <a class="el" href="classcrashpad_1_1ProcessReaderWin.html" title="Accesses information about another process, identified by a HANDLE.">ProcessReaderWin</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab96bb7edb42a2e1ce28eda205a18a17aa2fc7fbf0d19294f85dd3880460dd3c0a" name="ab96bb7edb42a2e1ce28eda205a18a17aa2fc7fbf0d19294f85dd3880460dd3c0a"></a>kRunning&#160;</td><td class="fielddoc"><p>The process has not been suspended. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab96bb7edb42a2e1ce28eda205a18a17aa6e09d95243f1f7bec7d0061e5831dc82" name="ab96bb7edb42a2e1ce28eda205a18a17aa6e09d95243f1f7bec7d0061e5831dc82"></a>kSuspended&#160;</td><td class="fielddoc"><p>The process is suspended. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8402ddae562db04a8daf6bffecaded5b" name="a8402ddae562db04a8daf6bffecaded5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8402ddae562db04a8daf6bffecaded5b">&#9670;&#160;</a></span>StdioStream</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8402ddae562db04a8daf6bffecaded5b">crashpad::StdioStream</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> that <a class="el" href="#ac6eccc3b9b90d2dd74048a43c9002e88" title="Returns a FileHandle corresponding to the requested standard I/O stream.">StdioFileHandle()</a> returns. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8402ddae562db04a8daf6bffecaded5ba9ce2feb67c200b9dec30fdec04ef32e2" name="a8402ddae562db04a8daf6bffecaded5ba9ce2feb67c200b9dec30fdec04ef32e2"></a>kStandardInput&#160;</td><td class="fielddoc"><p>Standard input, or <code>stdin</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8402ddae562db04a8daf6bffecaded5ba59d7b68e88996f02ef0d89547ae4d127" name="a8402ddae562db04a8daf6bffecaded5ba59d7b68e88996f02ef0d89547ae4d127"></a>kStandardOutput&#160;</td><td class="fielddoc"><p>Standard output, or <code>stdout</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8402ddae562db04a8daf6bffecaded5ba6012275f61c3c1fff0012cf9c9e646b0" name="a8402ddae562db04a8daf6bffecaded5ba6012275f61c3c1fff0012cf9c9e646b0"></a>kStandardError&#160;</td><td class="fielddoc"><p>Standard error, or <code>stderr</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8387ad067a7e6a1735ab97a1af450d2b" name="a8387ad067a7e6a1735ab97a1af450d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8387ad067a7e6a1735ab97a1af450d2b">&#9670;&#160;</a></span>StringToSymbolicConstantOptionBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a8387ad067a7e6a1735ab97a1af450d2b">crashpad::StringToSymbolicConstantOptionBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options for various <code>StringTo*</code> functions in <code>symbolic_constants_*</code> files. </p>
<p>Not every <code>StringTo*</code> function will implement each of these options. See function-specific documentation for details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="symbolic__constants__common_8h.html#symbolic_constant_terminology">Symbolic constant terminology</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8387ad067a7e6a1735ab97a1af450d2ba1ca8cfec5f4774db61b0359f6905cb49" name="a8387ad067a7e6a1735ab97a1af450d2ba1ca8cfec5f4774db61b0359f6905cb49"></a>kAllowFullName&#160;</td><td class="fielddoc"><p>Allow conversion from a string containing a symbolic constant by its full name. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8387ad067a7e6a1735ab97a1af450d2ba56cf2e379949ef54954bf3d23ca38e85" name="a8387ad067a7e6a1735ab97a1af450d2ba56cf2e379949ef54954bf3d23ca38e85"></a>kAllowShortName&#160;</td><td class="fielddoc"><p>Allow conversion from a string containing a symbolic constant by its short name. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8387ad067a7e6a1735ab97a1af450d2ba9021a9f07e3e4eb819ac567dd4d28b6f" name="a8387ad067a7e6a1735ab97a1af450d2ba9021a9f07e3e4eb819ac567dd4d28b6f"></a>kAllowNumber&#160;</td><td class="fielddoc"><p>Allow conversion from a numeric string. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8387ad067a7e6a1735ab97a1af450d2ba060cbf403d47785a69b249e9c562f410" name="a8387ad067a7e6a1735ab97a1af450d2ba060cbf403d47785a69b249e9c562f410"></a>kAllowOr&#160;</td><td class="fielddoc"><p>Allow <code>|</code> to combine values in a bitfield. </p>
<p>For families whose values may be constructed as bitfields, allow conversion of strings containing multiple individual components treated as being combined by a bitwise “or” operation. An example family of constants that behaves this way is the suite of Mach exception masks. For constants that are not constructed as bitfields, or constants that are only partially constructed as bitfields, this option has no effect. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7856b82b71167792ea6103debb5105ed" name="a7856b82b71167792ea6103debb5105ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7856b82b71167792ea6103debb5105ed">&#9670;&#160;</a></span>SymbolicConstantToStringOptionBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a7856b82b71167792ea6103debb5105ed">crashpad::SymbolicConstantToStringOptionBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options for various <code>*ToString</code> functions in <code>symbolic_constants_*</code> files. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="symbolic__constants__common_8h.html#symbolic_constant_terminology">Symbolic constant terminology</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7856b82b71167792ea6103debb5105edad497286630d39fe9b19c950a85c56db7" name="a7856b82b71167792ea6103debb5105edad497286630d39fe9b19c950a85c56db7"></a>kUseFullName&#160;</td><td class="fielddoc"><p>Return the full name for a given constant. </p>
<dl class="section attention"><dt>Attention</dt><dd>API consumers should provide this value when desired, but should provide only one of kUseFullName and <a class="el" href="#a7856b82b71167792ea6103debb5105eda127e077880ede5d2f87b87873d46ea55" title="Return the short name for a given constant.">kUseShortName</a>. Because kUseFullName is valueless, implementers should check for the absence of <a class="el" href="#a7856b82b71167792ea6103debb5105eda127e077880ede5d2f87b87873d46ea55" title="Return the short name for a given constant.">kUseShortName</a> instead. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a7856b82b71167792ea6103debb5105eda127e077880ede5d2f87b87873d46ea55" name="a7856b82b71167792ea6103debb5105eda127e077880ede5d2f87b87873d46ea55"></a>kUseShortName&#160;</td><td class="fielddoc"><p>Return the short name for a given constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7856b82b71167792ea6103debb5105eda6fd207e044b85ec202143881fcd5eb2e" name="a7856b82b71167792ea6103debb5105eda6fd207e044b85ec202143881fcd5eb2e"></a>kUnknownIsEmpty&#160;</td><td class="fielddoc"><p>If no symbolic name is known for a given constant, return an empty string. </p>
<dl class="section attention"><dt>Attention</dt><dd>API consumers should provide this value when desired, but should provide only one of kUnknownIsEmpty and <a class="el" href="#a7856b82b71167792ea6103debb5105edaf9da07820c9857c86422b70c3cc33c12" title="If no symbolic name is known for a given constant, return a numeric string.">kUnknownIsNumeric</a>. Because kUnknownIsEmpty is valueless, implementers should check for the absence of <a class="el" href="#a7856b82b71167792ea6103debb5105edaf9da07820c9857c86422b70c3cc33c12" title="If no symbolic name is known for a given constant, return a numeric string.">kUnknownIsNumeric</a> instead. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a7856b82b71167792ea6103debb5105edaf9da07820c9857c86422b70c3cc33c12" name="a7856b82b71167792ea6103debb5105edaf9da07820c9857c86422b70c3cc33c12"></a>kUnknownIsNumeric&#160;</td><td class="fielddoc"><p>If no symbolic name is known for a given constant, return a numeric string. </p>
<p>The numeric format used will vary by family, but will be appropriate to the family. Families whose values are typically constructed as bitfields will generally use a hexadecimal format, and other families will generally use a signed or unsigned decimal format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7856b82b71167792ea6103debb5105eda18aa149c3471a5129274df2af6972f04" name="a7856b82b71167792ea6103debb5105eda18aa149c3471a5129274df2af6972f04"></a>kUseOr&#160;</td><td class="fielddoc"><p>Use <code>|</code> to combine values in a bitfield. </p>
<p>For families whose values may be constructed as bitfields, allow conversion to strings containing multiple individual components treated as being combined by a bitwise “or” operation. An example family of constants that behaves this way is the suite of Mach exception masks. For constants that are not constructed as bitfields, or constants that are only partially constructed as bitfields, this option has no effect. </p>
</td></tr>
</table>

</div>
</div>
<a id="acf909fcc58999f95ab1a2d485a3b884f" name="acf909fcc58999f95ab1a2d485a3b884f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf909fcc58999f95ab1a2d485a3b884f">&#9670;&#160;</a></span>TerminationCodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#acf909fcc58999f95ab1a2d485a3b884f">crashpad::TerminationCodes</a> : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crashpad-specific codes that are used as arguments to <a class="el" href="#ad8efd0f50febdf3c8461fb93de8191f7" title="Calls TerminateProcess().">SafeTerminateProcess()</a> or <code>TerminateProcess()</code> in unusual circumstances. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acf909fcc58999f95ab1a2d485a3b884fa80056c7b41974ff409381f83677977fb" name="acf909fcc58999f95ab1a2d485a3b884fa80056c7b41974ff409381f83677977fb"></a>kTerminationCodeCrashNoDump&#160;</td><td class="fielddoc"><p>The crash handler did not respond, and the client self-terminated. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf909fcc58999f95ab1a2d485a3b884fa360db709d75512a0e6b8a27b9b122910" name="acf909fcc58999f95ab1a2d485a3b884fa360db709d75512a0e6b8a27b9b122910"></a>kTerminationCodeSnapshotFailed&#160;</td><td class="fielddoc"><p>The initial process snapshot failed, so the correct client termination code could not be retrieved. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf909fcc58999f95ab1a2d485a3b884fa3110b7733dd8d446957e061cb8fb37d2" name="acf909fcc58999f95ab1a2d485a3b884fa3110b7733dd8d446957e061cb8fb37d2"></a>kTerminationCodeNotConnectedToHandler&#160;</td><td class="fielddoc"><p>A dump was requested for a client that was never registered with the crash handler. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3b405c19a5787fabcfba96001d49f292" name="a3b405c19a5787fabcfba96001d49f292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b405c19a5787fabcfba96001d49f292">&#9670;&#160;</a></span>TriState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a3b405c19a5787fabcfba96001d49f292">crashpad::TriState</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A tri-state value that can be unset, on, or off. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3b405c19a5787fabcfba96001d49f292ac69d34d47bfd5244204004878441d53f" name="a3b405c19a5787fabcfba96001d49f292ac69d34d47bfd5244204004878441d53f"></a>kUnset&#160;</td><td class="fielddoc"><p>The value has not explicitly been set. </p>
<p>To allow a zero-initialized value to have this behavior, this must have the value <code>0</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b405c19a5787fabcfba96001d49f292ade1ec1870756a80dffbdc4cda53153e0" name="a3b405c19a5787fabcfba96001d49f292ade1ec1870756a80dffbdc4cda53153e0"></a>kEnabled&#160;</td><td class="fielddoc"><p>The value has explicitly been set to on, or a behavior has explicitly been enabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b405c19a5787fabcfba96001d49f292a7b04d8795f5fd03c761ce70dab985fee" name="a3b405c19a5787fabcfba96001d49f292a7b04d8795f5fd03c761ce70dab985fee"></a>kDisabled&#160;</td><td class="fielddoc"><p>The value has explicitly been set to off, or a behavior has explicitly been disabled. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8acaf90af42afce7536ea74c1cf32258" name="a8acaf90af42afce7536ea74c1cf32258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acaf90af42afce7536ea74c1cf32258">&#9670;&#160;</a></span>UploadBehavior</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8acaf90af42afce7536ea74c1cf32258">crashpad::UploadBehavior</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum to control upload behavior when processing pending reports. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8acaf90af42afce7536ea74c1cf32258a3827652cb700b6d3d2cdf18d69c52979" name="a8acaf90af42afce7536ea74c1cf32258a3827652cb700b6d3d2cdf18d69c52979"></a>kUploadWhenAppIsActive&#160;</td><td class="fielddoc"><p>Only upload reports while the application is active (e.g., in the foreground). </p>
</td></tr>
<tr><td class="fieldname"><a id="a8acaf90af42afce7536ea74c1cf32258a74148e642effa896e425f1c517fcce07" name="a8acaf90af42afce7536ea74c1cf32258a74148e642effa896e425f1c517fcce07"></a>kUploadImmediately&#160;</td><td class="fielddoc"><p>Upload reports immediately, regardless of whether or not the application is active. </p>
</td></tr>
</table>

</div>
</div>
<a id="a589b4d9bd6f2233b67148ab6793c3c13" name="a589b4d9bd6f2233b67148ab6793c3c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589b4d9bd6f2233b67148ab6793c3c13">&#9670;&#160;</a></span>XattrStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">crashpad::XattrStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The result code for a ReadXattr operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a589b4d9bd6f2233b67148ab6793c3c13ab8c5bbba307a5b38f6a1474fbf23dddd" name="a589b4d9bd6f2233b67148ab6793c3c13ab8c5bbba307a5b38f6a1474fbf23dddd"></a>kOK&#160;</td><td class="fielddoc"><p>No error occured. No message is logged. </p>
</td></tr>
<tr><td class="fieldname"><a id="a589b4d9bd6f2233b67148ab6793c3c13a56b68c332155feb30564a8ebd779ba67" name="a589b4d9bd6f2233b67148ab6793c3c13a56b68c332155feb30564a8ebd779ba67"></a>kNoAttribute&#160;</td><td class="fielddoc"><p>The attribute does not exist. No message is logged. </p>
</td></tr>
<tr><td class="fieldname"><a id="a589b4d9bd6f2233b67148ab6793c3c13a298223b78cd88f4983fbc5ae093136ca" name="a589b4d9bd6f2233b67148ab6793c3c13a298223b78cd88f4983fbc5ae093136ca"></a>kOtherError&#160;</td><td class="fielddoc"><p>An error occurred and an error message was logged. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af0004297cf46f8fd00258e02a4bcf13a" name="af0004297cf46f8fd00258e02a4bcf13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0004297cf46f8fd00258e02a4bcf13a">&#9670;&#160;</a></span>AddUserExtensionStreams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::AddUserExtensionStreams </td>
          <td>(</td>
          <td class="paramtype">const UserStreamDataSources *</td>          <td class="paramname"><span class="paramname"><em>user_stream_data_sources</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1ProcessSnapshot.html">ProcessSnapshot</a> *</td>          <td class="paramname"><span class="paramname"><em>process_snapshot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1MinidumpFileWriter.html">MinidumpFileWriter</a> *</td>          <td class="paramname"><span class="paramname"><em>minidump_file_writer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds user extension streams to a minidump. </p>
<p>Dispatches to each source in <em class="arg">user_stream_data_sources</em> and adds returned extension streams to <em class="arg">minidump_file_writer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_stream_data_sources</td><td>A pointer to the data sources, or <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">process_snapshot</td><td>An initialized snapshot to the crashing process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minidump_file_writer</td><td>Any extension streams will be added to this minidump. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a2aeb6f5cc4e5b302c6da3141e1b9c4" name="a2a2aeb6f5cc4e5b302c6da3141e1b9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2aeb6f5cc4e5b302c6da3141e1b9c4">&#9670;&#160;</a></span>AdvancePastNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::AdvancePastNumber </td>
          <td>(</td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a prefix of a char string to a numeric value. </p>
<p>Valid values are positive or negative decimal numbers, matching the regular expression "-?\d+", and within the limits of T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">input</td><td>A pointer to the char string to match against. <em class="arg">input</em> is advanced past the number if one is found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The converted number, if one is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a number is found at the start of <em class="arg">input</em> and <em class="arg">input</em> is advanced, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ad37351a34cc3b9282a1f590062b5368d" name="ad37351a34cc3b9282a1f590062b5368d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37351a34cc3b9282a1f590062b5368d">&#9670;&#160;</a></span>AdvancePastPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::AdvancePastPrefix </td>
          <td>(</td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match a pattern at the start of a char string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">input</td><td>A pointer to the char string to match against. <em class="arg">input</em> is advanced past the matched pattern if it is found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The pattern to match at the start of <em class="arg">input</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pattern is matched exactly and <em class="arg">input</em> is advanced, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ab8be7196ea1ef43c438be47b1f3bbf57" name="ab8be7196ea1ef43c438be47b1f3bbf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8be7196ea1ef43c438be47b1f3bbf57">&#9670;&#160;</a></span>AlignedAllocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * crashpad::AlignedAllocate </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory with the specified alignment constraint. </p>
<p>This function wraps <code>posix_memalign()</code> or <code>_aligned_malloc()</code>. Memory allocated by this function must be released by AlignFree(). </p>

</div>
</div>
<a id="a4d4cc77fb390eed171c11c6e06b78c85" name="a4d4cc77fb390eed171c11c6e06b78c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4cc77fb390eed171c11c6e06b78c85">&#9670;&#160;</a></span>AlignedFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::AlignedFree </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>pointer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated by <a class="el" href="#ab8be7196ea1ef43c438be47b1f3bbf57" title="Allocates memory with the specified alignment constraint.">AlignedAllocate()</a>. </p>
<p>This function wraps <code>free()</code> or <code>_aligned_free()</code>. </p>

</div>
</div>
<a id="a52a7dee343e392e5bf1794e8136df7f9" name="a52a7dee343e392e5bf1794e8136df7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a7dee343e392e5bf1794e8136df7f9">&#9670;&#160;</a></span>AppendCommandLineArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::AppendCommandLineArgument </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>argument</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring *</td>          <td class="paramname"><span class="paramname"><em>command_line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for building escaped command lines. </p>
<p>This builds a command line so that individual arguments can be reliably decoded by <code>CommandLineToArgvW()</code>.</p>
<p><em class="arg">argument</em> is appended to <em class="arg">command_line</em>. If necessary, it will be placed in quotation marks and escaped properly. If <em class="arg">command_line</em> is initially non-empty, a space will precede <em class="arg">argument</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>The argument to append to <em class="arg">command_line</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">command_line</td><td>The command line being constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb040202b4562c8c4087b9c9db2ce430" name="aeb040202b4562c8c4087b9c9db2ce430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb040202b4562c8c4087b9c9db2ce430">&#9670;&#160;</a></span>AssignIfInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Destination, typename Source&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::AssignIfInRange </td>
          <td>(</td>
          <td class="paramtype">Destination *</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Source</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an assignment if it can be done safely, and signals if it cannot be done safely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>A pointer to the variable to be assigned to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The value to assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em class="arg">source</em> is in the range supported by the type of <em class="arg">*destination</em>, with the assignment to <em class="arg">*destination</em> having been performed. <code>false</code> if the assignment cannot be completed safely because <em class="arg">source</em> is outside of this range. </dd></dl>

</div>
</div>
<a id="a89fde6ff8bc97d9f84bf0cdee5413987" name="a89fde6ff8bc97d9f84bf0cdee5413987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fde6ff8bc97d9f84bf0cdee5413987">&#9670;&#160;</a></span>AsUnderlyingType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::underlying_type&lt; From &gt;::type crashpad::AsUnderlyingType </td>
          <td>(</td>
          <td class="paramtype">From</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a value to its underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The value to be casted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em class="arg">from</em> casted to its underlying type. </dd></dl>

</div>
</div>
<a id="a2c18eae8148ec3304733581a28c2da3b" name="a2c18eae8148ec3304733581a28c2da3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c18eae8148ec3304733581a28c2da3b">&#9670;&#160;</a></span>AuditPIDFromMachMessageTrailer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t crashpad::AuditPIDFromMachMessageTrailer </td>
          <td>(</td>
          <td class="paramtype">const mach_msg_trailer_t *</td>          <td class="paramname"><span class="paramname"><em>trailer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the process ID of a Mach message’s sender from its audit trailer. </p>
<p>For the audit trailer to be present, the message must have been received with <a class="el" href="#a2c87c3ca622c253c84e9b557a0abe034" title="A Mach message option specifying that an audit trailer should be delivered during a receive operation...">kMachMessageReceiveAuditTrailer</a> or its macro equivalent specified in the receive options.</p>
<p>If the kernel is the message’s sender, a process ID of <code>0</code> will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trailer</td><td>The trailer received with a Mach message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The process ID of the message’s sender, or <code>-1</code> on failure with a message logged. It is considered a failure for <em class="arg">trailer</em> to not contain audit information. </dd></dl>

</div>
</div>
<a id="ab289b6fa3f20ee1c96a54b24174b4c9e" name="ab289b6fa3f20ee1c96a54b24174b4c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab289b6fa3f20ee1c96a54b24174b4c9e">&#9670;&#160;</a></span>BootstrapCheckIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">base::apple::ScopedMachReceiveRight crashpad::BootstrapCheckIn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>service_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a <code>boostrap_check_in()</code> call to the process’ bootstrap server. </p>
<p>This function is provided to make it easier to call <code>bootstrap_check_in()</code> while avoiding accidental leaks of the returned receive right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>The service name to check in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a receive right to the service port. On failure, <code>MACH_PORT_NULL</code> with a message logged. </dd></dl>

</div>
</div>
<a id="ad4abb1fe0e33a5a404f48510ba952347" name="ad4abb1fe0e33a5a404f48510ba952347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4abb1fe0e33a5a404f48510ba952347">&#9670;&#160;</a></span>BootstrapLookUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">base::apple::ScopedMachSendRight crashpad::BootstrapLookUp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>service_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a <code>boostrap_look_up()</code> call to the process’ bootstrap server. </p>
<p>This function is provided to make it easier to call <code>bootstrap_look_up()</code> while avoiding accidental leaks of the returned send right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>The service name to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a send right to the service port. On failure, <code>MACH_PORT_NULL</code> with a message logged. </dd></dl>

</div>
</div>
<a id="a63faa5e791871a34f458e2e3995389df" name="a63faa5e791871a34f458e2e3995389df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63faa5e791871a34f458e2e3995389df">&#9670;&#160;</a></span>BreakpadHTTPFormParametersFromMinidump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; crashpad::BreakpadHTTPFormParametersFromMinidump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrashpad_1_1ProcessSnapshot.html">ProcessSnapshot</a> *</td>          <td class="paramname"><span class="paramname"><em>process_snapshot</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a>, returns a map of key-value pairs to use as HTTP form parameters for upload to a Breakpad crash report colleciton server. </p>
<p>The map is built by combining the process simple annotations map with each module’s simple annotations map and annotation objects.</p>
<p>In the case of duplicate simple map keys or annotation names, the map will retain the first value found for any key, and will log a warning about discarded values. The precedence rules for annotation names are: the two reserved keys discussed below, process simple annotations, module simple annotations, and module annotation objects.</p>
<p>For annotation objects, only ones of that are <a class="el" href="classcrashpad_1_1Annotation.html#a734ee64cd20afdb78acb8656ed867d34a302e56d566a2561033b27c13680ea4b2" title="A NUL-terminated C-string.">Annotation::Type::kString</a> are included.</p>
<p>Each module’s annotations vector is also examined and built into a single string value, with distinct elements separated by newlines, and stored at the key named “list_annotations”, which supersedes any other key found by that name.</p>
<p>The client ID stored in the minidump is converted to a string and stored at the key named “guid”, which supersedes any other key found by that name.</p>
<p>In the event of an error reading the minidump file, a message will be logged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">process_snapshot</td><td>The process snapshot from which annotations will be extracted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string map of the annotations. </dd></dl>

</div>
</div>
<a id="a29f064fabb5cda55a8903bb99b72944d" name="a29f064fabb5cda55a8903bb99b72944d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f064fabb5cda55a8903bb99b72944d">&#9670;&#160;</a></span>BuildHandlerArgvStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; crashpad::BuildHandlerArgvStrings </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>metrics_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; base::FilePath &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>attachments</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a vector of arguments suitable for invoking a handler process based on arguments passed to StartHandler-type(). </p>
<p>See StartHandlerAtCrash() for documentation on the input arguments.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of arguments suitable for starting the handler with. </dd></dl>

</div>
</div>
<a id="a58169a74e32daa2888614fcd2f2381ce" name="a58169a74e32daa2888614fcd2f2381ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58169a74e32daa2888614fcd2f2381ce">&#9670;&#160;</a></span>BuildMinidumpThreadIDMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::BuildMinidumpThreadIDMap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classcrashpad_1_1ThreadSnapshot.html">ThreadSnapshot</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>thread_snapshots</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6e1c44f1c92c4ae031829f6f1b255268">MinidumpThreadIDMap</a> *</td>          <td class="paramname"><span class="paramname"><em>thread_id_map</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a <a class="el" href="#a6e1c44f1c92c4ae031829f6f1b255268" title="A map that connects 64-bit snapshot thread IDs to 32-bit minidump thread IDs.">MinidumpThreadIDMap</a> for a group of <a class="el" href="classcrashpad_1_1ThreadSnapshot.html" title="An abstract interface to a snapshot representing a thread (lightweight process) present in a snapshot...">ThreadSnapshot</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_snapshots</td><td>The thread snapshots to use as source data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">thread_id_map</td><td>A <a class="el" href="#a6e1c44f1c92c4ae031829f6f1b255268" title="A map that connects 64-bit snapshot thread IDs to 32-bit minidump thread IDs.">MinidumpThreadIDMap</a> to be built by this method. This map must be empty when this function is called.</td></tr>
  </table>
  </dd>
</dl>
<p>The map ensures that for any unique 64-bit thread ID found in a <a class="el" href="classcrashpad_1_1ThreadSnapshot.html" title="An abstract interface to a snapshot representing a thread (lightweight process) present in a snapshot...">ThreadSnapshot</a>, the 32-bit thread ID used in a minidump file will also be unique. </p>

</div>
</div>
<a id="ae97634ff8f75404670da123e9453c170" name="ae97634ff8f75404670da123e9453c170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97634ff8f75404670da123e9453c170">&#9670;&#160;</a></span>c16lcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t crashpad::c16lcpy </td>
          <td>(</td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a <code>NUL</code>-terminated char16_t-based string to a fixed-size buffer. </p>
<p>This function behaves identically to <code>strlcpy()</code>, but it operates on char16_t data instead of <code>char</code> data. It copies the <code>NUL</code>-terminated string in the buffer beginning at <em class="arg">source</em> to the buffer of size <em class="arg">length</em> at <em class="arg">destination</em>, ensuring that the destination buffer is <code>NUL</code>-terminated. No data will be written outside of the <em class="arg">destination</em> buffer, but if <em class="arg">length</em> is smaller than the length of the string at <em class="arg">source</em>, the string will be truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>A pointer to a buffer of at least size <em class="arg">length</em> char16_t units (not bytes). The string will be copied to this buffer, possibly with truncation, and <code>NUL</code>-terminated. Nothing will be written following the <code>NUL</code> terminator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>A pointer to a <code>NUL</code>-terminated string of char16_t data. The <code>NUL</code> terminator must be a <code>NUL</code> value in a char16_t unit, not just a single <code>NUL</code> byte. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the <em class="arg">destination</em> buffer in char16_t units, not bytes. A maximum of <em class="arg">`length</em> - 1` char16_t units from <em class="arg">source</em> will be copied to <em class="arg">destination</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the <em class="arg">source</em> string in char16_t units, not including its <code>NUL</code> terminator. When truncation occurs, the return value will be equal to or greater than than the <em class="arg">length</em> parameter. </dd></dl>

</div>
</div>
<a id="ac25486c6b4c38fc7c7868e978094edcf" name="ac25486c6b4c38fc7c7868e978094edcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25486c6b4c38fc7c7868e978094edcf">&#9670;&#160;</a></span>CaptureContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CaptureContext </td>
          <td>(</td>
          <td class="paramtype">NativeCPUContext *</td>          <td class="paramname"><span class="paramname"><em>cpu_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the CPU context. </p>
<p>The CPU context will be captured as accurately and completely as possible, containing an atomic snapshot at the point of this function’s return. This function does not modify any registers.</p>
<p>This function is a replacement for <code>RtlCaptureContext()</code> and <code>getcontext()</code> which contain bugs and/or limitations.</p>
<p>On 32-bit x86, <code>RtlCaptureContext()</code> requires that <code>ebp</code> be used as a frame pointer, and returns <code>ebp</code>, <code>esp</code>, and <code>eip</code> out of sync with the other registers. Both the 32-bit x86 and 64-bit x86_64 versions of <code>RtlCaptureContext()</code> capture only the state of the integer registers, ignoring floating-point and vector state.</p>
<p>CaptureContext isn't used on Fuchsia, nor does a concept of <code>ucontext_t</code> exist on Fuchsia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cpu_context</td><td>The structure to store the context in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The ABI may require that this function's argument is passed by register, preventing this fuction from saving the original value of that register. This occurs in the following circumstances:</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">OS   </th><th class="markdownTableHeadNone">Architecture   </th><th class="markdownTableHeadNone">Register    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Win   </td><td class="markdownTableBodyNone">x86_64   </td><td class="markdownTableBodyNone"><code>%rcx</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">macOS/Linux   </td><td class="markdownTableBodyNone">x86_64   </td><td class="markdownTableBodyNone"><code>%rdi</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone">ARM/ARM64   </td><td class="markdownTableBodyNone"><code>r0</code>/<code>x0</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone">MIPS/MIPS64   </td><td class="markdownTableBodyNone"><code>$a0</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone">RISCV64   </td><td class="markdownTableBodyNone"><code>a0</code>   </td></tr>
</table>
<p>Additionally, the value <code>LR</code> on ARM/ARM64 will be the return address of this function.</p>
<p>If the value of these register prior to calling this function are needed they must be obtained separately prior to calling this function. For example: </p><div class="fragment"><div class="line">uint64_t rdi;</div>
<div class="line"><span class="keyword">asm</span>(<span class="stringliteral">&quot;movq %%rdi, %0&quot;</span> : <span class="stringliteral">&quot;=m&quot;</span>(rdi));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acd8819955d3c396805f044bff1ecf595" name="acd8819955d3c396805f044bff1ecf595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8819955d3c396805f044bff1ecf595">&#9670;&#160;</a></span>CaptureSnapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CaptureSnapshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1PtraceConnection.html">PtraceConnection</a> *</td>          <td class="paramname"><span class="paramname"><em>connection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1ExceptionHandlerProtocol_1_1ClientInformation.html">ExceptionHandlerProtocol::ClientInformation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>process_annotations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t</td>          <td class="paramname"><span class="paramname"><em>client_uid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a></td>          <td class="paramname"><span class="paramname"><em>requesting_thread_stack_address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t *</td>          <td class="paramname"><span class="paramname"><em>requesting_thread_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcrashpad_1_1ProcessSnapshotLinux.html">ProcessSnapshotLinux</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>process_snapshot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcrashpad_1_1ProcessSnapshotSanitized.html">ProcessSnapshotSanitized</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>sanitized_snapshot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Captures a snapshot of a client over <em class="arg">connection</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connection</td><td>A <a class="el" href="classcrashpad_1_1PtraceConnection.html" title="Provides an interface for making ptrace requests against a process and its threads.">PtraceConnection</a> to the client to snapshot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Information about the client configuring the snapshot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">process_annotations</td><td>A map of annotations to insert as process-level annotations into the snapshot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">client_uid</td><td>The client's user ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requesting_thread_stack_address</td><td>An address on the stack of the thread requesting the snapshot. If <em class="arg">info</em> includes an exception address, the exception will be assigned to the thread whose stack address range contains this address. If 0, <em class="arg">requesting_thread_id</em> will be -1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">requesting_thread_id</td><td>The thread ID of the thread corresponding to <em class="arg">requesting_thread_stack_address</em>. Set to -1 if the thread ID could not be determined. Optional. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">process_snapshot</td><td>A snapshot of the client process, valid if this function returns <code>true</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sanitized_snapshot</td><td>A sanitized snapshot of the client process, valid if this function returns <code>true</code> and sanitization was requested in <em class="arg">info</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em class="arg">process_snapshot</em> was successfully created. A message will be logged on failure, but not if the snapshot was skipped because handling was disabled by <a class="el" href="structcrashpad_1_1CrashpadInfoClientOptions.html" title="Options represented in a client’s CrashpadInfo structure.">CrashpadInfoClientOptions</a>. </dd></dl>

</div>
</div>
<a id="a616ed0784021ecbd2f0f14b7e75c068c" name="a616ed0784021ecbd2f0f14b7e75c068c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616ed0784021ecbd2f0f14b7e75c068c">&#9670;&#160;</a></span>CFPropertyToLaunchData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::CFPropertyToLaunchData </td>
          <td>(</td>
          <td class="paramtype">CFPropertyListRef</td>          <td class="paramname"><span class="paramname"><em>property_cf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Core Foundation-type property list to a launchd-type <code>launch_data_t</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">property_cf</td><td>The Core Foundation-type property list to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted launchd-type <code>launch_data_t</code>. The caller takes ownership of the returned value. On error, returns <code>nullptr</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function handles all <code>CFPropertyListRef</code> types except for <code>CFDateRef</code>, because there’s no <code>launch_data_type_t</code> analogue. Not all types supported in a launchd-type <code>launch_data_t</code> have <code>CFPropertyListRef</code> analogues. </dd></dl>

</div>
</div>
<a id="ac7cb2e4837a6fda169cbe92d1603460f" name="ac7cb2e4837a6fda169cbe92d1603460f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7cb2e4837a6fda169cbe92d1603460f">&#9670;&#160;</a></span>CheckedCloseFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CheckedCloseFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <code>close()</code> or <code>CloseHandle()</code>, ensuring that it succeeds. </p>
<p>If the underlying function fails, this function causes execution to terminate without returning. </p>

</div>
</div>
<a id="ac8e7e1b1a4b89b489964ffee54d0d9df" name="ac8e7e1b1a4b89b489964ffee54d0d9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e7e1b1a4b89b489964ffee54d0d9df">&#9670;&#160;</a></span>CheckedReadFileAtEOF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CheckedReadFileAtEOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, ensuring that it indicates end-of-file. </p>
<p>Attempts to read a single byte from <em class="arg">file</em>, expecting no data to be read. If the underlying <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> fails, or if a byte actually is read, this function causes execution to terminate without returning.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a00e03e19185b0fde6301be6b113628cb" title="Wraps ReadFile(), ensuring that exactly size bytes are read.">CheckedReadFileExactly</a> </dd>
<dd>
<a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile</a> </dd></dl>

</div>
</div>
<a id="a00e03e19185b0fde6301be6b113628cb" name="a00e03e19185b0fde6301be6b113628cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e03e19185b0fde6301be6b113628cb">&#9670;&#160;</a></span>CheckedReadFileExactly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CheckedReadFileExactly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, ensuring that exactly <em class="arg">size</em> bytes are read. </p>
<p>If the underlying <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> fails, or if fewer than <em class="arg">size</em> bytes were read, this function causes execution to terminate without returning.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a74c74fefa3b1f5e0c1b885755c9f9cf6" title="Wraps WriteFile(), ensuring that exactly size bytes are written.">CheckedWriteFile</a> </dd>
<dd>
<a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile</a> </dd>
<dd>
<a class="el" href="#ac3fb8955565f605e08c1e30562fbdb7a" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">LoggingReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ac8e7e1b1a4b89b489964ffee54d0d9df" title="Wraps ReadFile(), ensuring that it indicates end-of-file.">CheckedReadFileAtEOF</a> </dd></dl>

</div>
</div>
<a id="a74c74fefa3b1f5e0c1b885755c9f9cf6" name="a74c74fefa3b1f5e0c1b885755c9f9cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c74fefa3b1f5e0c1b885755c9f9cf6">&#9670;&#160;</a></span>CheckedWriteFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CheckedWriteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4" title="Writes to a file, retrying when interrupted on POSIX or following a short write.">WriteFile()</a>, ensuring that exactly <em class="arg">size</em> bytes are written. </p>
<p>if the underlying <a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4" title="Writes to a file, retrying when interrupted on POSIX or following a short write.">WriteFile()</a> fails, or if fewer than <em class="arg">size</em> bytes were written, this function causes execution to terminate without returning.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a00e03e19185b0fde6301be6b113628cb" title="Wraps ReadFile(), ensuring that exactly size bytes are read.">CheckedReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4" title="Writes to a file, retrying when interrupted on POSIX or following a short write.">WriteFile</a> </dd>
<dd>
<a class="el" href="#a8a91af9c690d2a280c463596bf82070b" title="Wraps WriteFile(), ensuring that exactly size bytes are written.">LoggingWriteFile</a> </dd></dl>

</div>
</div>
<a id="aa93af751a4a09c316fb3de1a90e03fe8" name="aa93af751a4a09c316fb3de1a90e03fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93af751a4a09c316fb3de1a90e03fe8">&#9670;&#160;</a></span>ClockMonotonicNanoseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crashpad::ClockMonotonicNanoseconds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the system’s monotonic clock. </p>
<p>The monotonic clock is a tick counter whose epoch is unspecified. It is a monotonically-increasing clock that cannot be set, and never jumps backwards on a running system. The monotonic clock may stop while the system is sleeping, and it may be reset when the system starts up. This clock is suitable for computing durations of events. Subject to the underlying clock’s resolution, successive calls to this function will result in a series of increasing values.</p>
<dl class="section return"><dt>Returns</dt><dd>The value of the system’s monotonic clock, in nanoseconds. </dd></dl>

</div>
</div>
<a id="a003f563ef0fe26081b4520012e0c1ef8" name="a003f563ef0fe26081b4520012e0c1ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003f563ef0fe26081b4520012e0c1ef8">&#9670;&#160;</a></span>CloseMultipleNowOrOnExec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CloseMultipleNowOrOnExec </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>preserve_fd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close multiple file descriptors or mark them close-on-exec. </p>
<p>This is similar to the BSD/Solaris-style <code>closefrom()</code> routine, which closes all open file descriptors equal to or higher than its <em class="arg">fd</em> argument. This function must not be called while other threads are active. It is intended to be used in a child process created by <code>fork()</code>, prior to calling an <code>exec()</code>-family function. This guarantees that a (possibly untrustworthy) child process does not inherit file descriptors that it has no need for.</p>
<p>Unlike the BSD function, this function may not close file descriptors immediately, but may instead mark them as close-on-exec. The actual behavior chosen is specific to the operating system. On macOS, file descriptors are marked close-on-exec instead of being closed outright in order to avoid raising <code>EXC_GUARD</code> exceptions for guarded file descriptors that are protected against <code>close()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>The lowest file descriptor to close or set as close-on-exec. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preserve_fd</td><td>A file descriptor to preserve and not close (or set as close-on-exec), even if it is open and its value is greater than <em class="arg">fd</em>. To not preserve any file descriptor, pass <code>-1</code> for this parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8a3145ce95463d1638428b2547cde4d" name="aa8a3145ce95463d1638428b2547cde4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a3145ce95463d1638428b2547cde4d">&#9670;&#160;</a></span>CloseStdinAndStdout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CloseStdinAndStdout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes <code>stdin</code> and <code>stdout</code> by opening <code>/dev/null</code> over them. </p>
<p>It is normally inadvisable to <code>close()</code> the three standard input/output streams, because they occupy special file descriptors. Closing them outright could result in their file descriptors being reused. This causes problems for library code (including the standard library) that expects these file descriptors to have special meaning.</p>
<p>This function discards the standard input and standard output streams by opening <code>/dev/null</code> and assigning it to their file descriptors, closing whatever had been at those file descriptors previously.</p>
<p><code>stderr</code>, the standard error stream, is not closed. It is often useful to retain the ability to send diagnostic messages to the standard error stream.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only maintain its guarantees in a single-threaded process, or in situations where the caller has control of all threads in the process. </dd></dl>

</div>
</div>
<a id="ae89adfd6e277a5762f2e9b30e1af289e" name="ae89adfd6e277a5762f2e9b30e1af289e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89adfd6e277a5762f2e9b30e1af289e">&#9670;&#160;</a></span>CrackURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrackURL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>scheme</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crack a URL into component parts. </p>
<p>This is not a general function, and works only on the limited style of URLs that are expected to be used by <a class="el" href="classcrashpad_1_1HTTPTransport.html#a505d8f15710b1490f78d952cf84256f1" title="Sets URL to which the request will be made.">HTTPTransport::SetURL()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL to crack. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scheme</td><td>The request scheme, either http or https. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">host</td><td>The hostname. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port</td><td>The port. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rest</td><td>The remainder of the URL (both resource and URL params). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success in which case all output parameters will be filled out, or <code>false</code> on failure, in which case the output parameters will be unmodified and an error will be logged. </dd></dl>

</div>
</div>
<a id="a1bb7596acd0c7d75d0608ffafc6028e8" name="a1bb7596acd0c7d75d0608ffafc6028e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb7596acd0c7d75d0608ffafc6028e8">&#9670;&#160;</a></span>CreateNamedPipeInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE crashpad::CreateNamedPipeInstance </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>pipe_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>first_instance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps CreateNamedPipe() to create a single named pipe instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pipe_name</td><td>The name to use for the pipe. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_instance</td><td>If <code>true</code>, the named pipe instance will be created with <code>FILE_FLAG_FIRST_PIPE_INSTANCE</code>. This ensures that the the pipe name is not already in use when created. The first instance will be created with an untrusted integrity SACL so instances of this pipe can be connected to by processes of any integrity level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f17bed131c46938ca08241eebd5b520" name="a8f17bed131c46938ca08241eebd5b520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f17bed131c46938ca08241eebd5b520">&#9670;&#160;</a></span>DetermineMergedRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::DetermineMergedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrashpad_1_1MemorySnapshot.html">MemorySnapshot</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrashpad_1_1MemorySnapshot.html">MemorySnapshot</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1CheckedRange.html">CheckedRange</a>&lt; uint64_t, size_t &gt; *</td>          <td class="paramname"><span class="paramname"><em>merged</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The same as LoggingDetermineMergedRange but with no errors logged. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acb7b5be59c1293af50753130136aeb32" title="Given two memory snapshots, checks if they&#39;re overlapping or abutting, and if so, returns the result ...">LoggingDetermineMergedRange</a> </dd></dl>

</div>
</div>
<a id="a5e5ee7c62768446ceb8fa8a76db99952" name="a5e5ee7c62768446ceb8fa8a76db99952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5ee7c62768446ceb8fa8a76db99952">&#9670;&#160;</a></span>DropPrivileges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::DropPrivileges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permanently drops privileges conferred by being a setuid or setgid executable. </p>
<p>The effective user ID and saved set-user ID are set to the real user ID, negating any effects of being a setuid executable. The effective group ID and saved set-group ID are set to the real group ID, negating any effects of being a setgid executable. Because the saved set-user ID and saved set-group ID are reset, there is no way to restore the prior privileges, and the drop is permanent.</p>
<p>This function drops privileges correctly when running setuid root and in other circumstances, including when running setuid non-root. If the program is not a setuid or setgid executable, this function has no effect.</p>
<p>No changes are made to the supplementary group list, which is normally not altered for setuid or setgid executables. </p>

</div>
</div>
<a id="a83c8325c451170f4d3fb883014656af3" name="a83c8325c451170f4d3fb883014656af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c8325c451170f4d3fb883014656af3">&#9670;&#160;</a></span>ExcCrashCouldContainException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ExcCrashCouldContainException </td>
          <td>(</td>
          <td class="paramtype">exception_type_t</td>          <td class="paramname"><span class="paramname"><em>exception</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a given exception type could plausibly be carried within an <code>EXC_CRASH</code> exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception</td><td>The exception type to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an <code>EXC_CRASH</code> exception could plausibly carry <em class="arg">exception</em>.</dd></dl>
<p>An <code>EXC_CRASH</code> exception can wrap exceptions that originate as hardware faults, as well as exceptions that originate from certain software sources such as POSIX signals. It cannot wrap another <code>EXC_CRASH</code> exception, nor can it wrap <code>EXC_RESOURCE</code>, <code>EXC_GUARD</code>, or <code>EXC_CORPSE_NOTIFY</code> exceptions. It also cannot wrap Crashpad-specific <a class="el" href="#a9e0a6740778f04fe2d190dbcd080d55b" title="An exception type to use for simulated exceptions.">kMachExceptionSimulated</a> exceptions. </p>

</div>
</div>
<a id="a830c754edaa401f7d866e69369f76ae1" name="a830c754edaa401f7d866e69369f76ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830c754edaa401f7d866e69369f76ae1">&#9670;&#160;</a></span>ExcCrashRecoverOriginalException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exception_type_t crashpad::ExcCrashRecoverOriginalException </td>
          <td>(</td>
          <td class="paramtype">mach_exception_code_t</td>          <td class="paramname"><span class="paramname"><em>code_0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_exception_code_t *</td>          <td class="paramname"><span class="paramname"><em>original_code_0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>signal</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recovers the original exception, first exception code, and signal from the encoded form of the first exception code delivered with <code>EXC_CRASH</code> exceptions. </p>
<p><code>EXC_CRASH</code> exceptions are generated when the kernel has committed to terminating a process as a result of a core-generating POSIX signal and, for hardware exceptions, an earlier Mach exception. Information about this earlier exception and signal is made available to the <code>EXC_CRASH</code> handler via its <code>code[0]</code> parameter. This function recovers the original exception, the value of <code>code[0]</code> from the original exception, and the value of the signal responsible for process termination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code_0</td><td>The first exception code (<code>code[0]</code>) passed to a Mach exception handler in an <code>EXC_CRASH</code> exception. It is invalid to call this function with an exception code from any exception other than <code>EXC_CRASH</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">original_code_0</td><td>The first exception code (<code>code[0]</code>) passed to the Mach exception handler for a hardware exception that resulted in the generation of a POSIX signal that caused process termination. If the signal that caused termination was not sent as a result of a hardware exception, this will be <code>0</code>. Callers that do not need this value may pass <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signal</td><td>The POSIX signal that caused process termination. Callers that do not need this value may pass <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original exception for a hardware exception that resulted in the generation of a POSIX signal that caused process termination. If the signal that caused termination was not sent as a result of a hardware exception, this will be <code>0</code>. </dd></dl>

</div>
</div>
<a id="a2e26b5b9a8355ab15063b1c07fa6dff7" name="a2e26b5b9a8355ab15063b1c07fa6dff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e26b5b9a8355ab15063b1c07fa6dff7">&#9670;&#160;</a></span>ExceptionBehaviorBasic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exception_behavior_t crashpad::ExceptionBehaviorBasic </td>
          <td>(</td>
          <td class="paramtype">exception_behavior_t</td>          <td class="paramname"><span class="paramname"><em>behavior</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the basic behavior value of <em class="arg">behavior</em>, its value without <code>MACH_EXCEPTION_CODES</code> set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>An exception behavior value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>EXCEPTION_DEFAULT</code>, <code>EXCEPTION_STATE</code>, or <code>EXCEPTION_STATE_IDENTITY</code>, assuming <em class="arg">behavior</em> was a correct exception behavior value. </dd></dl>

</div>
</div>
<a id="a5d424769dc3683b809a9783f9319d4ab" name="a5d424769dc3683b809a9783f9319d4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d424769dc3683b809a9783f9319d4ab">&#9670;&#160;</a></span>ExceptionBehaviorHasIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ExceptionBehaviorHasIdentity </td>
          <td>(</td>
          <td class="paramtype">exception_behavior_t</td>          <td class="paramname"><span class="paramname"><em>behavior</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <em class="arg">behavior</em> indicates an exception behavior that carries thread and task identities. </p>
<p>When this function returns <code>true</code>, an exception message of <em class="arg">behavior</em> will carry thread and task identities in the form of send rights to the thread and task ports. Its <em class="arg">thread</em> and <em class="arg">task</em> fields will be valid. When this function returns <code>false</code>, these fields will not be valid.</p>
<p>Exception behaviors that carry thread and task identity information are <code>EXCEPTION_DEFAULT</code> and <code>EXCEPTION_STATE_IDENTITY</code>. <code>MACH_EXCEPTION_CODES</code> may also be set. These behaviors correspond to <code>exception_raise()</code>, <code>exception_raise_state_identity()</code>, <code>mach_exception_raise()</code>, and <code>mach_exception_raise_state_identity()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>An exception behavior value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em class="arg">behavior</em> is <code>EXCEPTION_DEFAULT</code> or <code>EXCEPTION_STATE_IDENTITY</code>, possibly with <code>MACH_EXCEPTION_CODES</code> also set. </dd></dl>

</div>
</div>
<a id="a6cd35f65144317021b4ea09a2b779bfb" name="a6cd35f65144317021b4ea09a2b779bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd35f65144317021b4ea09a2b779bfb">&#9670;&#160;</a></span>ExceptionBehaviorHasMachExceptionCodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ExceptionBehaviorHasMachExceptionCodes </td>
          <td>(</td>
          <td class="paramtype">exception_behavior_t</td>          <td class="paramname"><span class="paramname"><em>behavior</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <em class="arg">behavior</em> indicates an exception behavior that carries 64-bit exception codes (“Mach exception codes”). </p>
<p>When this function returns <code>true</code>, an exception message of <em class="arg">behavior</em> will carry 64-bit exception codes of type <code>mach_exception_code_t</code> in its <em class="arg">code</em> field. When this function returns <code>false</code>, the exception message will carry 32-bit exception codes of type <code>exception_data_type_t</code> in its <em class="arg">code</em> field.</p>
<p>Exception behaviors that carry 64-bit exception codes are those that have <code>MACH_EXCEPTION_CODES</code> set. These behaviors correspond to <code>mach_exception_raise()</code>, <code>mach_exception_raise_state()</code>, and <code>mach_exception_raise_state_identity()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>An exception behavior value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>MACH_EXCEPTION_CODES</code> is set in <em class="arg">behavior</em>. </dd></dl>

</div>
</div>
<a id="acea6434eb784ccde471620e9d79ba8c1" name="acea6434eb784ccde471620e9d79ba8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea6434eb784ccde471620e9d79ba8c1">&#9670;&#160;</a></span>ExceptionBehaviorHasState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ExceptionBehaviorHasState </td>
          <td>(</td>
          <td class="paramtype">exception_behavior_t</td>          <td class="paramname"><span class="paramname"><em>behavior</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <em class="arg">behavior</em> indicates an exception behavior that carries thread state information. </p>
<p>When this function returns <code>true</code>, an exception message of <em class="arg">behavior</em> will carry thread state information. Its <em class="arg">flavor</em>, <em class="arg">old_state</em>, <em class="arg">old_state_count</em>, <em class="arg">new_state</em>, and <em class="arg">new_state_count</em> fields will be valid. When this function returns <code>false</code>, these fields will not be valid.</p>
<p>Exception behaviors that carry thread state information are <code>EXCEPTION_STATE</code> and <code>EXCEPTION_STATE_IDENTITY</code>. <code>MACH_EXCEPTION_CODES</code> may also be set. These behaviors correspond to <code>exception_raise_state()</code>, <code>exception_raise_state_identity()</code>, <code>mach_exception_raise_state()</code>, and <code>mach_exception_raise_state_identity()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>An exception behavior value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em class="arg">behavior</em> is <code>EXCEPTION_STATE</code> or <code>EXCEPTION_STATE_IDENTITY</code>, possibly with <code>MACH_EXCEPTION_CODES</code> also set. </dd></dl>

</div>
</div>
<a id="a53fd131112ba6eba0d81467733a7643a" name="a53fd131112ba6eba0d81467733a7643a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fd131112ba6eba0d81467733a7643a">&#9670;&#160;</a></span>ExceptionBehaviorToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::ExceptionBehaviorToString </td>
          <td>(</td>
          <td class="paramtype">exception_behavior_t</td>          <td class="paramname"><span class="paramname"><em>behavior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Mach exception behavior value to a textual representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>The Mach exception behavior value to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a7856b82b71167792ea6103debb5105eda18aa149c3471a5129274df2af6972f04" title="Use | to combine values in a bitfield.">kUseOr</a> is ignored. <code>MACH_EXCEPTION_CODES</code> can always be ORed in, but no other values can be ORed with each other. For <a class="el" href="#a7856b82b71167792ea6103debb5105edaf9da07820c9857c86422b70c3cc33c12" title="If no symbolic name is known for a given constant, return a numeric string.">kUnknownIsNumeric</a>, the format is <code>"%#x"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string. </dd></dl>

</div>
</div>
<a id="ac448d0b014125dc8edd9c617836eb44c" name="ac448d0b014125dc8edd9c617836eb44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac448d0b014125dc8edd9c617836eb44c">&#9670;&#160;</a></span>ExceptionCodeForMetrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t crashpad::ExceptionCodeForMetrics </td>
          <td>(</td>
          <td class="paramtype">exception_type_t</td>          <td class="paramname"><span class="paramname"><em>exception</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_exception_code_t</td>          <td class="paramname"><span class="paramname"><em>code_0</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the exception code to report via a configured metrics system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception</td><td>The exception type as received by a Mach exception handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code_0</td><td>The first exception code (<code>code[0]</code>) as received by a Mach exception handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An exception code that maps useful information from <em class="arg">exception</em> and <em class="arg">code_0</em> to the more limited data type available for metrics reporting.</dd></dl>
<p>For classic Mach exceptions (including hardware faults reported as Mach exceptions), the mapping is <code>(exception &lt;&lt; 16) | code_0</code>.</p>
<p>For <code>EXC_CRASH</code> exceptions that originate as Mach exceptions described above, the mapping above is used, with the original exception’s values. For <code>EXC_CRASH</code> exceptions that originate as POSIX signals without an underlying Mach exception, the mapping is <code>(EXC_CRASH &lt;&lt; 16) | code_0</code>.</p>
<p><code>EXC_RESOURCE</code> and <code>EXC_GUARD</code> exceptions both contain exception-specific “type” values and type-specific “flavor” values. In these cases, the mapping is <code>(exception &lt;&lt; 16) | (type &lt;&lt; 8) | flavor</code>. For <code>EXC_GUARD</code>, the “flavor” value is rewritten to be more space-efficient by replacing the kernel-supplied bitmask having exactly one bit set with the index of the set bit.</p>
<p><code>EXC_CORPSE_NOTIFY</code> exceptions are reported as classic Mach exceptions with the <em class="arg">code_0</em> field set to <code>0</code>.</p>
<p>If <em class="arg">exception</em> is <a class="el" href="#a9e0a6740778f04fe2d190dbcd080d55b" title="An exception type to use for simulated exceptions.">kMachExceptionSimulated</a>, that value is returned as-is.</p>
<p>Overflow conditions in any field are handled via saturation. </p>

</div>
</div>
<a id="a8ee31102507c0f75d82496dcd6f6b53b" name="a8ee31102507c0f75d82496dcd6f6b53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee31102507c0f75d82496dcd6f6b53b">&#9670;&#160;</a></span>ExceptionMaskToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::ExceptionMaskToString </td>
          <td>(</td>
          <td class="paramtype">exception_mask_t</td>          <td class="paramname"><span class="paramname"><em>exception_mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Mach exception mask value to a textual representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_mask</td><td>The Mach exception mask value to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a7856b82b71167792ea6103debb5105eda18aa149c3471a5129274df2af6972f04" title="Use | to combine values in a bitfield.">kUseOr</a> is honored. For <a class="el" href="#a7856b82b71167792ea6103debb5105edaf9da07820c9857c86422b70c3cc33c12" title="If no symbolic name is known for a given constant, return a numeric string.">kUnknownIsNumeric</a>, the format is <code>"%#x"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string. </dd></dl>

</div>
</div>
<a id="a05296bfd23550f42639067355410811e" name="a05296bfd23550f42639067355410811e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05296bfd23550f42639067355410811e">&#9670;&#160;</a></span>ExceptionToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::ExceptionToString </td>
          <td>(</td>
          <td class="paramtype">exception_type_t</td>          <td class="paramname"><span class="paramname"><em>exception</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Mach exception value to a textual representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception</td><td>The Mach exception value to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a7856b82b71167792ea6103debb5105eda18aa149c3471a5129274df2af6972f04" title="Use | to combine values in a bitfield.">kUseOr</a> is ignored. For <a class="el" href="#a7856b82b71167792ea6103debb5105edaf9da07820c9857c86422b70c3cc33c12" title="If no symbolic name is known for a given constant, return a numeric string.">kUnknownIsNumeric</a>, the format is <code>"%d"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string. </dd></dl>

</div>
</div>
<a id="a194e0575e09db56e4107e1c41b27c941" name="a194e0575e09db56e4107e1c41b27c941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194e0575e09db56e4107e1c41b27c941">&#9670;&#160;</a></span>ExcMaskAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exception_mask_t crashpad::ExcMaskAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value for <code>EXC_MASK_ALL</code> appropriate for the operating system at run time. </p>
<p>The SDK’s definition of <code>EXC_MASK_ALL</code> has changed over time, with later versions containing more bits set than earlier versions. However, older kernels will reject exception masks that contain bits set that they don’t recognize. Calling this function will return a value for <code>EXC_MASK_ALL</code> appropriate for the system at run time.</p>
<dl class="section note"><dt>Note</dt><dd><code>EXC_MASK_ALL</code> does not include the value of <code>EXC_MASK_CRASH</code> or <code>EXC_MASK_CORPSE_NOTIFY</code>. Consumers that want <code>EXC_MASK_ALL</code> along with <code>EXC_MASK_CRASH</code> may use <a class="el" href="#a194e0575e09db56e4107e1c41b27c941" title="The value for EXC_MASK_ALL appropriate for the operating system at run time.">ExcMaskAll()</a> <code>| EXC_MASK_CRASH</code>. Consumers may use <a class="el" href="#a18e47623f33e0c86fef1d08a82b28cc9" title="An exception mask containing every possible exception understood by the operating system at run time.">ExcMaskValid()</a> for <code>EXC_MASK_ALL</code> along with <code>EXC_MASK_CRASH</code>, <code>EXC_MASK_CORPSE_NOTIFY</code>, and any values that come into existence in the future. </dd></dl>

</div>
</div>
<a id="a18e47623f33e0c86fef1d08a82b28cc9" name="a18e47623f33e0c86fef1d08a82b28cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e47623f33e0c86fef1d08a82b28cc9">&#9670;&#160;</a></span>ExcMaskValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exception_mask_t crashpad::ExcMaskValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An exception mask containing every possible exception understood by the operating system at run time. </p>
<p><code>EXC_MASK_ALL</code>, and thus <a class="el" href="#a194e0575e09db56e4107e1c41b27c941" title="The value for EXC_MASK_ALL appropriate for the operating system at run time.">ExcMaskAll()</a>, never includes the value of <code>EXC_MASK_CRASH</code> or <code>EXC_MASK_CORPSE_NOTIFY</code>. For situations where an exception mask corresponding to every possible exception understood by the running kernel is desired, use this function instead.</p>
<p>Should new exception types be introduced in the future, this function will be updated to include their bits in the returned mask value when run time support is present. </p>

</div>
</div>
<a id="ac192440e1d208f5dd348f0cba652d93a" name="ac192440e1d208f5dd348f0cba652d93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac192440e1d208f5dd348f0cba652d93a">&#9670;&#160;</a></span>ExcServerCopyState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::ExcServerCopyState </td>
          <td>(</td>
          <td class="paramtype">exception_behavior_t</td>          <td class="paramname"><span class="paramname"><em>behavior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae8a2e5f928712c15766a756cd2035d90">ConstThreadState</a></td>          <td class="paramname"><span class="paramname"><em>old_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_msg_type_number_t</td>          <td class="paramname"><span class="paramname"><em>old_state_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_state_t</td>          <td class="paramname"><span class="paramname"><em>new_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_msg_type_number_t *</td>          <td class="paramname"><span class="paramname"><em>new_state_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the old state to the new state for state-carrying exceptions. </p>
<p>When the kernel sends a state-carrying exception request and the response is successful (<code>MACH_MSG_SUCCESS</code>, a synonym for <code>KERN_SUCCESS</code>), it will set a new thread state based on <em class="arg">new_state</em> and <em class="arg">new_state_count</em>. To ease initialization of the new state, this function copies <em class="arg">old_state</em> and <em class="arg">old_state_count</em>. This is only done if <em class="arg">behavior</em> indicates a state-carrying exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>The behavior of the exception handler as invoked. This may be taken directly from the <em class="arg">behavior</em> parameter of internal::SimplifiedExcServer::Interface::CatchException(), for example. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_state</td><td>The original state value. This may be taken directly from the <em class="arg">old_state</em> parameter of internal::SimplifiedExcServer::Interface::CatchException(), for example. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_state_count</td><td>The number of significant <code>natural_t</code> words in <em class="arg">old_state</em>. This may be taken directly from the <em class="arg">old_state_count</em> parameter of internal::SimplifiedExcServer::Interface::CatchException(), for example. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_state</td><td>The state value to be set. This may be taken directly from the <em class="arg">new_state</em> parameter of internal::SimplifiedExcServer::Interface::CatchException(), for example. This parameter is untouched if <em class="arg">behavior</em> is not state-carrying. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_state_count</td><td>On entry, the number of <code>natural_t</code> words available to be written to in <em class="arg">new_state</em>. On return, the number of significant <code>natural_t</code> words in <em class="arg">new_state</em>. This may be taken directly from the <em class="arg">new_state_count</em> parameter of internal::SimplifiedExcServer::Interface::CatchException(), for example. This parameter is untouched if <em class="arg">behavior</em> is not state-carrying. If <em class="arg"><em class="arg">behavior</em> is</em> state-carrying, this parameter should be at least as large as <em class="arg">old_state_count</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2112e7fcb6a2fc7f9b6b0ff8856e8466" name="a2112e7fcb6a2fc7f9b6b0ff8856e8466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2112e7fcb6a2fc7f9b6b0ff8856e8466">&#9670;&#160;</a></span>ExcServerSuccessfulReturnValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kern_return_t crashpad::ExcServerSuccessfulReturnValue </td>
          <td>(</td>
          <td class="paramtype">exception_type_t</td>          <td class="paramname"><span class="paramname"><em>exception</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exception_behavior_t</td>          <td class="paramname"><span class="paramname"><em>behavior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>set_thread_state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an approriate successful return value for an exception handler function. </p>
<p>For exception handlers that respond to state-carrying behaviors, when the handler is called by the kernel (as it is normally), the kernel will attempt to set a new thread state when the exception handler returns successfully. Other code that mimics the kernel’s exception-delivery semantics may implement the same or similar behavior. In some situations, it is undesirable to set a new thread state. If the exception handler were to return unsuccessfully, however, the kernel would continue searching for an exception handler at a wider (task or host) scope. This may also be undesirable.</p>
<p>If such exception handlers return <code>MACH_RCV_PORT_DIED</code>, the kernel will not set a new thread state and will also not search for another exception handler. See 10.9.4 <code>xnu-2422.110.17/osfmk/kern/exception.c</code>. <code>exception_deliver()</code> will only set a new thread state if the handler’s return code was <code>MACH_MSG_SUCCESS</code> (a synonym for <code>KERN_SUCCESS</code>), and subsequently, <code>exception_triage()</code> will not search for a new handler if the handler’s return code was <code>KERN_SUCCESS</code> or <code>MACH_RCV_PORT_DIED</code>.</p>
<p>This function allows exception handlers to compute an appropriate return code to influence their caller (the kernel) in the desired way with respect to setting a new thread state while suppressing the caller’s subsequent search for other exception handlers. An exception handler should return the value returned by this function.</p>
<p>This function is useful even for <code>EXC_CRASH</code> handlers, where returning <code>KERN_SUCCESS</code> and allowing the kernel to set a new thread state has been observed to cause a perceptible and unnecessary waste of time. The victim task in an <code>EXC_CRASH</code> handler is already being terminated and is no longer schedulable, so there is no point in setting the states of any of its threads.</p>
<p>On OS X 10.11, the <code>MACH_RCV_PORT_DIED</code> mechanism cannot be used with an <code>EXC_CRASH</code> handler without triggering an undesirable <code>EXC_CORPSE_NOTIFY</code> exception. In that case, <code>KERN_SUCCESS</code> is always returned. Because this function may return <code>KERN_SUCCESS</code> for a state-carrying exception, it is important to ensure that the state returned by a state-carrying exception handler is valid, because it will be passed to <code>thread_set_status()</code>. <a class="el" href="#ac192440e1d208f5dd348f0cba652d93a" title="Copies the old state to the new state for state-carrying exceptions.">ExcServerCopyState()</a> may be used to achieve this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception</td><td>The exception type passed to the exception handler. This may be taken directly from the <em class="arg">exception</em> parameter of internal::SimplifiedExcServer::Interface::CatchException(), for example. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>The behavior of the exception handler as invoked. This may be taken directly from the <em class="arg">behavior</em> parameter of internal::SimplifiedExcServer::Interface::CatchException(), for example. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set_thread_state</td><td><code>true</code> if the handler would like its caller to set the new thread state using the <em class="arg">flavor</em>, <em class="arg">new_state</em>, and <em class="arg">new_state_count</em> out parameters. This can only happen when <em class="arg">behavior</em> is a state-carrying behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>KERN_SUCCESS</code> or <code>MACH_RCV_PORT_DIED</code>. <code>KERN_SUCCESS</code> is used when <em class="arg">behavior</em> is not a state-carrying behavior, or when it is a state-carrying behavior and <em class="arg">set_thread_state</em> is <code>true</code>, or for <code>EXC_CRASH</code> exceptions on OS X 10.11 and later. Otherwise, <code>MACH_RCV_PORT_DIED</code> is used. </dd></dl>

</div>
</div>
<a id="a229b9a82773f5497a0f0c74aae3b8b3a" name="a229b9a82773f5497a0f0c74aae3b8b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229b9a82773f5497a0f0c74aae3b8b3a">&#9670;&#160;</a></span>FileModificationTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::FileModificationTime </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timespec *</td>          <td class="paramname"><span class="paramname"><em>mtime</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the modification time for a file, directory, or symbolic link, logging a message on failure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The file to get the modification time for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mtime</td><td>The modification time as seconds since the POSIX Epoch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="aa84c4880b695542867ee6ac872f0f98f" name="aa84c4880b695542867ee6ac872f0f98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84c4880b695542867ee6ac872f0f98f">&#9670;&#160;</a></span>FromPointerCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To, typename From&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">crashpad::FromPointerCast </td>
          <td>(</td>
          <td class="paramtype">From</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts from a pointer type to an integer. </p>
<p>Compared to <code>reinterpret_cast&lt;&gt;()</code>, <a class="el" href="#aa84c4880b695542867ee6ac872f0f98f" title="Casts from a pointer type to an integer.">FromPointerCast&lt;&gt;()</a> defines whether a pointer type is sign-extended or zero-extended. Casts to signed integral types are sign-extended. Casts to unsigned integral types are zero-extended.</p>
<p>Use <a class="el" href="#aa84c4880b695542867ee6ac872f0f98f" title="Casts from a pointer type to an integer.">FromPointerCast&lt;&gt;()</a> instead of <code>reinterpret_cast&lt;&gt;()</code> when casting a pointer to an integral type that may not be the same width as a pointer. There is no need to prefer <a class="el" href="#aa84c4880b695542867ee6ac872f0f98f" title="Casts from a pointer type to an integer.">FromPointerCast&lt;&gt;()</a> when casting to an integral type that’s definitely the same width as a pointer, such as <code>uintptr_t</code> and <code>intptr_t</code>. </p>

</div>
</div>
<a id="a546d3f9feba8be654adc0292f99e043a" name="a546d3f9feba8be654adc0292f99e043a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546d3f9feba8be654adc0292f99e043a">&#9670;&#160;</a></span>GetBootTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::GetBootTime </td>
          <td>(</td>
          <td class="paramtype">timespec *</td>          <td class="paramname"><span class="paramname"><em>ts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the kernel boot time. Subsequent calls to this function may return different results due to the system clock being changed or imprecision in measuring the boot time. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise, <code>false</code> with a message logged. </dd></dl>

</div>
</div>
<a id="a4f31c2f8b1cfea873b757dc486281437" name="a4f31c2f8b1cfea873b757dc486281437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f31c2f8b1cfea873b757dc486281437">&#9670;&#160;</a></span>GetChildKoids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; zx_koid_t &gt; crashpad::GetChildKoids </td>
          <td>(</td>
          <td class="paramtype">const zx::object_base &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">zx_object_info_topic_t</td>          <td class="paramname"><span class="paramname"><em>child_kind</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of child koids for a parent handle. </p>
<p>For example, the list of processes in jobs, or the list of threads in a process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The handle to the parent object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_kind</td><td>The type of children to retrieve from <em class="arg">parent</em>. Valid values depend on the type of <em class="arg">parent</em>, but include <code>ZX_INFO_JOB_CHILDREN</code> (child jobs of a job), <code>ZX_INFO_JOB_PROCESSES</code> (child processes of a job), and <code>ZX_INFO_PROCESS_THREADS</code> (child threads of a process). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the koids representing the child objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>GetChildHandles </dd></dl>

</div>
</div>
<a id="a23c75452e519dc3715a6f7f30fc83805" name="a23c75452e519dc3715a6f7f30fc83805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c75452e519dc3715a6f7f30fc83805">&#9670;&#160;</a></span>GetDirectorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crashpad::GetDirectorySize </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>dirPath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the recursive sum of the size of the files in |dirPath|. The function will ignore symlinks (not follow them, not add them to the returned size). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirPath</td><td>The path to the directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the size of the files in |dirPath|. </dd></dl>

</div>
</div>
<a id="a8dec2ab03620dcacc0b0d60ae0845f3c" name="a8dec2ab03620dcacc0b0d60ae0845f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dec2ab03620dcacc0b0d60ae0845f3c">&#9670;&#160;</a></span>GetFallbackSecurityDescriptorForNamedPipeInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * crashpad::GetFallbackSecurityDescriptorForNamedPipeInstance </td>
          <td>(</td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code>SECURITY_DESCRIPTOR</code> blob that will be used for creating the connection pipe in <a class="el" href="#a1bb7596acd0c7d75d0608ffafc6028e8" title="Wraps CreateNamedPipe() to create a single named pipe instance.">CreateNamedPipeInstance()</a> if the full descriptor can't be created. </p>
<p>This function is only exposed for testing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>The size of the returned blob. May be <code>nullptr</code> if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a self-relative <code>SECURITY_DESCRIPTOR</code>. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a9e0124db0942485ff3afb224f48cd765" name="a9e0124db0942485ff3afb224f48cd765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0124db0942485ff3afb224f48cd765">&#9670;&#160;</a></span>GetFileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crashpad::GetFileSize </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>filepath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the file at |filepath|. The function will ignore symlinks (not follow them, not add them to the returned size). </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the file pointed by |filepath|. </dd></dl>

</div>
</div>
<a id="a24450f6cd81133935420337540b4d62b" name="a24450f6cd81133935420337540b4d62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24450f6cd81133935420337540b4d62b">&#9670;&#160;</a></span>GetHandlesForThreadKoids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; zx::thread &gt; crashpad::GetHandlesForThreadKoids </td>
          <td>(</td>
          <td class="paramtype">const zx::process &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; zx_koid_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>koids</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of koids that are all children of a particular process into thread handles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The parent object to which the koids belong. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">koids</td><td>The list of koids. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting list of handles corresponding to the koids. If an element of <em class="arg">koids</em> is invalid or can't be retrieved, there will be a corresponding <code>ZX_HANDLE_INVALID</code> entry in the return. </dd></dl>

</div>
</div>
<a id="aa78f92ab17c2ca6a7a86edc949ac1fde" name="aa78f92ab17c2ca6a7a86edc949ac1fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78f92ab17c2ca6a7a86edc949ac1fde">&#9670;&#160;</a></span>GetKoidForHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">zx_koid_t crashpad::GetKoidForHandle </td>
          <td>(</td>
          <td class="paramtype">const zx::object_base &amp;</td>          <td class="paramname"><span class="paramname"><em>object</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the koid for a given object handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The handle for which the koid is to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The koid of <em class="arg">handle</em>, or <code>ZX_HANDLE_INVALID</code> with an error logged. </dd></dl>

</div>
</div>
<a id="af5f4414be804bdcd71f57053d7147eff" name="af5f4414be804bdcd71f57053d7147eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f4414be804bdcd71f57053d7147eff">&#9670;&#160;</a></span>GetModuleVersionAndType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::GetModuleVersionAndType </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVS__FIXEDFILEINFO.html">VS_FIXEDFILEINFO</a> *</td>          <td class="paramname"><span class="paramname"><em>vs_fixedfileinfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the type and version information from a given module (exe, dll, etc.) </p>
<p>This function calls <code>GetFileVersionInfo()</code>, which can implicitly call <code>LoadLibrary()</code> to load <em class="arg">path</em> into the calling process. Do not call this function on an untrusted module, because there is a risk of executing the module’s code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the module to be inspected. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vs_fixedfileinfo</td><td>The <a class="el" href="structVS__FIXEDFILEINFO.html" title="Version information for a file.">VS_FIXEDFILEINFO</a> on success. <a class="el" href="structVS__FIXEDFILEINFO.html#a1ecf0351f90806354f987321c4d1ce0e" title="A bitmask of VS_FF_* values identifying attributes of the file. Only bits present in dwFileFlagsMask ...">VS_FIXEDFILEINFO::dwFileFlags</a> will have been masked with <a class="el" href="structVS__FIXEDFILEINFO.html#a1523cf64b0b010ecf5a8c3b02866041c" title="A bitmask of VS_FF_* values indicating which bits in dwFileFlags are valid.">VS_FIXEDFILEINFO::dwFileFlagsMask</a> already.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, or <code>false</code> on failure with a message logged. If the module has no <code>VERSIONINFO</code> resource, <code>false</code> will be returned without any messages logged. </dd></dl>

</div>
</div>
<a id="a794c1a44de599deb3e261eab0bd6c03b" name="a794c1a44de599deb3e261eab0bd6c03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794c1a44de599deb3e261eab0bd6c03b">&#9670;&#160;</a></span>GetReadableRangesOfMemoryMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcrashpad_1_1CheckedRange.html">CheckedRange</a>&lt; <a class="el" href="#ac5872ff07ebe5bda9f532e8d3d752d77">WinVMAddress</a>, <a class="el" href="#aa24b456d735f72df6141fd110542b24f">WinVMSize</a> &gt; &gt; crashpad::GetReadableRangesOfMemoryMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrashpad_1_1CheckedRange.html">CheckedRange</a>&lt; <a class="el" href="#ac5872ff07ebe5bda9f532e8d3d752d77">WinVMAddress</a>, <a class="el" href="#aa24b456d735f72df6141fd110542b24f">WinVMSize</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrashpad_1_1ProcessInfo.html#a8b50ad8796b1e43eed798c6c717bcbdf">ProcessInfo::MemoryBasicInformation64Vector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>memory_info</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a memory map of a process, and a range to be read from the target process, returns a vector of ranges, representing the readable portions of the original range. </p>
<p>This is a free function for testing, but prefer <a class="el" href="classcrashpad_1_1ProcessInfo.html#a96ddc54651cdea815f8f88a5ae00f0ab" title="Given a range to be read from the target process, returns a vector of ranges, representing the readab...">ProcessInfo::GetReadableRanges()</a>. </p>

</div>
</div>
<a id="af22242667ee950fe12a99b298dda5e08" name="af22242667ee950fe12a99b298dda5e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22242667ee950fe12a99b298dda5e08">&#9670;&#160;</a></span>GetSecurityDescriptorForNamedPipeInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * crashpad::GetSecurityDescriptorForNamedPipeInstance </td>
          <td>(</td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code>SECURITY_DESCRIPTOR</code> blob that will be used for creating the connection pipe in <a class="el" href="#a1bb7596acd0c7d75d0608ffafc6028e8" title="Wraps CreateNamedPipe() to create a single named pipe instance.">CreateNamedPipeInstance()</a>. </p>
<p>This function is only exposed for testing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>The size of the returned blob. May be <code>nullptr</code> if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a self-relative <code>SECURITY_DESCRIPTOR</code>. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="ae99a5273dd73373a439df42cc39a8da0" name="ae99a5273dd73373a439df42cc39a8da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99a5273dd73373a439df42cc39a8da0">&#9670;&#160;</a></span>GetThreadHandleByKoid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">zx::thread crashpad::GetThreadHandleByKoid </td>
          <td>(</td>
          <td class="paramtype">const zx::process &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">zx_koid_t</td>          <td class="paramname"><span class="paramname"><em>child_koid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the handle of a process' thread, based on koid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The parent object to which the child belongs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_koid</td><td>The koid of the child to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle representing <em class="arg">child_koid</em>, or <code>ZX_HANDLE_INVALID</code> if the handle could not be retrieved, in which case an error will be logged. </dd></dl>

</div>
</div>
<a id="a1b88f2d030f9da088707bc361045ff86" name="a1b88f2d030f9da088707bc361045ff86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b88f2d030f9da088707bc361045ff86">&#9670;&#160;</a></span>GetThreadHandles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; zx::thread &gt; crashpad::GetThreadHandles </td>
          <td>(</td>
          <td class="paramtype">const zx::process &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get handles representing a list of child objects of a given parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The handle to the parent object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting list of handles corresponding to the child objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4f31c2f8b1cfea873b757dc486281437" title="Get a list of child koids for a parent handle.">GetChildKoids</a> </dd></dl>

</div>
</div>
<a id="a6925b00a82891a9fd7a77ec6f5259094" name="a6925b00a82891a9fd7a77ec6f5259094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6925b00a82891a9fd7a77ec6f5259094">&#9670;&#160;</a></span>HandlerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crashpad::HandlerMain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserStreamDataSources *</td>          <td class="paramname"><span class="paramname"><em>user_stream_sources</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>main()</code> of the <code>crashpad_handler</code> binary. </p>
<p>This is exposed so that <code>crashpad_handler</code> can be embedded into another binary, but called and used as if it were a standalone executable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td><em class="arg">argc</em> as passed to <code>main()</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td><em class="arg">argv</em> as passed to <code>main()</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_stream_sources</td><td>An optional vector containing the extensibility data sources to call on crash. Each time a minidump is created, the sources are called in turn. Any streams returned are added to the minidump. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae643b5c6bce4e11a0f51eb2f4d5fa1de" name="ae643b5c6bce4e11a0f51eb2f4d5fa1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae643b5c6bce4e11a0f51eb2f4d5fa1de">&#9670;&#160;</a></span>HandleToInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crashpad::HandleToInt </td>
          <td>(</td>
          <td class="paramtype">HANDLE</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <code>HANDLE</code> to an <code>int</code>. </p>
<p><code>HANDLE</code> is a <code>typedef</code> for <code>void *</code>, but kernel <code>HANDLE</code> values aren’t pointers to anything. Only 32 bits of kernel <code>HANDLE</code>s are significant, even in 64-bit processes on 64-bit operating systems. See <a href="https://msdn.microsoft.com/library/aa384203.aspx">Interprocess Communication Between 32-bit and 64-bit Applications</a>.</p>
<p>This function safely converts a kernel <code>HANDLE</code> to an <code>int</code> similarly to a cast operation. It checks that the operation can be performed safely, and aborts execution if it cannot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The kernel <code>HANDLE</code> to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An equivalent <code>int</code>, truncated (if necessary) from <em class="arg">handle</em>. If truncation would have resulted in an <code>int</code> that could not be converted back to <em class="arg">handle</em>, aborts execution.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a83df06f1e4dc470676c1f86e93b6bc63" title="Converts an int to an HANDLE.">IntToHandle()</a> </dd></dl>

</div>
</div>
<a id="af8340c24a2983e788d2a3ba90d1d4846" name="af8340c24a2983e788d2a3ba90d1d4846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8340c24a2983e788d2a3ba90d1d4846">&#9670;&#160;</a></span>InitializeCriticalSectionWithDebugInfoIfPossible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::InitializeCriticalSectionWithDebugInfoIfPossible </td>
          <td>(</td>
          <td class="paramtype">CRITICAL_SECTION *</td>          <td class="paramname"><span class="paramname"><em>critical_section</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>InitializeCritialSection()</code>, but attempts to allocate with a valid <code>.DebugInfo</code> field on versions of Windows where it's possible to do so. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, or <code>false</code> on failure with a message logged. Success means that the critical section was successfully initialized, but it does not necessarily have a valid <code>.DebugInfo</code> field. </dd></dl>

</div>
</div>
<a id="a2a2e6f185467f42cb17ce959a13cc482" name="a2a2e6f185467f42cb17ce959a13cc482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2e6f185467f42cb17ce959a13cc482">&#9670;&#160;</a></span>InitializeSignalDispositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::InitializeSignalDispositions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes signal dispositions for a process based on the platform. </p>
<p>Default signal dispositions are normally configured by the kernel, but additional signal handlers might be installed by dependent or preloaded libraries, e.g. Bionic normally installs signal handlers which log stack traces to Android's logcat.</p>
<p>This function initializes signal dispositions when the default dispositions provided by the platform are broken. This function must be called before any application level signal handlers have been installed and should be called early in the process lifetime to reduce the chance of any broken signal handlers being triggered.</p>
<p>When running on Android M (API 23), this function installs <code>SIG_DFL</code> for signals: <code>SIGABRT</code>, <code>SIGFPE</code>, <code>SIGPIPE</code>, <code>SIGSTKFLT</code>, and <code>SIGTRAP</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise <code>false</code> with a message logged. </dd></dl>

</div>
</div>
<a id="a6e1b1c536af301cd418dad62348b1d29" name="a6e1b1c536af301cd418dad62348b1d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1b1c536af301cd418dad62348b1d29">&#9670;&#160;</a></span>InRangeCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Destination, typename Source&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Destination crashpad::InRangeCast </td>
          <td>(</td>
          <td class="paramtype">Source</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Destination</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts to a different type if it can be done without data loss, logging a warning message and returing a default value otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The value to convert and return. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>The default value to return, in the event that <em class="arg">source</em> cannot be represented in the destination type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em class="arg">source</em> if it can be represented in the destination type, otherwise <em class="arg">default_value</em>. </dd></dl>

</div>
</div>
<a id="a20c1c43fa1b04d68f3262b88cd86e2e2" name="a20c1c43fa1b04d68f3262b88cd86e2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c1c43fa1b04d68f3262b88cd86e2e2">&#9670;&#160;</a></span>InstallObjcExceptionPreprocessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::InstallObjcExceptionPreprocessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1ObjcExceptionDelegate.html">ObjcExceptionDelegate</a> *</td>          <td class="paramname"><span class="paramname"><em>delegate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs the Objective-C exception preprocessor. </p>
<p>When code raises an Objective-C exception, unwind the stack looking for any exception handlers. If an exception handler is encountered, test to see if it is a function known to be a catch-and-rethrow 'sinkhole' exception handler. Various routines in UIKit do this, and they obscure the crashing stack, since the original throw location is no longer present on the stack (just the re-throw) when Crashpad captures the crash report. In the case of sinkholes, trigger an immediate exception to capture the original stack.</p>
<p>This should be installed at the same time the <a class="el" href="classcrashpad_1_1CrashpadClient.html" title="The primary interface for an application to have Crashpad monitor it for crashes.">CrashpadClient</a> installs the signal handler. It should only be installed once. </p>

</div>
</div>
<a id="a83df06f1e4dc470676c1f86e93b6bc63" name="a83df06f1e4dc470676c1f86e93b6bc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83df06f1e4dc470676c1f86e93b6bc63">&#9670;&#160;</a></span>IntToHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE crashpad::IntToHandle </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>handle_int</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <code>int</code> to an <code>HANDLE</code>. </p>
<p><code>HANDLE</code> is a <code>typedef</code> for <code>void *</code>, but kernel <code>HANDLE</code> values aren’t pointers to anything. Only 32 bits of kernel <code>HANDLE</code>s are significant, even in 64-bit processes on 64-bit operating systems. See <a href="https://msdn.microsoft.com/library/aa384203.aspx">Interprocess Communication Between 32-bit and 64-bit Applications</a>.</p>
<p>This function safely convert an <code>int</code> to a kernel <code>HANDLE</code> similarly to a cast operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle_int</td><td>The <code>int</code> to convert. This must have been produced by <a class="el" href="#ae643b5c6bce4e11a0f51eb2f4d5fa1de" title="Converts a HANDLE to an int.">HandleToInt()</a>, possibly in a different process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An equivalent kernel <code>HANDLE</code>, sign-extended (if necessary) from <em class="arg">handle_int</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae643b5c6bce4e11a0f51eb2f4d5fa1de" title="Converts a HANDLE to an int.">HandleToInt()</a> </dd></dl>

</div>
</div>
<a id="af12fac7cddd34499234ca6617e3e3aa3" name="af12fac7cddd34499234ca6617e3e3aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12fac7cddd34499234ca6617e3e3aa3">&#9670;&#160;</a></span>IsDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::IsDirectory </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_symlinks</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a path refers to a directory, logging a message on failure. </p>
<p>On POSIX, if this function fails because <em class="arg">path</em> does not exist, then no message is logged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_symlinks</td><td>Whether to allow the final component in the path to be a symbolic link to a directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the path exists and is a directory. Otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ad2ac0b9fe2a066fecac5e8d9b977e892" name="ad2ac0b9fe2a066fecac5e8d9b977e892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ac0b9fe2a066fecac5e8d9b977e892">&#9670;&#160;</a></span>IsExceptionNonfatalResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::IsExceptionNonfatalResource </td>
          <td>(</td>
          <td class="paramtype">exception_type_t</td>          <td class="paramname"><span class="paramname"><em>exception</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_exception_code_t</td>          <td class="paramname"><span class="paramname"><em>code_0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether an exception is a non-fatal <code>EXC_RESOURCE</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception</td><td>The exception type as received by a Mach exception handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code_0</td><td>The first exception code (<code>code[0]</code>) as received by a Mach exception handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The process ID that the exception occurred in. In some cases, process may need to be queried to determine whether an <code>EXC_RESOURCE</code> exception is fatal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the exception is a non-fatal <code>EXC_RESOURCE</code>. <code>false</code> otherwise. If the exception is <code>EXC_RESOURCE</code> of a recognized type but it is not possible to determine whether it is fatal, returns <code>true</code> under the assumption that all known <code>EXC_RESOURCE</code> exceptions are non-fatal by default. If the exception is not <code>EXC_RESOURCE</code> or is an unknown <code>EXC_RESOURCE</code> type, returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="a2388c530540daf977829b751582d5624" name="a2388c530540daf977829b751582d5624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2388c530540daf977829b751582d5624">&#9670;&#160;</a></span>IsMalformedCLKernelsModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::IsMalformedCLKernelsModule </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>mach_o_file_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>module_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a module appears to be a malformed OpenCL <code>cl_kernels</code> module based on its name and Mach-O file type. </p>
<p><code>cl_kernels</code> modules require special handling because they’re malformed on OS X 10.10 and later. A <code>cl_kernels</code> module always has Mach-O type <code>MH_BUNDLE</code> and is named <code>"cl_kernels"</code> until macOS 10.14, and <code>"/private/var/db/CVMS/cvmsCodeSignObj"</code> plus 16 random characters on macOS 10.14.</p>
<p>Malformed <code>cl_kernels</code> modules have a single <code>__TEXT</code> segment, but one of the sections within it claims to belong to the <code>__LD</code> segment. This mismatch shouldn’t happen. This errant section also has the <code>S_ATTR_DEBUG</code> flag set, which shouldn’t happen unless all of the other sections in the segment also have this bit set (they don’t). These odd sections are reminiscent of unwind information stored in <code>MH_OBJECT</code> images, although <code>cl_kernels</code> images claim to be <code>MH_BUNDLE</code>.</p>
<p>These <code>cl_kernels</code> modules have only been observed on x86, not on arm64. This function always returns <code>false</code> on arm64.</p>
<p>This function is exposed for testing purposes only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mach_o_file_type</td><td>The Mach-O type of the module being examined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_name</td><td>The pathname that <code>dyld</code> reported having loaded the module from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the module appears to be a malformed <code>cl_kernels</code> module based on the provided information, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a3c69205d3a470099d1489f71cbfe7ba6" name="a3c69205d3a470099d1489f71cbfe7ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c69205d3a470099d1489f71cbfe7ba6">&#9670;&#160;</a></span>IsRegularFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::IsRegularFile </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a path refers to a regular file, logging a message on failure. </p>
<p>On POSIX, this function returns <code>true</code> if <em class="arg">path</em> refers to a file that is not a symbolic link, directory, or other kind of special file. If this function fails because <em class="arg">path</em> does not exist, then no message is logged.</p>
<p>On Windows, this function returns <code>true</code> if <em class="arg">path</em> refers to a file that is not a symbolic link or directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the file to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the file exists and is a regular file. Otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a0358455342226c7906f6d8f3016a6374" name="a0358455342226c7906f6d8f3016a6374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0358455342226c7906f6d8f3016a6374">&#9670;&#160;</a></span>IsThreadInLoaderLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::IsThreadInLoaderLock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current thread holds the loader lock. </dd></dl>

</div>
</div>
<a id="aec89d58359f33bb2ba3671feea0c15f4" name="aec89d58359f33bb2ba3671feea0c15f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec89d58359f33bb2ba3671feea0c15f4">&#9670;&#160;</a></span>LaunchDataAlloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::LaunchDataAlloc </td>
          <td>(</td>
          <td class="paramtype">launch_data_type_t</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="abeb060347d9343e720856380234cd6ff" name="abeb060347d9343e720856380234cd6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb060347d9343e720856380234cd6ff">&#9670;&#160;</a></span>LaunchDataArrayGetCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t crashpad::LaunchDataArrayGetCount </td>
          <td>(</td>
          <td class="paramtype">launch_data_t</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a46e5304477aab0ad1d165869557eb3b5" name="a46e5304477aab0ad1d165869557eb3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e5304477aab0ad1d165869557eb3b5">&#9670;&#160;</a></span>LaunchDataArrayGetIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::LaunchDataArrayGetIndex </td>
          <td>(</td>
          <td class="paramtype">launch_data_t</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a075be3843e4294e446c40022ba6661c4" name="a075be3843e4294e446c40022ba6661c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075be3843e4294e446c40022ba6661c4">&#9670;&#160;</a></span>LaunchDataArraySetIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LaunchDataArraySetIndex </td>
          <td>(</td>
          <td class="paramtype">launch_data_t</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="aedb99d12b989d048f972d843a2aea013" name="aedb99d12b989d048f972d843a2aea013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb99d12b989d048f972d843a2aea013">&#9670;&#160;</a></span>LaunchDataDictGetCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t crashpad::LaunchDataDictGetCount </td>
          <td>(</td>
          <td class="paramtype">launch_data_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a5637f13db21865305a5d09b123647ee0" name="a5637f13db21865305a5d09b123647ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5637f13db21865305a5d09b123647ee0">&#9670;&#160;</a></span>LaunchDataDictInsert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LaunchDataDictInsert </td>
          <td>(</td>
          <td class="paramtype">launch_data_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a7d4549b38faef80da81a53b88b1a27ac" name="a7d4549b38faef80da81a53b88b1a27ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4549b38faef80da81a53b88b1a27ac">&#9670;&#160;</a></span>LaunchDataDictLookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::LaunchDataDictLookup </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a6075a91ef08754a4f6f1d1cc4f4243d2" name="a6075a91ef08754a4f6f1d1cc4f4243d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6075a91ef08754a4f6f1d1cc4f4243d2">&#9670;&#160;</a></span>LaunchDataFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::LaunchDataFree </td>
          <td>(</td>
          <td class="paramtype">launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a6fd262daa89e57ffd897e4b583d44d44" name="a6fd262daa89e57ffd897e4b583d44d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd262daa89e57ffd897e4b583d44d44">&#9670;&#160;</a></span>LaunchDataGetBool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LaunchDataGetBool </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a5637cdc78caedaaadb2c0e47857ccf78" name="a5637cdc78caedaaadb2c0e47857ccf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5637cdc78caedaaadb2c0e47857ccf78">&#9670;&#160;</a></span>LaunchDataGetErrno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int crashpad::LaunchDataGetErrno </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a54549da20f78530f300712625fc0ba5a" name="a54549da20f78530f300712625fc0ba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54549da20f78530f300712625fc0ba5a">&#9670;&#160;</a></span>LaunchDataGetInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long crashpad::LaunchDataGetInteger </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a2f99732a5ea3f2cbc2435e3b3a5ef1ba" name="a2f99732a5ea3f2cbc2435e3b3a5ef1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f99732a5ea3f2cbc2435e3b3a5ef1ba">&#9670;&#160;</a></span>LaunchDataGetOpaque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * crashpad::LaunchDataGetOpaque </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a6ed0f2e24befe2e6faa94445bb03e054" name="a6ed0f2e24befe2e6faa94445bb03e054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed0f2e24befe2e6faa94445bb03e054">&#9670;&#160;</a></span>LaunchDataGetOpaqueSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t crashpad::LaunchDataGetOpaqueSize </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a21114f1a9f28bfb065033f569d466a09" name="a21114f1a9f28bfb065033f569d466a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21114f1a9f28bfb065033f569d466a09">&#9670;&#160;</a></span>LaunchDataGetReal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double crashpad::LaunchDataGetReal </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a00f39dab15fdc32b5e2b2264aeba2480" name="a00f39dab15fdc32b5e2b2264aeba2480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f39dab15fdc32b5e2b2264aeba2480">&#9670;&#160;</a></span>LaunchDataGetString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * crashpad::LaunchDataGetString </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a765503fd97e9e3d622d3b30bff543fb9" name="a765503fd97e9e3d622d3b30bff543fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765503fd97e9e3d622d3b30bff543fb9">&#9670;&#160;</a></span>LaunchDataGetType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_type_t crashpad::LaunchDataGetType </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a19e679e954d2d8ca88ace03ccab5c4df" name="a19e679e954d2d8ca88ace03ccab5c4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e679e954d2d8ca88ace03ccab5c4df">&#9670;&#160;</a></span>LaunchDataNewBool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::LaunchDataNewBool </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>boolean</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a7b4bfcaae95ef3a81e3ec2d27f059bab" name="a7b4bfcaae95ef3a81e3ec2d27f059bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4bfcaae95ef3a81e3ec2d27f059bab">&#9670;&#160;</a></span>LaunchDataNewInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::LaunchDataNewInteger </td>
          <td>(</td>
          <td class="paramtype">long long</td>          <td class="paramname"><span class="paramname"><em>integer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a5af22dade75539fd9e5032acf799c945" name="a5af22dade75539fd9e5032acf799c945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af22dade75539fd9e5032acf799c945">&#9670;&#160;</a></span>LaunchDataNewOpaque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::LaunchDataNewOpaque </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>opaque</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="aa78698056108819fe4bd268cc55801c3" name="aa78698056108819fe4bd268cc55801c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78698056108819fe4bd268cc55801c3">&#9670;&#160;</a></span>LaunchDataNewReal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::LaunchDataNewReal </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>real</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="a7ae48002caa906acb164114bc290b048" name="a7ae48002caa906acb164114bc290b048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae48002caa906acb164114bc290b048">&#9670;&#160;</a></span>LaunchDataNewString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::LaunchDataNewString </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="ae541f07925a67de751502b903af919b4" name="ae541f07925a67de751502b903af919b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae541f07925a67de751502b903af919b4">&#9670;&#160;</a></span>LaunchMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">launch_data_t crashpad::LaunchMsg </td>
          <td>(</td>
          <td class="paramtype">const launch_data_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the <code>&lt;launch.h&gt;</code> function of the same name. </p>
<p>The OS X 10.10 SDK deprecates <code>&lt;launch.h&gt;</code>, although the functionality it provides is still useful. These wrappers allow the deprecated functions to be called without triggering deprecated-declaration warnings. </p>

</div>
</div>
<a id="ab9db00544fd57cfde0bb03d32b989221" name="ab9db00544fd57cfde0bb03d32b989221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9db00544fd57cfde0bb03d32b989221">&#9670;&#160;</a></span>LoggingCloseFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingCloseFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <code>close()</code> or <code>CloseHandle()</code>, logging an error if the operation fails. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, <code>true</code> is returned. On failure, an error is logged and <code>false</code> is returned. </dd></dl>

</div>
</div>
<a id="a7ae84cd353b237bfdf698d40da521568" name="a7ae84cd353b237bfdf698d40da521568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae84cd353b237bfdf698d40da521568">&#9670;&#160;</a></span>LoggingCreateDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingCreateDirectory </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a></td>          <td class="paramname"><span class="paramname"><em>permissions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>may_reuse</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a directory, logging a message on failure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the directory to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>The permissions to use if the directory is created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">may_reuse</td><td>If <code>true</code>, this function will return <code>true</code> if a directory or symbolic link to a directory with path <em class="arg">path</em> already exists. If the directory already exists, it's permissions may differ from <em class="arg">permissions</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the directory is successfully created or it already existed and <em class="arg">may_reuse</em> is <code>true</code>. Otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="acb7b5be59c1293af50753130136aeb32" name="acb7b5be59c1293af50753130136aeb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7b5be59c1293af50753130136aeb32">&#9670;&#160;</a></span>LoggingDetermineMergedRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingDetermineMergedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrashpad_1_1MemorySnapshot.html">MemorySnapshot</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcrashpad_1_1MemorySnapshot.html">MemorySnapshot</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1CheckedRange.html">CheckedRange</a>&lt; uint64_t, size_t &gt; *</td>          <td class="paramname"><span class="paramname"><em>merged</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two memory snapshots, checks if they're overlapping or abutting, and if so, returns the result of merging the two ranges. </p>
<p>This function is useful to implement <a class="el" href="classcrashpad_1_1MemorySnapshot.html#a3a9e0d814cad5450ff684dd484223319" title="Creates a new MemorySnapshot based on merging this one with other.">MemorySnapshot::MergeWithOtherSnapshot()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first range. Must have Size() &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second range. Must have Size() &gt; 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">merged</td><td>The resulting merged range. May be <code>nullptr</code> if only a characterization of the ranges is desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the input ranges overlap or abut, with <em class="arg">merged</em> filled out, otherwise, <code>false</code> with an error logged if <em class="arg">log</em> is <code>true</code>. </dd></dl>

</div>
</div>
<a id="a0224d5a689cdb8c2315c255fd6ea6b5c" name="a0224d5a689cdb8c2315c255fd6ea6b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0224d5a689cdb8c2315c255fd6ea6b5c">&#9670;&#160;</a></span>LoggingFileSizeByHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a73e870ea9156f1bfdff1b998a77cdd9e">FileOffset</a> crashpad::LoggingFileSizeByHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the size of a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The handle to the file for which the size should be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the file. If an error occurs when attempting to determine its size, returns <code>-1</code> with an error logged. </dd></dl>

</div>
</div>
<a id="ab3712d59104f641109b170c78a912b4d" name="ab3712d59104f641109b170c78a912b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3712d59104f641109b170c78a912b4d">&#9670;&#160;</a></span>LoggingOpenFileForRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> crashpad::LoggingOpenFileForRead </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#a7987df05e1260e6d8d93ee3a21e9b0eb" title="Wraps open() or CreateFile(), opening an existing file for reading.">OpenFileForRead()</a>, logging an error if the operation fails. </p>
<dl class="section return"><dt>Returns</dt><dd>The newly opened <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>, or an invalid <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2d3a0ca2e9e37905b425f2cb1b428e7e" title="Scoped wrapper of a FileHandle.">ScopedFileHandle</a> </dd>
<dd>
<a class="el" href="#a62fc6876cc0c660f0ea8bd1dd0a07e82" title="Wraps OpenFileForWrite(), logging an error if the operation fails.">LoggingOpenFileForWrite</a> </dd>
<dd>
<a class="el" href="#aab3e964bdba04aaf74e7a27a36efe108" title="Wraps OpenFileForReadAndWrite(), logging an error if the operation fails.">LoggingOpenFileForReadAndWrite</a> </dd></dl>

</div>
</div>
<a id="aab3e964bdba04aaf74e7a27a36efe108" name="aab3e964bdba04aaf74e7a27a36efe108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3e964bdba04aaf74e7a27a36efe108">&#9670;&#160;</a></span>LoggingOpenFileForReadAndWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> crashpad::LoggingOpenFileForReadAndWrite </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">FileWriteMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a></td>          <td class="paramname"><span class="paramname"><em>permissions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#abe6238b18be49921772c14dd25a624de" title="Wraps open() or CreateFile(), creating a file for both input and output.">OpenFileForReadAndWrite()</a>, logging an error if the operation fails. </p>
<dl class="section return"><dt>Returns</dt><dd>The newly opened <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>, or an invalid <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2d3a0ca2e9e37905b425f2cb1b428e7e" title="Scoped wrapper of a FileHandle.">ScopedFileHandle</a> </dd>
<dd>
<a class="el" href="#ab3712d59104f641109b170c78a912b4d" title="Wraps OpenFileForRead(), logging an error if the operation fails.">LoggingOpenFileForRead</a> </dd>
<dd>
<a class="el" href="#a62fc6876cc0c660f0ea8bd1dd0a07e82" title="Wraps OpenFileForWrite(), logging an error if the operation fails.">LoggingOpenFileForWrite</a> </dd></dl>

</div>
</div>
<a id="a62fc6876cc0c660f0ea8bd1dd0a07e82" name="a62fc6876cc0c660f0ea8bd1dd0a07e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62fc6876cc0c660f0ea8bd1dd0a07e82">&#9670;&#160;</a></span>LoggingOpenFileForWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> crashpad::LoggingOpenFileForWrite </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">FileWriteMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a></td>          <td class="paramname"><span class="paramname"><em>permissions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#ad8e8848af82384f7757108c8c445f18d" title="Wraps open() or CreateFile(), creating a file for output.">OpenFileForWrite()</a>, logging an error if the operation fails. </p>
<dl class="section return"><dt>Returns</dt><dd>The newly opened <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>, or an invalid <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2d3a0ca2e9e37905b425f2cb1b428e7e" title="Scoped wrapper of a FileHandle.">ScopedFileHandle</a> </dd>
<dd>
<a class="el" href="#ab3712d59104f641109b170c78a912b4d" title="Wraps OpenFileForRead(), logging an error if the operation fails.">LoggingOpenFileForRead</a> </dd>
<dd>
<a class="el" href="#aab3e964bdba04aaf74e7a27a36efe108" title="Wraps OpenFileForReadAndWrite(), logging an error if the operation fails.">LoggingOpenFileForReadAndWrite</a> </dd></dl>

</div>
</div>
<a id="a300ac399f9d33a4c47b4e4c148ebbe7c" name="a300ac399f9d33a4c47b4e4c148ebbe7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300ac399f9d33a4c47b4e4c148ebbe7c">&#9670;&#160;</a></span>LoggingReadEntireFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingReadEntireFile </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>contents</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#ab3712d59104f641109b170c78a912b4d" title="Wraps OpenFileForRead(), logging an error if the operation fails.">LoggingOpenFileForRead()</a> and <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> reading the entire file into <em class="arg">contents</em>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, or <code>false</code> with a message logged. </dd></dl>

</div>
</div>
<a id="ac3fb8955565f605e08c1e30562fbdb7a" name="ac3fb8955565f605e08c1e30562fbdb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fb8955565f605e08c1e30562fbdb7a">&#9670;&#160;</a></span>LoggingReadFileExactly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingReadFileExactly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, retrying following a short read, ensuring that exactly <em class="arg">size</em> bytes are read. Logs an error on failure. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Returns <code>false</code> if the underlying <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> fails or if fewer than <em class="arg">size</em> bytes were read.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8a91af9c690d2a280c463596bf82070b" title="Wraps WriteFile(), ensuring that exactly size bytes are written.">LoggingWriteFile</a> </dd>
<dd>
<a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile</a> </dd>
<dd>
<a class="el" href="#a6e685af255d9b71fb46ed2679329dd7c" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">ReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ab37c2677a36c7cf97be67103a3a5b5a6" title="Wraps ReadFile(), retrying following a short read. Does not log on failure.">ReadFileUntil</a> </dd>
<dd>
<a class="el" href="#a13522930fa21f678aefd0bcd1ba2ce92" title="Wraps ReadFile(), retrying following a short read. Logs an error on failure.">LoggingReadFileUntil</a> </dd>
<dd>
<a class="el" href="#a00e03e19185b0fde6301be6b113628cb" title="Wraps ReadFile(), ensuring that exactly size bytes are read.">CheckedReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ac8e7e1b1a4b89b489964ffee54d0d9df" title="Wraps ReadFile(), ensuring that it indicates end-of-file.">CheckedReadFileAtEOF</a> </dd></dl>

</div>
</div>
<a id="a13522930fa21f678aefd0bcd1ba2ce92" name="a13522930fa21f678aefd0bcd1ba2ce92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13522930fa21f678aefd0bcd1ba2ce92">&#9670;&#160;</a></span>LoggingReadFileUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9cbae3880f57681cd84026b2c5a042ca">FileOperationResult</a> crashpad::LoggingReadFileUntil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, retrying following a short read. Logs an error on failure. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or <code>-1</code> if the underlying <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> fails.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6e685af255d9b71fb46ed2679329dd7c" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">ReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ab37c2677a36c7cf97be67103a3a5b5a6" title="Wraps ReadFile(), retrying following a short read. Does not log on failure.">ReadFileUntil</a> </dd>
<dd>
<a class="el" href="#ac3fb8955565f605e08c1e30562fbdb7a" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">LoggingReadFileExactly</a> </dd>
<dd>
<a class="el" href="#a00e03e19185b0fde6301be6b113628cb" title="Wraps ReadFile(), ensuring that exactly size bytes are read.">CheckedReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ac8e7e1b1a4b89b489964ffee54d0d9df" title="Wraps ReadFile(), ensuring that it indicates end-of-file.">CheckedReadFileAtEOF</a> </dd></dl>

</div>
</div>
<a id="ae52dab87e27350dd4c70ea4c8ac258cc" name="ae52dab87e27350dd4c70ea4c8ac258cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52dab87e27350dd4c70ea4c8ac258cc">&#9670;&#160;</a></span>LoggingReadToEOF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingReadToEOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>contents</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> to read from the current file position to the end of the file into <em class="arg">contents</em>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, or <code>false</code> with a message logged. </dd></dl>

</div>
</div>
<a id="a7fdc84fcc207cf0b718626997d11ad04" name="a7fdc84fcc207cf0b718626997d11ad04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdc84fcc207cf0b718626997d11ad04">&#9670;&#160;</a></span>LoggingRemoveDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingRemoveDirectory </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-recurseively removes an empty directory, logging a message on failure. </p>
<p>This function will not remove symbolic links to directories.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The to the directory to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the directory was removed. Otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac7c5ccd8661bd87eed66eae26fb9e0d3" name="ac7c5ccd8661bd87eed66eae26fb9e0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c5ccd8661bd87eed66eae26fb9e0d3">&#9670;&#160;</a></span>LoggingRemoveFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingRemoveFile </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a file or a symbolic link to a file or directory, logging a message on failure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the file to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a3d6cedc10e24145d4a0c1000c33f8a10" name="a3d6cedc10e24145d4a0c1000c33f8a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6cedc10e24145d4a0c1000c33f8a10">&#9670;&#160;</a></span>LoggingSeekFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a73e870ea9156f1bfdff1b998a77cdd9e">FileOffset</a> crashpad::LoggingSeekFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a73e870ea9156f1bfdff1b998a77cdd9e">FileOffset</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>whence</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <code>lseek()</code> or <code>SetFilePointerEx()</code>. Logs an error if the operation fails. </p>
<p>Repositions the offset of the open <em class="arg">file</em> to the specified <em class="arg">offset</em>, relative to <em class="arg">whence</em>. <em class="arg">whence</em> must be one of <code>SEEK_SET</code>, <code>SEEK_CUR</code>, or <code>SEEK_END</code>, and is interpreted in the usual way.</p>
<dl class="section return"><dt>Returns</dt><dd>The resulting offset in bytes from the beginning of the file, or <code>-1</code> on failure. </dd></dl>

</div>
</div>
<a id="a06ba30c1a4b2974f1d4ea842db55b068" name="a06ba30c1a4b2974f1d4ea842db55b068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ba30c1a4b2974f1d4ea842db55b068">&#9670;&#160;</a></span>LoggingTruncateFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingTruncateFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncates the given <em class="arg">file</em> to zero bytes in length. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, or <code>false</code>, and a message will be logged. </dd></dl>

</div>
</div>
<a id="a8a91af9c690d2a280c463596bf82070b" name="a8a91af9c690d2a280c463596bf82070b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a91af9c690d2a280c463596bf82070b">&#9670;&#160;</a></span>LoggingWriteFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::LoggingWriteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4" title="Writes to a file, retrying when interrupted on POSIX or following a short write.">WriteFile()</a>, ensuring that exactly <em class="arg">size</em> bytes are written. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. If the underlying <a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4" title="Writes to a file, retrying when interrupted on POSIX or following a short write.">WriteFile()</a> fails, or if fewer than <em class="arg">size</em> bytes were written, this function logs a message and returns <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac3fb8955565f605e08c1e30562fbdb7a" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">LoggingReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4" title="Writes to a file, retrying when interrupted on POSIX or following a short write.">WriteFile</a> </dd>
<dd>
<a class="el" href="#a74c74fefa3b1f5e0c1b885755c9f9cf6" title="Wraps WriteFile(), ensuring that exactly size bytes are written.">CheckedWriteFile</a> </dd></dl>

</div>
</div>
<a id="aa31f495c675536bcb30d1267c3a9b696" name="aa31f495c675536bcb30d1267c3a9b696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31f495c675536bcb30d1267c3a9b696">&#9670;&#160;</a></span>MachMessageDeadlineFromTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abd63ad5a7c13f493e8d1e37ef7801bce">MachMessageDeadline</a> crashpad::MachMessageDeadlineFromTimeout </td>
          <td>(</td>
          <td class="paramtype">mach_msg_timeout_t</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the deadline for a specified timeout value. </p>
<p>While deadlines exist on an absolute time scale, timeouts are relative. This function calculates the deadline as <em class="arg">timeout_ms</em> milliseconds after it executes.</p>
<p>If <em class="arg">timeout_ms</em> is <a class="el" href="#a1aaf1be45de9c694fb5e4169b963a64da6461bf9de012b5f2305fb3da6d0f82d5" title="MachMessageWithDeadline() should not block at all in its operation.">kMachMessageDeadlineNonblocking</a>, this function will return <a class="el" href="#a1aaf1be45de9c694fb5e4169b963a64da6461bf9de012b5f2305fb3da6d0f82d5" title="MachMessageWithDeadline() should not block at all in its operation.">kMachMessageDeadlineNonblocking</a>. If <em class="arg">timeout_ms</em> is <a class="el" href="#af2bdc8a7a2af1fc2459cad703879884daaf4f2c8a649ea6bcfe896e77c312315f" title="When passed to MachMessageDeadlineFromTimeout(), that function will return kMachMessageDeadlineWaitIn...">kMachMessageTimeoutWaitIndefinitely</a>, this function will return <a class="el" href="#a1aaf1be45de9c694fb5e4169b963a64da848a739b3c252f4565161a6bd3f070d6" title="MachMessageWithDeadline() should wait indefinitely for the requested operation to complete.">kMachMessageDeadlineWaitIndefinitely</a>. </p>

</div>
</div>
<a id="a2670a96d46f33b0e88db50a6222c0b47" name="a2670a96d46f33b0e88db50a6222c0b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2670a96d46f33b0e88db50a6222c0b47">&#9670;&#160;</a></span>MachMessageDestroyReceivedPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::MachMessageDestroyReceivedPort </td>
          <td>(</td>
          <td class="paramtype">mach_port_t</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_msg_type_name_t</td>          <td class="paramname"><span class="paramname"><em>port_right_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys or deallocates a Mach port received in a Mach message. </p>
<p>This function disposes of port rights received in a Mach message. Receive rights will be destroyed with <code>mach_port_mod_refs()</code>. Send and send-once rights will be deallocated with <code>mach_port_deallocate()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The port to destroy or deallocate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_right_type</td><td>The right type held for <em class="arg">port:</em> <code>MACH_MSG_TYPE_PORT_RECEIVE</code>, <code>MACH_MSG_TYPE_PORT_SEND</code>, or <code>MACH_MSG_TYPE_PORT_SEND_ONCE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, or <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a979ca1d327dcf56488d3304efa9680eb" name="a979ca1d327dcf56488d3304efa9680eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979ca1d327dcf56488d3304efa9680eb">&#9670;&#160;</a></span>MachMessageTrailerFromHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const mach_msg_trailer_t * crashpad::MachMessageTrailerFromHeader </td>
          <td>(</td>
          <td class="paramtype">const mach_msg_header_t *</td>          <td class="paramname"><span class="paramname"><em>header</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Mach message trailer for a message that has been received. </p>
<p>This function must only be called on Mach messages that have been received via the Mach messaging interface, such as <code>mach_msg()</code>. Messages constructed for sending do not contain trailers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>A pointer to a received Mach message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the trailer following the received Mach message’s body. The contents of the trailer depend on the options provided to <code>mach_msg()</code> or a similar function when the message was received. </dd></dl>

</div>
</div>
<a id="a35293418a0b7637a00631807ac4b431e" name="a35293418a0b7637a00631807ac4b431e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35293418a0b7637a00631807ac4b431e">&#9670;&#160;</a></span>MachMessageWithDeadline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mach_msg_return_t crashpad::MachMessageWithDeadline </td>
          <td>(</td>
          <td class="paramtype">mach_msg_header_t *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_msg_option_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_msg_size_t</td>          <td class="paramname"><span class="paramname"><em>receive_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_port_name_t</td>          <td class="paramname"><span class="paramname"><em>receive_port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abd63ad5a7c13f493e8d1e37ef7801bce">MachMessageDeadline</a></td>          <td class="paramname"><span class="paramname"><em>deadline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_port_name_t</td>          <td class="paramname"><span class="paramname"><em>notify_port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>run_even_if_expired</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs <code>mach_msg()</code> with a deadline, as opposed to a timeout. </p>
<p>This function is similar to <code>mach_msg()</code>, with the following differences:</p><ul>
<li>The <code>timeout</code> parameter has been replaced by <em class="arg">deadline</em>. The deadline applies uniformly to a call that is requested to both send and receive a message.</li>
<li>The <code>MACH_SEND_TIMEOUT</code> and <code>MACH_RCV_TIMEOUT</code> bits in <em class="arg">options</em> are not used. Timeouts are specified by the <em class="arg">deadline</em> argument.</li>
<li>The <code>send_size</code> parameter has been removed. Its value is implied by <em class="arg">message</em> when <em class="arg">options</em> contains <code>MACH_SEND_MSG</code>.</li>
<li>The <em class="arg">run_even_if_expired</em> parameter has been added.</li>
</ul>
<p>Like the <code>mach_msg()</code> wrapper in <code>libsyscall</code>, this function will retry operations when experiencing <code>MACH_SEND_INTERRUPTED</code> and <code>MACH_RCV_INTERRUPTED</code>, unless <em class="arg">options</em> contains <code>MACH_SEND_INTERRUPT</code> or <code>MACH_RCV_INTERRUPT</code>. Unlike <code>mach_msg()</code>, which restarts the call with the full timeout when this occurs, this function continues enforcing the user-specified <em class="arg">deadline</em>.</p>
<p>Except as noted, the parameters and return value are identical to those of <code>mach_msg()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">message</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">receive_size</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">receive_port</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deadline</td><td>The time by which this call should complete. If the deadline is exceeded, this call will return <code>MACH_SEND_TIMED_OUT</code> or <code>MACH_RCV_TIMED_OUT</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify_port</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">run_even_if_expired</td><td>If <code>true</code>, a deadline that is expired when this function is called will be treated as though a deadline of <a class="el" href="#a1aaf1be45de9c694fb5e4169b963a64da6461bf9de012b5f2305fb3da6d0f82d5" title="MachMessageWithDeadline() should not block at all in its operation.">kMachMessageDeadlineNonblocking</a> had been specified. When <code>false</code>, an expired deadline will result in a <code>MACH_SEND_TIMED_OUT</code> or <code>MACH_RCV_TIMED_OUT</code> return value, even if the deadline is already expired when the function is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of <code>mach_msg()</code> </dd></dl>

</div>
</div>
<a id="a79ee9764b34c0267b58f54404946275a" name="a79ee9764b34c0267b58f54404946275a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ee9764b34c0267b58f54404946275a">&#9670;&#160;</a></span>MachThreadSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">thread_t crashpad::MachThreadSelf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>mach_thread_self()</code>, but without the obligation to release the send right. </p>
<p><code>mach_thread_self()</code> returns a send right to the current thread port, incrementing its reference count. This burdens the caller with maintaining this send right, and calling <code>mach_port_deallocate()</code> when it is no longer needed. This is burdensome, and is at odds with the normal operation of <code>mach_task_self()</code>, which does not increment the task port’s reference count whose result must not be deallocated.</p>
<p>Callers can use this function in preference to <code>mach_thread_self()</code>. This function returns an extant reference to the current thread’s port without incrementing its reference count.</p>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>mach_thread_self()</code> without incrementing its reference count. The returned port must not be deallocated by <code>mach_port_deallocate()</code>. The returned value is valid as long as the thread continues to exist as a <code>pthread_t</code>. </dd></dl>

</div>
</div>
<a id="a71c79500b827d06b190e30b7cc016c35" name="a71c79500b827d06b190e30b7cc016c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c79500b827d06b190e30b7cc016c35">&#9670;&#160;</a></span>MacModelAndBoard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::MacModelAndBoard </td>
          <td>(</td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>board_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the model name and board ID of the running system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">model</td><td>The system’s model name. A mid-2012 15" MacBook Pro would report “MacBookPro10,1”. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">board_id</td><td>The system’s board ID. A mid-2012 15" MacBook Pro would report “Mac-C3EC7CD22292981F”.</td></tr>
  </table>
  </dd>
</dl>
<p>If a value cannot be determined, its string is cleared. </p>

</div>
</div>
<a id="a458272b3e9c9b83b2643c6f3bdf72924" name="a458272b3e9c9b83b2643c6f3bdf72924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458272b3e9c9b83b2643c6f3bdf72924">&#9670;&#160;</a></span>MacOSVersionComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::MacOSVersionComponents </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>major</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>minor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>bugfix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>build</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>version_string</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the version of the running operating system. </p>
<p>All parameters are required. No parameter may be <code>nullptr</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">major</td><td>The major version of the operating system, such as <code>10</code> for macOS 10.12.1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minor</td><td>The major version of the operating system, such as <code>12</code> for macOS 10.12.1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bugfix</td><td>The bugfix version of the operating system, such as <code>1</code> for macOS 10.12.1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">build</td><td>The operating system’s build string, such as <code>"16B2657"</code> for macOS 10.12.1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">version_string</td><td>A string representing the full operating system version, such as <code>"macOS 10.12.1 (16B2657)"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure, with an error message logged. A failure is considered to have occurred if any element could not be determined. When this happens, their values will be untouched, but other values that could be determined will still be set properly. </dd></dl>

</div>
</div>
<a id="abce484227aa401de226e81e42b6dfabd" name="abce484227aa401de226e81e42b6dfabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce484227aa401de226e81e42b6dfabd">&#9670;&#160;</a></span>MacOSVersionNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crashpad::MacOSVersionNumber </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the version of the running operating system. </p>
<dl class="section return"><dt>Returns</dt><dd>The version of the operating system, such as <code>10'15'06</code> for macOS 10.15.6.</dd></dl>
<p>The format of the return value matches what is used by the &lt;Availability.h&gt; <code>__MAC_OS_X_VERSION_MIN_REQUIRED</code>, <code>__MAC_OS_X_VERSION_MAX_ALLOWED</code>, and per-version <code>__MAC_*</code> macros, for versions since OS X 10.10.</p>
<p>On macOS 10.13.4 and later, this function will return the major, minor, and bugfix components combined into a single number. On older OS versions, only the major and minor components will be returned, and the bugfix component will always be reported as 0. By contrast, <a class="el" href="#a458272b3e9c9b83b2643c6f3bdf72924" title="Returns the version of the running operating system.">MacOSVersionComponents()</a> always returns the bugfix component.</p>
<dl class="section note"><dt>Note</dt><dd>This is similar to the base::mac::IsOS*() family of functions, but is provided for situations where the caller needs to obtain version information beyond what is provided by Chromium’s base, or for when the caller needs the actual minor version value. </dd></dl>

</div>
</div>
<a id="a0486df983d8e9cecbe1e46e0059806df" name="a0486df983d8e9cecbe1e46e0059806df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0486df983d8e9cecbe1e46e0059806df">&#9670;&#160;</a></span>MapInsertOrReplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::MapInsertOrReplace </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::mapped_type &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename T::mapped_type *</td>          <td class="paramname"><span class="paramname"><em>old_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a mapping from <em class="arg">key</em> to <em class="arg">value</em> into <em class="arg">map</em>, or replaces an existing mapping so that <em class="arg">key</em> maps to <em class="arg">value</em>. </p>
<p>This behaves similarly to <code>std::map&lt;&gt;::insert_or_assign()</code> proposed for C++17, except that the <em class="arg">old_value</em> parameter is added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">map</td><td>The map to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key that should be mapped to <em class="arg">value</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value that <em class="arg">key</em> should map to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">old_value</td><td>If <em class="arg">key</em> was previously present in <em class="arg">map</em>, this will be set to its previous value. This parameter is optional and may be <code>nullptr</code> if this information is not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if <em class="arg">key</em> was previously present in <em class="arg">map</em>. If <em class="arg">old_value</em> is not <code>nullptr</code>, it will be set to the previous value. <code>true</code> if <em class="arg">key</em> was not present in the map and was inserted. </dd></dl>

</div>
</div>
<a id="a7e5ef254327bfa348cc23cd21893b29e" name="a7e5ef254327bfa348cc23cd21893b29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5ef254327bfa348cc23cd21893b29e">&#9670;&#160;</a></span>MoveFileOrDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::MoveFileOrDirectory </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a file, symbolic link, or directory, logging a message on failure. </p>
<p><em class="arg">source</em> must exist and refer to a file, symbolic link, or directory.</p>
<p><em class="arg">source</em> and <em class="arg">dest</em> must be on the same filesystem.</p>
<p>If <em class="arg">dest</em> exists, it may be overwritten:</p>
<p>If <em class="arg">dest</em> exists and refers to a file or to a live or dangling symbolic link to a file, it will be overwritten if <em class="arg">source</em> also refers to a file or to a live or dangling symbolic link to a file or directory.</p>
<p>On POSIX, if <em class="arg">dest</em> refers to a directory, it will be overwritten only if it is empty and <em class="arg">source</em> also refers to a directory.</p>
<p>On Windows, if <em class="arg">dest</em> refers to a directory or to a live or dangling symbolic link to a directory, it will not be overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The path to the file to be moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>The new path for the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a9c9bc6ad9973f794c425707617b63278" name="a9c9bc6ad9973f794c425707617b63278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9bc6ad9973f794c425707617b63278">&#9670;&#160;</a></span>NewMachPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mach_port_t crashpad::NewMachPort </td>
          <td>(</td>
          <td class="paramtype">mach_port_right_t</td>          <td class="paramname"><span class="paramname"><em>right</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Mach port in the current task. </p>
<p>This function wraps the <code>mach_port_allocate()</code> providing a simpler interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The type of right to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new Mach port. On failure, <code>MACH_PORT_NULL</code> with a message logged. </dd></dl>

</div>
</div>
<a id="a7987df05e1260e6d8d93ee3a21e9b0eb" name="a7987df05e1260e6d8d93ee3a21e9b0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7987df05e1260e6d8d93ee3a21e9b0eb">&#9670;&#160;</a></span>OpenFileForRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> crashpad::OpenFileForRead </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <code>open()</code> or <code>CreateFile()</code>, opening an existing file for reading. </p>
<dl class="section return"><dt>Returns</dt><dd>The newly opened <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>, or an invalid <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2d3a0ca2e9e37905b425f2cb1b428e7e" title="Scoped wrapper of a FileHandle.">ScopedFileHandle</a> </dd>
<dd>
<a class="el" href="#ad8e8848af82384f7757108c8c445f18d" title="Wraps open() or CreateFile(), creating a file for output.">OpenFileForWrite</a> </dd>
<dd>
<a class="el" href="#abe6238b18be49921772c14dd25a624de" title="Wraps open() or CreateFile(), creating a file for both input and output.">OpenFileForReadAndWrite</a> </dd>
<dd>
<a class="el" href="#ab3712d59104f641109b170c78a912b4d" title="Wraps OpenFileForRead(), logging an error if the operation fails.">LoggingOpenFileForRead</a> </dd></dl>

</div>
</div>
<a id="abe6238b18be49921772c14dd25a624de" name="abe6238b18be49921772c14dd25a624de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6238b18be49921772c14dd25a624de">&#9670;&#160;</a></span>OpenFileForReadAndWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> crashpad::OpenFileForReadAndWrite </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">FileWriteMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a></td>          <td class="paramname"><span class="paramname"><em>permissions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <code>open()</code> or <code>CreateFile()</code>, creating a file for both input and output. </p>
<p><em class="arg">mode</em> determines the style (truncate, reuse, etc.) that is used to open the file. On POSIX, <em class="arg">permissions</em> determines the value that is passed as <code>mode</code> to <code>open()</code>. On Windows, the file is always opened in binary mode (that is, no CRLF translation). On Windows, the file is opened for sharing, see LoggingLockFile() and LoggingUnlockFile() to control concurrent access.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly opened <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>, or an invalid <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2d3a0ca2e9e37905b425f2cb1b428e7e" title="Scoped wrapper of a FileHandle.">ScopedFileHandle</a> </dd>
<dd>
<a class="el" href="#a7987df05e1260e6d8d93ee3a21e9b0eb" title="Wraps open() or CreateFile(), opening an existing file for reading.">OpenFileForRead</a> </dd>
<dd>
<a class="el" href="#ad8e8848af82384f7757108c8c445f18d" title="Wraps open() or CreateFile(), creating a file for output.">OpenFileForWrite</a> </dd>
<dd>
<a class="el" href="#aab3e964bdba04aaf74e7a27a36efe108" title="Wraps OpenFileForReadAndWrite(), logging an error if the operation fails.">LoggingOpenFileForReadAndWrite</a> </dd></dl>

</div>
</div>
<a id="ad8e8848af82384f7757108c8c445f18d" name="ad8e8848af82384f7757108c8c445f18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e8848af82384f7757108c8c445f18d">&#9670;&#160;</a></span>OpenFileForWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> crashpad::OpenFileForWrite </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afa69b0967d9a6df659ff5d2a02ff3e51">FileWriteMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a034ccc90eb0d1f587ee89275d822175d">FilePermissions</a></td>          <td class="paramname"><span class="paramname"><em>permissions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <code>open()</code> or <code>CreateFile()</code>, creating a file for output. </p>
<p><em class="arg">mode</em> determines the style (truncate, reuse, etc.) that is used to open the file. On POSIX, <em class="arg">permissions</em> determines the value that is passed as <code>mode</code> to <code>open()</code>. On Windows, the file is always opened in binary mode (that is, no CRLF translation). On Windows, the file is opened for sharing, see LoggingLockFile() and LoggingUnlockFile() to control concurrent access.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly opened <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a>, or an invalid <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2d3a0ca2e9e37905b425f2cb1b428e7e" title="Scoped wrapper of a FileHandle.">ScopedFileHandle</a> </dd>
<dd>
<a class="el" href="#a7987df05e1260e6d8d93ee3a21e9b0eb" title="Wraps open() or CreateFile(), opening an existing file for reading.">OpenFileForRead</a> </dd>
<dd>
<a class="el" href="#abe6238b18be49921772c14dd25a624de" title="Wraps open() or CreateFile(), creating a file for both input and output.">OpenFileForReadAndWrite</a> </dd>
<dd>
<a class="el" href="#a62fc6876cc0c660f0ea8bd1dd0a07e82" title="Wraps OpenFileForWrite(), logging an error if the operation fails.">LoggingOpenFileForWrite</a> </dd></dl>

</div>
</div>
<a id="a2274adc0459f68b93ffe51d8f975f14e" name="a2274adc0459f68b93ffe51d8f975f14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2274adc0459f68b93ffe51d8f975f14e">&#9670;&#160;</a></span>PrepareMIGReplyFromRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::PrepareMIGReplyFromRequest </td>
          <td>(</td>
          <td class="paramtype">const mach_msg_header_t *</td>          <td class="paramname"><span class="paramname"><em>in_header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_msg_header_t *</td>          <td class="paramname"><span class="paramname"><em>out_header</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a reply message for a MIG server routine based on its corresponding request. </p>
<p>If a request is handled by a server routine, it may be necessary to revise some of the fields set by this function, such as <code>msgh_size</code> and any fields defined in a routine’s reply structure type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_header</td><td>The request message to base the reply on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_header</td><td>The reply message to initialize. <em class="arg">out_header</em> will be treated as a <code>mig_reply_error_t*</code> and all of its fields will be set except for <code>RetCode</code>, which must be set by <a class="el" href="#aa023691aedd4f3e6faa923e8d2095947" title="Sets the error code in a reply message for a MIG server routine.">SetMIGReplyError()</a>. This argument is accepted as a <code>mach_msg_header_t*</code> instead of a <code>mig_reply_error_t*</code> because that is the type that callers are expected to possess in the C API. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1767bc31528e1f4cfb4070855e6da96d" name="a1767bc31528e1f4cfb4070855e6da96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1767bc31528e1f4cfb4070855e6da96d">&#9670;&#160;</a></span>PruneCrashReportDatabase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t crashpad::PruneCrashReportDatabase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1CrashReportDatabase.html">CrashReportDatabase</a> *</td>          <td class="paramname"><span class="paramname"><em>database</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1PruneCondition.html">PruneCondition</a> *</td>          <td class="paramname"><span class="paramname"><em>condition</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes crash reports from <em class="arg">database</em> that match <em class="arg">condition</em>. </p>
<p>This function can be used to remove old or large reports from the database. The <em class="arg">condition</em> will be evaluated against each report in the <em class="arg">database</em>, sorted in descending order by <a class="el" href="structcrashpad_1_1CrashReportDatabase_1_1Report.html#a8011cd1a4b4fcd84ecbc21e5c5fd80b8" title="The time at which the report was generated.">CrashReportDatabase::Report::creation_time</a>. This guarantee allows conditions to be stateful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The database from which crash reports will be deleted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The condition against which all reports in the database will be evaluated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of deleted crash reports. </dd></dl>

</div>
</div>
<a id="ad304b11e44d0683d30518e2d0e1f92f5" name="ad304b11e44d0683d30518e2d0e1f92f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad304b11e44d0683d30518e2d0e1f92f5">&#9670;&#160;</a></span>PtraceAttach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::PtraceAttach </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>can_log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches to the process with process ID <em class="arg">pid</em> and blocks until the target process has stopped by calling <code>waitpid()</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>The process ID of the process to attach to. </td></tr>
    <tr><td class="paramname">can_log</td><td>Whether this function may log messages on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. <code>false</code> on failure with a message logged if <em class="arg">can_log</em> is <code>true</code>. </dd></dl>

</div>
</div>
<a id="af84984fc383ee4c9e22e6cdc25fd700f" name="af84984fc383ee4c9e22e6cdc25fd700f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84984fc383ee4c9e22e6cdc25fd700f">&#9670;&#160;</a></span>PtraceDetach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::PtraceDetach </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>can_log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the process with process ID <em class="arg">pid</em>. The process must already be ptrace attached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>The process ID of the process to detach. </td></tr>
    <tr><td class="paramname">can_log</td><td>Whether this function may log messages on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. <code>false</code> on failure with a message logged if <em class="arg">can_log</em> is <code>true</code>. </dd></dl>

</div>
</div>
<a id="ab15d0aff86a0aafe6f33cbd8913441c7" name="ab15d0aff86a0aafe6f33cbd8913441c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15d0aff86a0aafe6f33cbd8913441c7">&#9670;&#160;</a></span>RandomString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::RandomString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random string. </p>
<p>The string consists of 16 uppercase characters chosen at random. The returned string has over 75 bits of randomness (26<sup>16</sup> &gt; 2<sup>75</sup>). </p>

</div>
</div>
<a id="aa8f086bf42672cc9deccc4f93301478a" name="aa8f086bf42672cc9deccc4f93301478a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f086bf42672cc9deccc4f93301478a">&#9670;&#160;</a></span>ReadAllowedAnnotations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ReadAllowedAnnotations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrashpad_1_1ProcessMemoryRange.html">ProcessMemoryRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>memory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a></td>          <td class="paramname"><span class="paramname"><em>list_address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>allowed_annotations</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a list of allowed annotations from another process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memory</td><td>A memory reader for the target process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list_address</td><td>The address in the target process' address space of a nullptr terminated array of NUL-terminated strings. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allowed_annotations</td><td>The list read, valid only if this function returns <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="af4f3d401cee57d9776ad3d338111a95c" name="af4f3d401cee57d9776ad3d338111a95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f3d401cee57d9776ad3d338111a95c">&#9670;&#160;</a></span>ReadAllowedMemoryRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ReadAllowedMemoryRanges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcrashpad_1_1ProcessMemoryRange.html">ProcessMemoryRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>memory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a></td>          <td class="paramname"><span class="paramname"><em>list_address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a>, <a class="el" href="#a3b472f487657ece8e0a9a662a13b2256">VMAddress</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>allowed_memory_ranges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a list of allowed memory ranges from another process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memory</td><td>A memory reader for the target process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list_address</td><td>The address in the target process' address space of a nullptr terminated array of NUL-terminated strings. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allowed_memory_ranges</td><td>A list of allowed memory regions, valid only if this function returns <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a8599600814a17d622766decd5f122a96" name="a8599600814a17d622766decd5f122a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8599600814a17d622766decd5f122a96">&#9670;&#160;</a></span>ReadFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9cbae3880f57681cd84026b2c5a042ca">FileOperationResult</a> crashpad::ReadFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads from a file, retrying when interrupted before reading any data on POSIX. </p>
<p>This function reads into <em class="arg">buffer</em>. Fewer than <em class="arg">size</em> bytes may be read. On Windows, reading from sockets is not currently supported.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read and placed into <em class="arg">buffer</em>, or <code>-1</code> on error, with <code>errno</code> or <code>GetLastError()</code> set appropriately. On error, a portion of <em class="arg">file</em> may have been read into <em class="arg">buffer</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ada530c306bf30e9ed9274c20d05c0db4" title="Writes to a file, retrying when interrupted on POSIX or following a short write.">WriteFile</a> </dd>
<dd>
<a class="el" href="#a6e685af255d9b71fb46ed2679329dd7c" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">ReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ab37c2677a36c7cf97be67103a3a5b5a6" title="Wraps ReadFile(), retrying following a short read. Does not log on failure.">ReadFileUntil</a> </dd>
<dd>
<a class="el" href="#ac3fb8955565f605e08c1e30562fbdb7a" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">LoggingReadFileExactly</a> </dd>
<dd>
<a class="el" href="#a13522930fa21f678aefd0bcd1ba2ce92" title="Wraps ReadFile(), retrying following a short read. Logs an error on failure.">LoggingReadFileUntil</a> </dd>
<dd>
<a class="el" href="#a00e03e19185b0fde6301be6b113628cb" title="Wraps ReadFile(), ensuring that exactly size bytes are read.">CheckedReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ac8e7e1b1a4b89b489964ffee54d0d9df" title="Wraps ReadFile(), ensuring that it indicates end-of-file.">CheckedReadFileAtEOF</a> </dd></dl>

</div>
</div>
<a id="a6e685af255d9b71fb46ed2679329dd7c" name="a6e685af255d9b71fb46ed2679329dd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e685af255d9b71fb46ed2679329dd7c">&#9670;&#160;</a></span>ReadFileExactly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ReadFileExactly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, retrying following a short read, ensuring that exactly <em class="arg">size</em> bytes are read. Does not log on failure. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Returns <code>false</code> if the underlying <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> fails or if fewer than <em class="arg">size</em> bytes were read.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8a91af9c690d2a280c463596bf82070b" title="Wraps WriteFile(), ensuring that exactly size bytes are written.">LoggingWriteFile</a> </dd>
<dd>
<a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile</a> </dd>
<dd>
<a class="el" href="#ab37c2677a36c7cf97be67103a3a5b5a6" title="Wraps ReadFile(), retrying following a short read. Does not log on failure.">ReadFileUntil</a> </dd>
<dd>
<a class="el" href="#ac3fb8955565f605e08c1e30562fbdb7a" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">LoggingReadFileExactly</a> </dd>
<dd>
<a class="el" href="#a13522930fa21f678aefd0bcd1ba2ce92" title="Wraps ReadFile(), retrying following a short read. Logs an error on failure.">LoggingReadFileUntil</a> </dd>
<dd>
<a class="el" href="#a00e03e19185b0fde6301be6b113628cb" title="Wraps ReadFile(), ensuring that exactly size bytes are read.">CheckedReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ac8e7e1b1a4b89b489964ffee54d0d9df" title="Wraps ReadFile(), ensuring that it indicates end-of-file.">CheckedReadFileAtEOF</a> </dd></dl>

</div>
</div>
<a id="ab37c2677a36c7cf97be67103a3a5b5a6" name="ab37c2677a36c7cf97be67103a3a5b5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37c2677a36c7cf97be67103a3a5b5a6">&#9670;&#160;</a></span>ReadFileUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9cbae3880f57681cd84026b2c5a042ca">FileOperationResult</a> crashpad::ReadFileUntil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a>, retrying following a short read. Does not log on failure. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or <code>-1</code> if the underlying <a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile()</a> fails.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile</a> </dd>
<dd>
<a class="el" href="#a6e685af255d9b71fb46ed2679329dd7c" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">ReadFileExactly</a> </dd>
<dd>
<a class="el" href="#ac3fb8955565f605e08c1e30562fbdb7a" title="Wraps ReadFile(), retrying following a short read, ensuring that exactly size bytes are read....">LoggingReadFileExactly</a> </dd>
<dd>
<a class="el" href="#a13522930fa21f678aefd0bcd1ba2ce92" title="Wraps ReadFile(), retrying following a short read. Logs an error on failure.">LoggingReadFileUntil</a> </dd></dl>

</div>
</div>
<a id="a33fd86bc618d758d07c29304df9fbf4f" name="a33fd86bc618d758d07c29304df9fbf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fd86bc618d758d07c29304df9fbf4f">&#9670;&#160;</a></span>ReadStringSysctlByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::ReadStringSysctlByName </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>may_log_enoent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>sysctlbyname</code> to read a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The string name of the sysctl to raed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">may_log_enoent</td><td>If <code>true</code>, allows a warning to be logged if the sysctl is not found, indicated by <code>sysctlbyname</code> setting <code>errno</code> to <code>ENOENT</code>. If <code>false</code>, no warning will be logged if the sysctl is missing, and an empty string will be returned silently.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the sysctl read on success. On failure, an empty string with a warning logged, subject to <em class="arg">may_log_enoent</em>. </dd></dl>

</div>
</div>
<a id="ae93766162f8810f02d1891951937aede" name="ae93766162f8810f02d1891951937aede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93766162f8810f02d1891951937aede">&#9670;&#160;</a></span>ReadThreadIDs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ReadThreadIDs </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; pid_t &gt; *</td>          <td class="paramname"><span class="paramname"><em>tids</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the thread IDs of a process by reading <code>/proc/<em>pid</em>/task</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The process ID for which to read thread IDs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tids</td><td>The read thread IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the task directory was successfully read. Format errors are logged, but won't cause this function to return <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac86f028e5f175cccfcab418346d7bcfe" name="ac86f028e5f175cccfcab418346d7bcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86f028e5f175cccfcab418346d7bcfe">&#9670;&#160;</a></span>ReadXattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a> crashpad::ReadXattr </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an extended attribute on a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The path to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the extended attribute to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13" title="The result code for a ReadXattr operation.">XattrStatus</a> </dd></dl>

</div>
</div>
<a id="ab8c682ff6d5f00ca828640a72436e196" name="ab8c682ff6d5f00ca828640a72436e196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c682ff6d5f00ca828640a72436e196">&#9670;&#160;</a></span>ReadXattrBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a> crashpad::ReadXattrBool </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an extended attribute on a file.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The path to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the extended attribute to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13" title="The result code for a ReadXattr operation.">XattrStatus</a>   </dd></dl>
<p>Only the values <code>"0"</code> and <code>"1"</code>, for <code>false</code> and <code>true</code> respectively, are valid conversions. </p>

</div>
</div>
<a id="a0c28700ce2629c13b5b8bb1392625ef4" name="a0c28700ce2629c13b5b8bb1392625ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c28700ce2629c13b5b8bb1392625ef4">&#9670;&#160;</a></span>ReadXattrInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a> crashpad::ReadXattrInt </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an extended attribute on a file.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The path to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the extended attribute to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13" title="The result code for a ReadXattr operation.">XattrStatus</a>    </dd></dl>

</div>
</div>
<a id="a71572c94f27aba3f34938d3a0d9030a3" name="a71572c94f27aba3f34938d3a0d9030a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71572c94f27aba3f34938d3a0d9030a3">&#9670;&#160;</a></span>ReadXattrTimeT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a> crashpad::ReadXattrTimeT </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an extended attribute on a file.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The path to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the extended attribute to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13" title="The result code for a ReadXattr operation.">XattrStatus</a>    </dd></dl>

</div>
</div>
<a id="ad20301f0c5158576b0893444ff662108" name="ad20301f0c5158576b0893444ff662108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20301f0c5158576b0893444ff662108">&#9670;&#160;</a></span>RecordFileLimitAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::RecordFileLimitAnnotation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records a <code>"file-limits"</code> simple annotation for the process. </p>
<p>This annotation will be used to confirm the theory that certain crashes are caused by systems at or near their file descriptor table size limits.</p>
<p>The format of the annotation is four comma-separated values: the system-wide <code>kern.num_files</code> and <code>kern.maxfiles</code> values from <code>sysctl()</code>, and the process-specific current and maximum file descriptor limits from <code>getrlimit(RLIMIT_NOFILE, …)</code>.</p>
<p>See <a href="https://crashpad.chromium.org/bug/180">https://crashpad.chromium.org/bug/180</a>.</p>
<p>TODO(mark): Remove this annotation after sufficient data has been collected for analysis. </p>

</div>
</div>
<a id="a61b73837f43334046a1b56763fefba55" name="a61b73837f43334046a1b56763fefba55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b73837f43334046a1b56763fefba55">&#9670;&#160;</a></span>ReinterpretBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From, typename To&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ReinterpretBytes </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">To *</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the bytes of <em class="arg">from</em> to <em class="arg">to</em>. </p>
<p>This function is similar to <code>bit_cast</code>, except that it can operate on differently sized types.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the copy is possible without information loss, otherwise <code>false</code> with a message logged. </dd></dl>

</div>
</div>
<a id="a354d84b9ce60fa7d437c2ee6f58ea05f" name="a354d84b9ce60fa7d437c2ee6f58ea05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354d84b9ce60fa7d437c2ee6f58ea05f">&#9670;&#160;</a></span>RemoveXattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13">XattrStatus</a> crashpad::RemoveXattr </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an extended attribute from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The path to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the extended attribute to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#a589b4d9bd6f2233b67148ab6793c3c13" title="The result code for a ReadXattr operation.">XattrStatus</a> </dd></dl>

</div>
</div>
<a id="ad8efd0f50febdf3c8461fb93de8191f7" name="ad8efd0f50febdf3c8461fb93de8191f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8efd0f50febdf3c8461fb93de8191f7">&#9670;&#160;</a></span>SafeTerminateProcess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::SafeTerminateProcess </td>
          <td>(</td>
          <td class="paramtype">HANDLE</td>          <td class="paramname"><span class="paramname"><em>process</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT</td>          <td class="paramname"><span class="paramname"><em>exit_code</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code>TerminateProcess()</code>. </p>
<p><code>TerminateProcess()</code> has been observed in the wild as being patched badly on 32-bit x86: it’s patched with code adhering to the <code>cdecl</code> (caller clean-up) convention, although it’s supposed to be <code>stdcall</code> (callee clean-up). The mix-up means that neither caller nor callee perform parameter clean-up from the stack, causing the stack pointer to have an unexpected value on return from the patched function. This typically results in a crash shortly thereafter. See <a href="https://crashpad.chromium.org/bug/179">Crashpad bug 179</a>.</p>
<p>On 32-bit x86, this replacement function calls <code>TerminateProcess()</code> without making any assumptions about the stack pointer on its return. As such, it’s compatible with the badly patched <code>cdecl</code> version as well as the native <code>stdcall</code> version (and other less badly patched versions).</p>
<p>Elsewhere, this function calls <code>TerminateProcess()</code> directly without any additional fanfare.</p>
<p>Call this function instead of <code>TerminateProcess()</code> anywhere that <code>TerminateProcess()</code> would normally be called. </p>

</div>
</div>
<a id="a0d993c28de1644014bf81bac75817757" name="a0d993c28de1644014bf81bac75817757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d993c28de1644014bf81bac75817757">&#9670;&#160;</a></span>SendToCrashHandlerServer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::SendToCrashHandlerServer </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>pipe_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1ClientToServerMessage.html">ClientToServerMessage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unioncrashpad_1_1ServerToClientMessage.html">ServerToClientMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>response</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect over the given <em class="arg">pipe_name</em>, passing <em class="arg">message</em> to the server, storing the server's reply into <em class="arg">response</em>. </p>
<p>Typically clients will not use this directly, instead using CrashpadClient::SetHandler().</p>
<dl class="section see"><dt>See also</dt><dd>CrashpadClient::SetHandler() </dd></dl>

</div>
</div>
<a id="aead5f04bd94549956a7f2826aeccf495" name="aead5f04bd94549956a7f2826aeccf495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead5f04bd94549956a7f2826aeccf495">&#9670;&#160;</a></span>ServiceManagementIsJobLoaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ServiceManagementIsJobLoaded </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>label</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a specified job is loaded in the user launchd domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>The label for the job to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the job is loaded, otherwise <code>false</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A loaded job is not necessarily presently running, nor has it necessarily ever run in the past. </dd>
<dd>
This function is provided because <code>SMJobCopyDictionary()</code> is deprecated in OS X 10.10. It may or may not be implemented using <code>SMJobCopyDictionary()</code> from <code>ServiceManagement.framework</code>. </dd></dl>

</div>
</div>
<a id="a3bc3a94386dd27968d48619f42154463" name="a3bc3a94386dd27968d48619f42154463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc3a94386dd27968d48619f42154463">&#9670;&#160;</a></span>ServiceManagementIsJobRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t crashpad::ServiceManagementIsJobRunning </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>label</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a specified job is running in the user launchd domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>The label for the job to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The job’s process ID if running, otherwise <code>0</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is provided because <code>SMJobCopyDictionary()</code> is deprecated in OS X 10.10. It may or may not be implemented using <code>SMJobCopyDictionary()</code> from <code>ServiceManagement.framework</code>. </dd></dl>

</div>
</div>
<a id="a8cc130fecf996b7d7c76a56200afccb1" name="a8cc130fecf996b7d7c76a56200afccb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc130fecf996b7d7c76a56200afccb1">&#9670;&#160;</a></span>ServiceManagementRemoveJob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ServiceManagementRemoveJob </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wait</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a job from the user launchd domain as in <code>SMJobRemove()</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>The label for the job to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait</td><td><code>true</code> if this function should block, waiting for the job to be removed. <code>false</code> if the job may be removed asynchronously.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the job was removed successfully or if an asynchronous attempt to remove the job was started successfully, otherwise <code>false</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is provided because <code>SMJobRemove()</code> is deprecated in OS X 10.10. On OS X 10.10, observed in DP8 14A361c, it also blocks for far too long (<code>_block_until_job_exits()</code> contains a one-second <code>sleep()</code>, filed as radar 18398683) and does not signal failure via its return value when asked to remove a nonexistent job (filed as radar 18268941). </dd></dl>

</div>
</div>
<a id="a97ebbbac4c7f27e2e3ba2b9c080ed0f3" name="a97ebbbac4c7f27e2e3ba2b9c080ed0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ebbbac4c7f27e2e3ba2b9c080ed0f3">&#9670;&#160;</a></span>ServiceManagementSubmitJob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::ServiceManagementSubmitJob </td>
          <td>(</td>
          <td class="paramtype">CFDictionaryRef</td>          <td class="paramname"><span class="paramname"><em>job_cf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a job to the user launchd domain as in <code>SMJobSubmit()</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">job_cf</td><td>A dictionary describing a job.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the job was submitted successfully, otherwise <code>false</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is provided because <code>SMJobSubmit()</code> is deprecated in OS X 10.10. It may or may not be implemented using <code>SMJobSubmit()</code> from <code>ServiceManagement.framework</code>. </dd></dl>

</div>
</div>
<a id="aa023691aedd4f3e6faa923e8d2095947" name="aa023691aedd4f3e6faa923e8d2095947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa023691aedd4f3e6faa923e8d2095947">&#9670;&#160;</a></span>SetMIGReplyError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::SetMIGReplyError </td>
          <td>(</td>
          <td class="paramtype">mach_msg_header_t *</td>          <td class="paramname"><span class="paramname"><em>out_header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kern_return_t</td>          <td class="paramname"><span class="paramname"><em>error</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the error code in a reply message for a MIG server routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out_header</td><td>The reply message to operate on. <em class="arg">out_header</em> will be treated as a <code>mig_reply_error_t*</code> and its <code>RetCode</code> field will be set. This argument is accepted as a <code>mach_msg_header_t*</code> instead of a <code>mig_reply_error_t*</code> because that is the type that callers are expected to possess in the C API. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>The error code to store in <em class="arg">out_header</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2274adc0459f68b93ffe51d8f975f14e" title="Initializes a reply message for a MIG server routine based on its corresponding request.">PrepareMIGReplyFromRequest()</a> </dd></dl>

</div>
</div>
<a id="a97b946d80de148d1fd2452af38b220f4" name="a97b946d80de148d1fd2452af38b220f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b946d80de148d1fd2452af38b220f4">&#9670;&#160;</a></span>SignalToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::SignalToString </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>signal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a POSIX signal value to a textual representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>The signal value to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a7856b82b71167792ea6103debb5105eda18aa149c3471a5129274df2af6972f04" title="Use | to combine values in a bitfield.">kUseOr</a> is ignored. For <a class="el" href="#a7856b82b71167792ea6103debb5105edaf9da07820c9857c86422b70c3cc33c12" title="If no symbolic name is known for a given constant, return a numeric string.">kUnknownIsNumeric</a>, the format is <code>"%d"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string. </dd></dl>

</div>
</div>
<a id="a45a44a5552e00ceaf0917f94433ac104" name="a45a44a5552e00ceaf0917f94433ac104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a44a5552e00ceaf0917f94433ac104">&#9670;&#160;</a></span>SimulateCrash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::SimulateCrash </td>
          <td>(</td>
          <td class="paramtype">const NativeCPUContext &amp;</td>          <td class="paramname"><span class="paramname"><em>cpu_context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulates a exception without crashing. </p>
<p>This function searches for an <code>EXC_CRASH</code> handler in the same manner that the kernel does, and sends it an exception message to that handler in the format that the handler expects, considering the behavior and thread state flavor that are registered for it. The exception sent to the handler will be <a class="el" href="#a9e0a6740778f04fe2d190dbcd080d55b" title="An exception type to use for simulated exceptions.">kMachExceptionSimulated</a>, not <code>EXC_CRASH</code>.</p>
<p>Typically, the <a class="el" href="simulate__crash__ios_8h.html#a0ac6f4df5ed356f04dd12be3f07f9ed2" title="Captures the CPU context and creates a minidump dump without an exception. The minidump will immediat...">CRASHPAD_SIMULATE_CRASH()</a> macro will be used in preference to this function, because it combines the context-capture operation with the raising of a simulated exception.</p>
<p>This function returns normally after the exception message is processed. If no valid handler was found, or no handler processed the exception successfully, a warning will be logged, but these conditions are not considered fatal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cpu_context</td><td>The thread state to pass to the exception handler as the exception context, provided that it is compatible with the thread state flavor that the exception handler accepts. If it is not compatible, the correct thread state for the handler will be obtained by calling <code>thread_get_state()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f1db976c6e43d3731c26df569368592" name="a8f1db976c6e43d3731c26df569368592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1db976c6e43d3731c26df569368592">&#9670;&#160;</a></span>SleepNanoseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::SleepNanoseconds </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>nanoseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleeps for the specified duration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nanoseconds</td><td>The number of nanoseconds to sleep. The actual sleep may be slightly longer due to latencies and timer resolution.</td></tr>
  </table>
  </dd>
</dl>
<p>On POSIX, this function is resilient against the underlying <code>nanosleep()</code> system call being interrupted by a signal. </p>

</div>
</div>
<a id="aca1a9edb4c9626920d9add1664acc631" name="aca1a9edb4c9626920d9add1664acc631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1a9edb4c9626920d9add1664acc631">&#9670;&#160;</a></span>SpawnSubprocess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::SpawnSubprocess </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>envp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>preserve_fd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>child_function&#160;</em></span>)()&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns a subprocess. </p>
<p>A grandchild process will be started through the <code>fork()</code>-and-<code>posix_spawn()</code> pattern where supported, and double-<code>fork()</code>-and-<code>execv()</code> pattern elsewhere. This allows the grandchild to fully disassociate from the parent. The grandchild will not be a member of the parent’s process group or session and will not have a controlling terminal, providing isolation from signals not intended for it. The grandchild’s parent process, in terms of the process tree hierarchy, will be the process with process ID 1, relieving any other process of the responsibility to reap it via <code>waitpid()</code>. Aside from the three file descriptors associated with the standard input/output streams and any file descriptor passed in <em class="arg">preserve_fd</em>, the grandchild will not inherit any file descriptors from the parent process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>The argument vector to start the grandchild process with. <code>argv[0]</code> is used as the path to the executable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">envp</td><td>A vector of environment variables of the form <code>var=value</code> to be passed to the spawned process. If this value is <code>nullptr</code>, the current environment is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preserve_fd</td><td>A file descriptor to be inherited by the grandchild process. This file descriptor is inherited in addition to the three file descriptors associated with the standard input/output streams. Use <code>-1</code> if no additional file descriptors are to be inherited. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_path</td><td>Whether to consult the <code>PATH</code> environment variable when requested to start an executable at a non-absolute path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_function</td><td>If not <code>nullptr</code>, this function will be called in the intermediate child process. Take note that this function will run in the context of a forked process, and must be safe for that purpose.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, and <code>false</code> on failure with a message logged. Only failures that occur in the parent process that indicate a definite failure to start the the grandchild are reported in the return value. Failures in the intermediate child or grandchild processes cannot be reported in the return value, and are addressed by logging a message and terminating. The caller assumes the responsibility for detecting such failures, for example, by observing a failure to perform a successful handshake with the grandchild process. </dd></dl>

</div>
</div>
<a id="abb5d05de37d3f1a92ce36c3ce37842b7" name="abb5d05de37d3f1a92ce36c3ce37842b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5d05de37d3f1a92ce36c3ce37842b7">&#9670;&#160;</a></span>SplitString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; crashpad::SplitString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into multiple parts on the given delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>The delimiter to split at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The individual parts of the string. </dd></dl>

</div>
</div>
<a id="a1b3aaf00fdc6fef366afb2a00062c97f" name="a1b3aaf00fdc6fef366afb2a00062c97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3aaf00fdc6fef366afb2a00062c97f">&#9670;&#160;</a></span>SplitStringFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::SplitStringFirst </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into two parts at the first delimiter found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>The delimiter to split at. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left</td><td>The portion of <em class="arg">string</em> up to, but not including, the first <em class="arg">delimiter</em> character. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">right</td><td>The portion of <em class="arg">string</em> after the first <em class="arg">delimiter</em> character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em class="arg">string</em> was split successfully. <code>false</code> if <em class="arg">string</em> did not contain a <em class="arg">delimiter</em> character or began with a <em class="arg">delimiter</em> character. </dd></dl>

</div>
</div>
<a id="ac6eccc3b9b90d2dd74048a43c9002e88" name="ac6eccc3b9b90d2dd74048a43c9002e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6eccc3b9b90d2dd74048a43c9002e88">&#9670;&#160;</a></span>StdioFileHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a> crashpad::StdioFileHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8402ddae562db04a8daf6bffecaded5b">StdioStream</a></td>          <td class="paramname"><span class="paramname"><em>stdio_stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> corresponding to the requested standard I/O stream. </p>
<p>The returned <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> should not be closed on POSIX, where it is important to maintain valid file descriptors occupying the slots reserved for these streams. If a need to close such a stream arises on POSIX, <code>dup2()</code> should instead be used to replace the existing file descriptor with one opened to <code>/dev/null</code>. See <a class="el" href="#aa8a3145ce95463d1638428b2547cde4d" title="Closes stdin and stdout by opening /dev/null over them.">CloseStdinAndStdout()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stdio_stream</td><td>The requested standard I/O stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A corresponding <a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c" title="Platform-specific alias for a low-level file handle.">FileHandle</a> on success. kInvalidFileHandle on error, with a message logged. </dd></dl>

</div>
</div>
<a id="a229a9b5ddd24c6722e413e6132d0acf0" name="a229a9b5ddd24c6722e413e6132d0acf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229a9b5ddd24c6722e413e6132d0acf0">&#9670;&#160;</a></span>StringToException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToException </td>
          <td>(</td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exception_type_t *</td>          <td class="paramname"><span class="paramname"><em>exception</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string to its corresponding Mach exception value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a8387ad067a7e6a1735ab97a1af450d2ba060cbf403d47785a69b249e9c562f410" title="Allow | to combine values in a bitfield.">kAllowOr</a> is ignored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exception</td><td>The converted Mach exception value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> if <em class="arg">string</em> could not be converted as requested. </dd></dl>

</div>
</div>
<a id="a957c7de6eb716bf1662c08333b1f7e21" name="a957c7de6eb716bf1662c08333b1f7e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957c7de6eb716bf1662c08333b1f7e21">&#9670;&#160;</a></span>StringToExceptionBehavior()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToExceptionBehavior </td>
          <td>(</td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exception_behavior_t *</td>          <td class="paramname"><span class="paramname"><em>behavior</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string to its corresponding Mach exception behavior value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a8387ad067a7e6a1735ab97a1af450d2ba060cbf403d47785a69b249e9c562f410" title="Allow | to combine values in a bitfield.">kAllowOr</a> is ignored. <code>MACH_EXCEPTION_CODES</code> can always be ORed in, but no other values can be ORed with each other. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">behavior</td><td>The converted Mach exception behavior value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> if <em class="arg">string</em> could not be converted as requested. </dd></dl>

</div>
</div>
<a id="a7ab63868a738f3bfd4d2449e60607dec" name="a7ab63868a738f3bfd4d2449e60607dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab63868a738f3bfd4d2449e60607dec">&#9670;&#160;</a></span>StringToExceptionMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToExceptionMask </td>
          <td>(</td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exception_mask_t *</td>          <td class="paramname"><span class="paramname"><em>exception_mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string to its corresponding Mach exception mask value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a8387ad067a7e6a1735ab97a1af450d2ba060cbf403d47785a69b249e9c562f410" title="Allow | to combine values in a bitfield.">kAllowOr</a> is honored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exception_mask</td><td>The converted Mach exception mask value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> if <em class="arg">string</em> could not be converted as requested. </dd></dl>

</div>
</div>
<a id="a32029d4f41770a8fafb8efdc896e5e4d" name="a32029d4f41770a8fafb8efdc896e5e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32029d4f41770a8fafb8efdc896e5e4d">&#9670;&#160;</a></span>StringToNumber() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a number. </p>
<p>A conversion will only be performed if it can be done perfectly: if <em class="arg">string</em> contains no leading or trailing characters (including whitespace) other than the number to convert, and does not overflow the targeted data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert to a number. As in <code>strtol()</code> with a <code>base</code> parameter of <code>0</code>, the string is treated as decimal unless it begins with a <code>"0x"</code> or <code>"0X"</code> prefix, in which case it is treated as hexadecimal, or a <code>"0"</code> prefix, in which case it is treated as octal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">number</td><td>The converted number. This will only be set if a perfect conversion can be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a perfect conversion could be performed, with <em class="arg">number</em> set appropriately. <code>false</code> if a perfect conversion was not possible.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interface in <code>base/strings/string_number_conversions.h</code> doesn’t allow arbitrary bases based on whether the string begins with a prefix indicating its base. The functions here are provided for situations where such prefix recognition is desirable. </dd></dl>

</div>
</div>
<a id="a6879fca357a65d0ea93e06a48399a36a" name="a6879fca357a65d0ea93e06a48399a36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6879fca357a65d0ea93e06a48399a36a">&#9670;&#160;</a></span>StringToNumber() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a number. </p>
<p>A conversion will only be performed if it can be done perfectly: if <em class="arg">string</em> contains no leading or trailing characters (including whitespace) other than the number to convert, and does not overflow the targeted data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert to a number. As in <code>strtol()</code> with a <code>base</code> parameter of <code>0</code>, the string is treated as decimal unless it begins with a <code>"0x"</code> or <code>"0X"</code> prefix, in which case it is treated as hexadecimal, or a <code>"0"</code> prefix, in which case it is treated as octal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">number</td><td>The converted number. This will only be set if a perfect conversion can be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a perfect conversion could be performed, with <em class="arg">number</em> set appropriately. <code>false</code> if a perfect conversion was not possible.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interface in <code>base/strings/string_number_conversions.h</code> doesn’t allow arbitrary bases based on whether the string begins with a prefix indicating its base. The functions here are provided for situations where such prefix recognition is desirable. </dd></dl>

</div>
</div>
<a id="a0803f07288b43b385a4cf8f44d9f737c" name="a0803f07288b43b385a4cf8f44d9f737c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0803f07288b43b385a4cf8f44d9f737c">&#9670;&#160;</a></span>StringToNumber() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a number. </p>
<p>A conversion will only be performed if it can be done perfectly: if <em class="arg">string</em> contains no leading or trailing characters (including whitespace) other than the number to convert, and does not overflow the targeted data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert to a number. As in <code>strtol()</code> with a <code>base</code> parameter of <code>0</code>, the string is treated as decimal unless it begins with a <code>"0x"</code> or <code>"0X"</code> prefix, in which case it is treated as hexadecimal, or a <code>"0"</code> prefix, in which case it is treated as octal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">number</td><td>The converted number. This will only be set if a perfect conversion can be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a perfect conversion could be performed, with <em class="arg">number</em> set appropriately. <code>false</code> if a perfect conversion was not possible.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interface in <code>base/strings/string_number_conversions.h</code> doesn’t allow arbitrary bases based on whether the string begins with a prefix indicating its base. The functions here are provided for situations where such prefix recognition is desirable. </dd></dl>

</div>
</div>
<a id="abc8d160b70c0f608add225d2be928f7c" name="abc8d160b70c0f608add225d2be928f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8d160b70c0f608add225d2be928f7c">&#9670;&#160;</a></span>StringToNumber() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a number. </p>
<p>A conversion will only be performed if it can be done perfectly: if <em class="arg">string</em> contains no leading or trailing characters (including whitespace) other than the number to convert, and does not overflow the targeted data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert to a number. As in <code>strtol()</code> with a <code>base</code> parameter of <code>0</code>, the string is treated as decimal unless it begins with a <code>"0x"</code> or <code>"0X"</code> prefix, in which case it is treated as hexadecimal, or a <code>"0"</code> prefix, in which case it is treated as octal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">number</td><td>The converted number. This will only be set if a perfect conversion can be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a perfect conversion could be performed, with <em class="arg">number</em> set appropriately. <code>false</code> if a perfect conversion was not possible.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interface in <code>base/strings/string_number_conversions.h</code> doesn’t allow arbitrary bases based on whether the string begins with a prefix indicating its base. The functions here are provided for situations where such prefix recognition is desirable. </dd></dl>

</div>
</div>
<a id="ad91f5fe164e391c950c3e3a456f5f008" name="ad91f5fe164e391c950c3e3a456f5f008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91f5fe164e391c950c3e3a456f5f008">&#9670;&#160;</a></span>StringToNumber() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a number. </p>
<p>A conversion will only be performed if it can be done perfectly: if <em class="arg">string</em> contains no leading or trailing characters (including whitespace) other than the number to convert, and does not overflow the targeted data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert to a number. As in <code>strtol()</code> with a <code>base</code> parameter of <code>0</code>, the string is treated as decimal unless it begins with a <code>"0x"</code> or <code>"0X"</code> prefix, in which case it is treated as hexadecimal, or a <code>"0"</code> prefix, in which case it is treated as octal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">number</td><td>The converted number. This will only be set if a perfect conversion can be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a perfect conversion could be performed, with <em class="arg">number</em> set appropriately. <code>false</code> if a perfect conversion was not possible.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interface in <code>base/strings/string_number_conversions.h</code> doesn’t allow arbitrary bases based on whether the string begins with a prefix indicating its base. The functions here are provided for situations where such prefix recognition is desirable. </dd></dl>

</div>
</div>
<a id="aca97fc8e5a3b10053b624bf9b8ac65c4" name="aca97fc8e5a3b10053b624bf9b8ac65c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca97fc8e5a3b10053b624bf9b8ac65c4">&#9670;&#160;</a></span>StringToNumber() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long *</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a number. </p>
<p>A conversion will only be performed if it can be done perfectly: if <em class="arg">string</em> contains no leading or trailing characters (including whitespace) other than the number to convert, and does not overflow the targeted data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert to a number. As in <code>strtol()</code> with a <code>base</code> parameter of <code>0</code>, the string is treated as decimal unless it begins with a <code>"0x"</code> or <code>"0X"</code> prefix, in which case it is treated as hexadecimal, or a <code>"0"</code> prefix, in which case it is treated as octal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">number</td><td>The converted number. This will only be set if a perfect conversion can be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a perfect conversion could be performed, with <em class="arg">number</em> set appropriately. <code>false</code> if a perfect conversion was not possible.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interface in <code>base/strings/string_number_conversions.h</code> doesn’t allow arbitrary bases based on whether the string begins with a prefix indicating its base. The functions here are provided for situations where such prefix recognition is desirable. </dd></dl>

</div>
</div>
<a id="a6249dd58c6a81b300d64b25a943fa25c" name="a6249dd58c6a81b300d64b25a943fa25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6249dd58c6a81b300d64b25a943fa25c">&#9670;&#160;</a></span>StringToSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToSignal </td>
          <td>(</td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>signal</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string to its corresponding POSIX signal value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a8387ad067a7e6a1735ab97a1af450d2ba060cbf403d47785a69b249e9c562f410" title="Allow | to combine values in a bitfield.">kAllowOr</a> is ignored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signal</td><td>The converted POSIX signal value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> if <em class="arg">string</em> could not be converted as requested. </dd></dl>

</div>
</div>
<a id="a2fdb1f659a2813e80d5b644020a44208" name="a2fdb1f659a2813e80d5b644020a44208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdb1f659a2813e80d5b644020a44208">&#9670;&#160;</a></span>StringToThreadStateFlavor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::StringToThreadStateFlavor </td>
          <td>(</td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a78ec34d8dc54f6d191e3ddae3eb79170">StringToSymbolicConstantOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_state_flavor_t *</td>          <td class="paramname"><span class="paramname"><em>flavor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string to its corresponding thread state flavor value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a8387ad067a7e6a1735ab97a1af450d2ba060cbf403d47785a69b249e9c562f410" title="Allow | to combine values in a bitfield.">kAllowOr</a> is ignored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flavor</td><td>The converted thread state flavor value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> if <em class="arg">string</em> could not be converted as requested. </dd></dl>

</div>
</div>
<a id="a8913260552f8af42d01f9155b6e717a5" name="a8913260552f8af42d01f9155b6e717a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8913260552f8af42d01f9155b6e717a5">&#9670;&#160;</a></span>StringVectorToCStringVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::StringVectorToCStringVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>strings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt; *</td>          <td class="paramname"><span class="paramname"><em>c_strings</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens a string vector into a const char* vector suitable for use in an exec() call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strings</td><td>A vector of string data. This vector must remain valid for the lifetime of <em class="arg">c_strings</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c_strings</td><td>A vector of pointers to the string data in <em class="arg">strings</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8605dea4710c2630ccdd21439e05999" name="ac8605dea4710c2630ccdd21439e05999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8605dea4710c2630ccdd21439e05999">&#9670;&#160;</a></span>strnlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t crashpad::strnlen </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of a string, not to exceed a maximum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string whose length is to be calculated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_length</td><td>The maximum length to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of <em class="arg">string</em>, determined as the index of the first <code>NUL</code> byte found, not exceeding <em class="arg">max_length</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is provided because it was introduced in POSIX.1-2008, and not all systems’ standard libraries provide an implementation. </dd></dl>

</div>
</div>
<a id="abf8f0c52904467bf6c534f78a52d5699" name="abf8f0c52904467bf6c534f78a52d5699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8f0c52904467bf6c534f78a52d5699">&#9670;&#160;</a></span>SystemCrashReporterHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">base::apple::ScopedMachSendRight crashpad::SystemCrashReporterHandler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the system’s default Mach exception handler for crash-type exceptions. </p>
<p>This is obtained by looking up <code>"com.apple.ReportCrash"</code> with the bootstrap server. The service name comes from the first launch agent loaded by <code>launchd</code> with a <code>MachServices</code> entry having <code>ExceptionServer</code> set. This launch agent is normally loaded from <code>/System/Library/LaunchAgents/com.apple.ReportCrash.plist</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, a send right to an <code>exception_handler_t</code> corresponding to the system’s default crash reporter. On failure, <code>MACH_PORT_NULL</code>, with a message logged. </dd></dl>

</div>
</div>
<a id="aeff94a266a84248b3ff0defae01efd8d" name="aeff94a266a84248b3ff0defae01efd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff94a266a84248b3ff0defae01efd8d">&#9670;&#160;</a></span>TaskForPID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">task_t crashpad::TaskForPID </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <code>task_for_pid()</code>. </p>
<p>This function exists to support <code>task_for_pid()</code> access checks in a setuid environment. Normally, <code>task_for_pid()</code> can only return an arbitrary task’s port when running as root or when taskgated(8) approves. When not running as root, a series of access checks are perfomed to ensure that the running process has permission to obtain the other process’ task port.</p>
<p>It is possible to make an executable setuid root to give it broader <code>task_for_pid()</code> access by bypassing taskgated(8) checks, but this also has the effect of bypassing the access checks, allowing any process’ task port to be obtained. In most situations, these access checks are desirable to prevent security and privacy breaches.</p>
<p>When running as setuid root, this function wraps <code>task_for_pid()</code>, reimplementing those access checks. A process whose effective user ID is 0 and whose real user ID is nonzero is understood to be running setuid root. In this case, the requested task’s real, effective, and saved set-user IDs must all equal the running process’ real user ID, the requested task must not have changed privileges, and the requested task’s set of all group IDs (including its real, effective, and saved set-group IDs and supplementary group list) must be a subset of the running process’ set of all group IDs. These access checks mimic those that the kernel performs.</p>
<p>When not running as setuid root, <code>task_for_pid()</code> is called directly, without imposing any additional checks beyond what the kernel does.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The process ID of the task whose task port is desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A send right to the task port if it could be obtained, or <code>TASK_NULL</code> otherwise, with an error message logged. If a send right is returned, the caller takes ownership of it. </dd></dl>

</div>
</div>
<a id="a857f6b2f39cb21b22891242df26757e0" name="a857f6b2f39cb21b22891242df26757e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857f6b2f39cb21b22891242df26757e0">&#9670;&#160;</a></span>ThreadStateFlavorToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::ThreadStateFlavorToString </td>
          <td>(</td>
          <td class="paramtype">thread_state_flavor_t</td>          <td class="paramname"><span class="paramname"><em>flavor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a18cc715d0526f5bd9909027403f30d7d">SymbolicConstantToStringOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a thread state flavor value to a textual representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flavor</td><td>The thread state flavor value to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options affecting the conversion. <a class="el" href="#a7856b82b71167792ea6103debb5105eda18aa149c3471a5129274df2af6972f04" title="Use | to combine values in a bitfield.">kUseOr</a> is ignored. For <a class="el" href="#a7856b82b71167792ea6103debb5105edaf9da07820c9857c86422b70c3cc33c12" title="If no symbolic name is known for a given constant, return a numeric string.">kUnknownIsNumeric</a>, the format is <code>"%d"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string. </dd></dl>

</div>
</div>
<a id="a6b7029dc1761d085612fdd6732d7130a" name="a6b7029dc1761d085612fdd6732d7130a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7029dc1761d085612fdd6732d7130a">&#9670;&#160;</a></span>TimespecToTimeval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::TimespecToTimeval </td>
          <td>(</td>
          <td class="paramtype">const timespec &amp;</td>          <td class="paramname"><span class="paramname"><em>ts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeval *</td>          <td class="paramname"><span class="paramname"><em>tv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the timespec <em class="arg">ts</em> to a timeval <em class="arg">tv</em>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the assignment is possible without truncation. </dd></dl>

</div>
</div>
<a id="a34001ec0bfa5e0815fa478a8cf025c61" name="a34001ec0bfa5e0815fa478a8cf025c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34001ec0bfa5e0815fa478a8cf025c61">&#9670;&#160;</a></span>UniversalExceptionRaise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kern_return_t crashpad::UniversalExceptionRaise </td>
          <td>(</td>
          <td class="paramtype">exception_behavior_t</td>          <td class="paramname"><span class="paramname"><em>behavior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exception_handler_t</td>          <td class="paramname"><span class="paramname"><em>exception_port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_t</td>          <td class="paramname"><span class="paramname"><em>thread</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">task_t</td>          <td class="paramname"><span class="paramname"><em>task</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exception_type_t</td>          <td class="paramname"><span class="paramname"><em>exception</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mach_exception_data_type_t *</td>          <td class="paramname"><span class="paramname"><em>code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_msg_type_number_t</td>          <td class="paramname"><span class="paramname"><em>code_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_state_flavor_t *</td>          <td class="paramname"><span class="paramname"><em>flavor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae8a2e5f928712c15766a756cd2035d90">ConstThreadState</a></td>          <td class="paramname"><span class="paramname"><em>old_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_msg_type_number_t</td>          <td class="paramname"><span class="paramname"><em>old_state_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_state_t</td>          <td class="paramname"><span class="paramname"><em>new_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mach_msg_type_number_t *</td>          <td class="paramname"><span class="paramname"><em>new_state_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the appropriate <code>*exception_raise*()</code> function for the specified <em class="arg">behavior</em>. </p>
<p>The function called will be <code>exception_raise()</code> for <code>EXCEPTION_DEFAULT</code>, <code>exception_raise_state()</code> for <code>EXCEPTION_STATE</code>, or <code>exception_raise_state_identity()</code> for <code>EXCEPTION_STATE_IDENTITY</code>. If <code>MACH_EXCEPTION_CODES</code> is also set, the function called will instead be <code>mach_exception_raise()</code>, <code>mach_exception_raise_state()</code> or <code>mach_exception_raise_state_identity()</code>, respectively.</p>
<p>This function does not fetch the existing thread state for <em class="arg">behavior</em> values that require a thread state. The caller must provide the existing thread state in the <em class="arg">flavor</em>, <em class="arg">old_state</em>, and <em class="arg">old_state_count</em> parameters for <em class="arg">behavior</em> values that require a thread state. <a class="el" href="classcrashpad_1_1Thread.html" title="Basic thread abstraction. Users should derive from this class and implement ThreadMain().">Thread</a> states may be obtained by calling <code>thread_get_state()</code> if needed. Similarly, this function does not do anything with the new thread state returned for these <em class="arg">behavior</em> values. Callers that wish to make use of the new thread state may do so by using the returned <em class="arg">flavor</em>, <em class="arg">new_state</em>, and <em class="arg">new_state_count</em> values. <a class="el" href="classcrashpad_1_1Thread.html" title="Basic thread abstraction. Users should derive from this class and implement ThreadMain().">Thread</a> states may be set by calling <code>thread_set_state()</code> if needed.</p>
<p><em class="arg">thread</em> and <em class="arg">task</em> are only used when <em class="arg">behavior</em> indicates that the exception message will carry identity information, when it has the value <code>EXCEPTION_DEFAULT</code> or <code>EXCEPTION_STATE_IDENTITY</code>, possibly with <code>MACH_EXCEPTION_CODES</code> also set. In other cases, these parameters are unused and may be set to <code>THREAD_NULL</code> and <code>TASK_NULL</code>, respectively.</p>
<p><em class="arg">flavor</em>, <em class="arg">old_state</em>, <em class="arg">old_state_count</em>, <em class="arg">new_state</em>, and <em class="arg">new_state_count</em> are only used when <em class="arg">behavior</em> indicates that the exception message will carry thread state information, when it has the value <code>EXCEPTION_STATE</code> or <code>EXCEPTION_STATE_IDENTITY</code>, possibly with <code>MACH_EXCEPTION_CODES</code> also set. In other cases, these parameters are unused and may be set to <code>0</code> (<em class="arg">old_state_count</em>) or <code>nullptr</code> (the remaining parameters).</p>
<p>Except as noted, the parameters and return value are equivalent to those of the <code>*exception_raise*()</code> family of functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>The exception behavior, which dictates which function will be called. It is an error to call this function with an invalid value for <em class="arg">behavior</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_port</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exception</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>If <em class="arg">behavior</em> indicates a behavior without <code>MACH_EXCEPTION_CODES</code>, the elements of <em class="arg">code</em> will be truncated in order to be passed to the appropriate exception handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code_count</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">flavor</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_state</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_state_count</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_state</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_state_count</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the function called. </dd></dl>

</div>
</div>
<a id="a16b771a34723da94fac698418232b1e2" name="a16b771a34723da94fac698418232b1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b771a34723da94fac698418232b1e2">&#9670;&#160;</a></span>URLEncode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::URLEncode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs percent-encoding (URL encoding) on the input string, following RFC 3986 paragraph 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The string to be encoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The encoded string. </dd></dl>

</div>
</div>
<a id="ada530c306bf30e9ed9274c20d05c0db4" name="ada530c306bf30e9ed9274c20d05c0db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada530c306bf30e9ed9274c20d05c0db4">&#9670;&#160;</a></span>WriteFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::WriteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa23e97af4fc55d89e2f7f6775138980c">FileHandle</a></td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes to a file, retrying when interrupted on POSIX or following a short write. </p>
<p>This function writes to <em class="arg">file</em>, stopping only when <em class="arg">size</em> bytes have been written.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. <code>false</code> on error, with <code>errno</code> or <code>GetLastError()</code> set appropriately. On error, a portion of <em class="arg">buffer</em> may have been written to <em class="arg">file</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8599600814a17d622766decd5f122a96" title="Reads from a file, retrying when interrupted before reading any data on POSIX.">ReadFile</a> </dd>
<dd>
<a class="el" href="#a8a91af9c690d2a280c463596bf82070b" title="Wraps WriteFile(), ensuring that exactly size bytes are written.">LoggingWriteFile</a> </dd>
<dd>
<a class="el" href="#a74c74fefa3b1f5e0c1b885755c9f9cf6" title="Wraps WriteFile(), ensuring that exactly size bytes are written.">CheckedWriteFile</a> </dd></dl>

</div>
</div>
<a id="a6842e0ae3110f04477765c771c04dc60" name="a6842e0ae3110f04477765c771c04dc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6842e0ae3110f04477765c771c04dc60">&#9670;&#160;</a></span>WriteXattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::WriteXattr </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an extended attribute on a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The path to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the extended attribute to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the write was successful. <code>false</code> on error, with a message logged. </dd></dl>

</div>
</div>
<a id="ae086861e350e7225e4ea065d941e664f" name="ae086861e350e7225e4ea065d941e664f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae086861e350e7225e4ea065d941e664f">&#9670;&#160;</a></span>WriteXattrBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::WriteXattrBool </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an extended attribute on a file.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The path to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the extended attribute to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the write was successful. <code>false</code> on error, with a message logged.    </dd></dl>

</div>
</div>
<a id="a85a3551184d900a1d970bd8fa0be0ec3" name="a85a3551184d900a1d970bd8fa0be0ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a3551184d900a1d970bd8fa0be0ec3">&#9670;&#160;</a></span>WriteXattrInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::WriteXattrInt </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an extended attribute on a file.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The path to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the extended attribute to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the write was successful. <code>false</code> on error, with a message logged.    </dd></dl>

</div>
</div>
<a id="ae63f9a1eeeec00b78c216f72b1ca1327" name="ae63f9a1eeeec00b78c216f72b1ca1327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63f9a1eeeec00b78c216f72b1ca1327">&#9670;&#160;</a></span>WriteXattrTimeT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::WriteXattrTimeT </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::StringPiece &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an extended attribute on a file.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The path to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the extended attribute to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the write was successful. <code>false</code> on error, with a message logged.    </dd></dl>

</div>
</div>
<a id="ae0634eb0299cf5b28f7a373454d97c51" name="ae0634eb0299cf5b28f7a373454d97c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0634eb0299cf5b28f7a373454d97c51">&#9670;&#160;</a></span>ZlibErrorString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::ZlibErrorString </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>zr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a string for an error received from the zlib library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zr</td><td>A zlib result code, such as <code>Z_STREAM_ERROR</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string. </dd></dl>

</div>
</div>
<a id="af9a547efca1b5ea53e95a3a12047c38a" name="af9a547efca1b5ea53e95a3a12047c38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a547efca1b5ea53e95a3a12047c38a">&#9670;&#160;</a></span>ZlibWindowBitsWithGzipWrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crashpad::ZlibWindowBitsWithGzipWrapper </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>window_bits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a <em class="arg">window_bits</em> parameter to pass to <code>deflateInit2()</code> or <code>inflateInit2()</code> that specifies a <code>gzip</code> wrapper instead of the default zlib wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window_bits</td><td>A <em class="arg">window_bits</em> value that only specifies the base-2 logarithm of the deflate sliding window size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em class="arg">window_bits</em> adjusted to specify a <code>gzip</code> wrapper, to be passed to <code>deflateInit2()</code> or <code>inflateInit2()</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a38551501b8f5006f1f4ac602b87e2724" name="a38551501b8f5006f1f4ac602b87e2724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38551501b8f5006f1f4ac602b87e2724">&#9670;&#160;</a></span>g_test_crashpad_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcrashpad_1_1TestCrashpadInfo.html">TestCrashpadInfo</a> crashpad::g_test_crashpad_info</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&#39;CPad&#39;</span>,</div>
<div class="line">                                         <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structcrashpad_1_1TestCrashpadInfo.html">TestCrashpadInfo</a>),</div>
<div class="line">                                         1,</div>
<div class="line">                                         0,</div>
<div class="line">                                         0,</div>
<div class="line">                                         0,</div>
<div class="line">                                         0,</div>
<div class="line">                                         0,</div>
<div class="line">                                         0,</div>
<div class="line">                                         <span class="keyword">nullptr</span>,</div>
<div class="line">                                         <span class="keyword">nullptr</span>,</div>
<div class="line"> </div>
<div class="line">                                         <span class="keyword">nullptr</span>,</div>
<div class="line">                                         <span class="keyword">nullptr</span>,</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line">}</div>
<div class="ttc" id="astructcrashpad_1_1TestCrashpadInfo_html"><div class="ttname"><a href="structcrashpad_1_1TestCrashpadInfo.html">crashpad::TestCrashpadInfo</a></div><div class="ttdef"><b>Definition</b> crashpad_info_size_test_module.cc:41</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0999f3c072971348f71f196848fcde12" name="a0999f3c072971348f71f196848fcde12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0999f3c072971348f71f196848fcde12">&#9670;&#160;</a></span>kMachExceptionCodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exception_behavior_t crashpad::kMachExceptionCodes = MACH_EXCEPTION_CODES</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>MACH_EXCEPTION_CODES</code> with the correct type for a Mach exception behavior, <code>exception_behavior_t</code>. </p>
<p>Signedness problems can occur when ORing <code>MACH_EXCEPTION_CODES</code> as a signed integer, because a signed integer overflow results. This constant can be used instead of <code>MACH_EXCEPTION_CODES</code> in such cases. </p>

</div>
</div>
<a id="a2c87c3ca622c253c84e9b557a0abe034" name="a2c87c3ca622c253c84e9b557a0abe034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c87c3ca622c253c84e9b557a0abe034">&#9670;&#160;</a></span>kMachMessageReceiveAuditTrailer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mach_msg_option_t crashpad::kMachMessageReceiveAuditTrailer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0) |</div>
<div class="line">    MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AUDIT)</div>
</div><!-- fragment -->
<p>A Mach message option specifying that an audit trailer should be delivered during a receive operation. </p>
<p>This constant is provided because the macros normally used to request this behavior are cumbersome. </p>

</div>
</div>
<a id="a253712a6760b4b8a54dbcc8943692731" name="a253712a6760b4b8a54dbcc8943692731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253712a6760b4b8a54dbcc8943692731">&#9670;&#160;</a></span>kMachPortNull</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mach_port_t crashpad::kMachPortNull = MACH_PORT_NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>MACH_PORT_NULL</code> with the correct type for a Mach port, <code>mach_port_t</code>. </p>
<p>For situations where implicit conversions between signed and unsigned types are not performed, use kMachPortNull instead of an explicit <code>implicit_cast</code> of <code>MACH_PORT_NULL</code> to <code>mach_port_t</code>. This is useful for logging and testing assertions. </p>

</div>
</div>
<a id="a83421817896ef24623f0f1cf10268843" name="a83421817896ef24623f0f1cf10268843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83421817896ef24623f0f1cf10268843">&#9670;&#160;</a></span>kMaxNumberOfAnnotations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t crashpad::kMaxNumberOfAnnotations = 400</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of crashpad::Annotations that will be read from a client process. </p>
<dl class="section note"><dt>Note</dt><dd>This maximum was chosen arbitrarily and may change in the future. </dd></dl>

</div>
</div>
<a id="ab297f205afaeb8ba801c36c32607fae1" name="ab297f205afaeb8ba801c36c32607fae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab297f205afaeb8ba801c36c32607fae1">&#9670;&#160;</a></span>kMinidumpAMD64XSaveOffset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t crashpad::kMinidumpAMD64XSaveOffset = 0x550</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset of first xsave feature in the full extended context. </p>
<p>This is used to calculate the final size of the extended context, and can be validated by calling InitializeContext2 with one XSTATE feature, and LocateXStateFeature to determine the first offset. Also see “MANAGING STATE USING THE XSAVE FEATURE SET”, Ch. 13, Intel SDM. </p>

</div>
</div>
<a id="ad1e976d5cb60cef3f5412fa9e55cb915" name="ad1e976d5cb60cef3f5412fa9e55cb915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e976d5cb60cef3f5412fa9e55cb915">&#9670;&#160;</a></span>kXSaveAreaFirstOffset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t crashpad::kXSaveAreaFirstOffset = 0x240</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset of first xsave feature within the extended context area. </p>
<p>0x240 is the size of the legacy area (512) + the xsave header(64 bytes) Intel SDM 13.4.1. This is not where the item is in the extended compacted context, but is the offset recorded in the minidump. It needs to be correct there. See <a href="https://windows-internals.com/cet-on-windows/">https://windows-internals.com/cet-on-windows/</a> for some discussion “CONTEXT_XSTATE: Extended processor state chunk. The state is stored in the same format the XSAVE operation stores it with exception of the first 512 bytes, i.e. starting from XSAVE_AREA_HEADER.” This may vary by cpuid. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecrashpad.html">crashpad</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
