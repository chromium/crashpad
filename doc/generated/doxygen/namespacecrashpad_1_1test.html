<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crashpad: crashpad::test Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="crashpad_doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crashpad
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecrashpad.html">crashpad</a></li><li class="navelem"><a class="el" href="namespacecrashpad_1_1test.html">test</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">crashpad::test Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The testing namespace, for use in test code only.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ChildLauncher.html">ChildLauncher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a child process for testing. Uses gtest <code>ASSERT_*</code> to indicate failure. The child's output is passed through a pipe and is available via <a class="el" href="classcrashpad_1_1test_1_1ChildLauncher.html#a3ed4b8859fa32e8f772e50afc19163ee" title="The read end of a pipe attached to the child&#39;s stdout. ">stdout_read_handle()</a>, and the child's input is attached to a second pipe available via <a class="el" href="classcrashpad_1_1test_1_1ChildLauncher.html#afe9c94037f079ad475e6b0aab992c21f" title="The write end of a pipe attached to the child&#39;s stdin. ">stdin_write_handle()</a>.  <a href="classcrashpad_1_1test_1_1ChildLauncher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1MachMultiprocess.html">MachMultiprocess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a Mach-aware multiprocess test.  <a href="classcrashpad_1_1test_1_1MachMultiprocess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1test_1_1MinidumpWritableTraits.html">MinidumpWritableTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits class defining whether a minidump object type is required to appear only as a fixed-size object or if it is variable-sized.  <a href="structcrashpad_1_1test_1_1MinidumpWritableTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1Multiprocess.html">Multiprocess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a multiprocess test.  <a href="classcrashpad_1_1test_1_1Multiprocess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1MultiprocessExec.html">MultiprocessExec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages an <code>exec()</code>-based multiprocess test.  <a href="classcrashpad_1_1test_1_1MultiprocessExec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1Paths.html">Paths</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to obtain paths from within tests.  <a href="classcrashpad_1_1test_1_1Paths.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ScopedTempDir.html">ScopedTempDir</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAII object that creates a temporary directory for testing.  <a href="classcrashpad_1_1test_1_1ScopedTempDir.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestExceptionSnapshot.html">TestExceptionSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ExceptionSnapshot.html" title="An abstract interface to a snapshot representing an exception that a snapshot process sustained and t...">ExceptionSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestExceptionSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestMemoryMapRegionSnapshot.html">TestMemoryMapRegionSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1MemoryMapRegionSnapshot.html" title="An abstract interface to a snapshot representing a region of the memory map present in the snapshot p...">MemoryMapRegionSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestMemoryMapRegionSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestMemorySnapshot.html">TestMemorySnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1MemorySnapshot.html" title="An abstract interface to a snapshot representing a region of memory present in a snapshot process...">MemorySnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestMemorySnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html">TestMinidumpMemoryWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1SnapshotMinidumpMemoryWriter.html" title="The base class for writers of memory ranges pointed to by MINIDUMP_MEMORY_DESCRIPTOR objects in a min...">SnapshotMinidumpMemoryWriter</a> implementation used for testing.  <a href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestModuleSnapshot.html">TestModuleSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ModuleSnapshot.html" title="An abstract interface to a snapshot representing a code module (binary image) loaded into a snapshot ...">ModuleSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestModuleSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestProcessSnapshot.html">TestProcessSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process. ">ProcessSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestProcessSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestSystemSnapshot.html">TestSystemSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1SystemSnapshot.html" title="An abstract interface to a snapshot representing the state of a system, comprising an operating syste...">SystemSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestSystemSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestThreadSnapshot.html">TestThreadSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ThreadSnapshot.html" title="An abstract interface to a snapshot representing a thread (lightweight process) present in a snapshot...">ThreadSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestThreadSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestUInt32MinidumpWritable.html">TestUInt32MinidumpWritable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classcrashpad_1_1internal_1_1MinidumpWritable.html" title="The base class for all content that might be written to a minidump file. ">internal::MinidumpWritable</a> that carries a <code>uint32_t</code> for testing.  <a href="classcrashpad_1_1test_1_1TestUInt32MinidumpWritable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1WinChildProcess.html">WinChildProcess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates the launching of child processes from unit tests.  <a href="classcrashpad_1_1test_1_1WinChildProcess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1WinMultiprocess.html">WinMultiprocess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a multiprocess test on Windows.  <a href="classcrashpad_1_1test_1_1WinMultiprocess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68bb97f184e9e5a41356a960fdaf3320"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a68bb97f184e9e5a41356a960fdaf3320">MinidumpHeaderAtStart</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__DIRECTORY.html">MINIDUMP_DIRECTORY</a> **directory)</td></tr>
<tr class="memdesc:a68bb97f184e9e5a41356a960fdaf3320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> at the start of a minidump file, along with the <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a> it references.  <a href="#a68bb97f184e9e5a41356a960fdaf3320">More...</a><br /></td></tr>
<tr class="separator:a68bb97f184e9e5a41356a960fdaf3320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e604ee6a23070a89e2a0015eb2854a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5e604ee6a23070a89e2a0015eb2854a9">VerifyMinidumpHeader</a> (const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *header, uint32_t streams, uint32_t timestamp)</td></tr>
<tr class="memdesc:a5e604ee6a23070a89e2a0015eb2854a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> contains expected values.  <a href="#a5e604ee6a23070a89e2a0015eb2854a9">More...</a><br /></td></tr>
<tr class="separator:a5e604ee6a23070a89e2a0015eb2854a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d907f190db31282e6c8a08df38f7f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5d907f190db31282e6c8a08df38f7f3f">ExpectMinidumpMemoryDescriptor</a> (const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *expected, const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *observed)</td></tr>
<tr class="memdesc:a5d907f190db31282e6c8a08df38f7f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values.  <a href="#a5d907f190db31282e6c8a08df38f7f3f">More...</a><br /></td></tr>
<tr class="separator:a5d907f190db31282e6c8a08df38f7f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcb7b725b62a0058c18e0851a1adf5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a7bcb7b725b62a0058c18e0851a1adf5c">ExpectMinidumpMemoryDescriptorAndContents</a> (const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *expected, const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *observed, const std::string &amp;file_contents, uint8_t value, bool at_eof)</td></tr>
<tr class="memdesc:a7bcb7b725b62a0058c18e0851a1adf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values, and that the memory region it points to contains expected values assuming it was written by a <a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html" title="A SnapshotMinidumpMemoryWriter implementation used for testing. ">TestMinidumpMemoryWriter</a> object.  <a href="#a7bcb7b725b62a0058c18e0851a1adf5c">More...</a><br /></td></tr>
<tr class="separator:a7bcb7b725b62a0058c18e0851a1adf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3936c22f43c2defcaa16e7c09ce544"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpRVAList.html">MinidumpRVAList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a1a3936c22f43c2defcaa16e7c09ce544">MinidumpRVAListAtStart</a> (const std::string &amp;file_contents, size_t count)</td></tr>
<tr class="memdesc:a1a3936c22f43c2defcaa16e7c09ce544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structcrashpad_1_1MinidumpRVAList.html" title="A list of RVA pointers. ">MinidumpRVAList</a> at the start of a minidump file.  <a href="#a1a3936c22f43c2defcaa16e7c09ce544">More...</a><br /></td></tr>
<tr class="separator:a1a3936c22f43c2defcaa16e7c09ce544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527731a826e40dd36ac112e7cd3dfcd2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a527731a826e40dd36ac112e7cd3dfcd2">MinidumpStringAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a527731a826e40dd36ac112e7cd3dfcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> located within a minidump file’s contents.  <a href="#a527731a826e40dd36ac112e7cd3dfcd2">More...</a><br /></td></tr>
<tr class="separator:a527731a826e40dd36ac112e7cd3dfcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5bbb381b32ca4c5276a5aacbef1c5f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html">MinidumpUTF8String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a9f5bbb381b32ca4c5276a5aacbef1c5f">MinidumpUTF8StringAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a9f5bbb381b32ca4c5276a5aacbef1c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file. ">MinidumpUTF8String</a> located within a minidump file’s contents.  <a href="#a9f5bbb381b32ca4c5276a5aacbef1c5f">More...</a><br /></td></tr>
<tr class="separator:a9f5bbb381b32ca4c5276a5aacbef1c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2276ff84807d40b2fc4f7fd2ccc8b743"><td class="memItemLeft" align="right" valign="top">base::string16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a2276ff84807d40b2fc4f7fd2ccc8b743">MinidumpStringAtRVAAsString</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a2276ff84807d40b2fc4f7fd2ccc8b743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> as a <code>string16</code>.  <a href="#a2276ff84807d40b2fc4f7fd2ccc8b743">More...</a><br /></td></tr>
<tr class="separator:a2276ff84807d40b2fc4f7fd2ccc8b743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8f1de3f021881b6464a1fedbddf956"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a4d8f1de3f021881b6464a1fedbddf956">MinidumpUTF8StringAtRVAAsString</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a4d8f1de3f021881b6464a1fedbddf956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file. ">MinidumpUTF8String</a> as a <code>std::string</code>.  <a href="#a4d8f1de3f021881b6464a1fedbddf956">More...</a><br /></td></tr>
<tr class="separator:a4d8f1de3f021881b6464a1fedbddf956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbb750966dcd4d580ba9eeb51a45fc6"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5cbb750966dcd4d580ba9eeb51a45fc6">MinidumpWritableAtLocationDescriptorInternal</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location, size_t expected_size, bool allow_oversized_data)</td></tr>
<tr class="memdesc:a5cbb750966dcd4d580ba9eeb51a45fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an untyped minidump object located within a minidump file’s contents, where the offset and size of the object are known.  <a href="#a5cbb750966dcd4d580ba9eeb51a45fc6">More...</a><br /></td></tr>
<tr class="separator:a5cbb750966dcd4d580ba9eeb51a45fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memTemplParams" colspan="2"><a id="acbef5521fa7d72b22f11af5fb6c46c8b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structIMAGE__DEBUG__MISC.html">IMAGE_DEBUG_MISC</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; IMAGE_DEBUG_MISC &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memTemplParams" colspan="2"><a id="a3cfd6e9d9034ac4eb0fa4a81d5d24f47"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_HEADER &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01134f431c0e023b0c28b1b11884d0e"><td class="memTemplParams" colspan="2"><a id="af01134f431c0e023b0c28b1b11884d0e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af01134f431c0e023b0c28b1b11884d0e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MEMORY__LIST.html">MINIDUMP_MEMORY_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MEMORY_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:af01134f431c0e023b0c28b1b11884d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memTemplParams" colspan="2"><a id="a2e4fb44a0fd839f5c5741163cf55e5c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MODULE__LIST.html">MINIDUMP_MODULE_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MODULE_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed533501df3f4de4fa2665ca6b63239"><td class="memTemplParams" colspan="2"><a id="a6ed533501df3f4de4fa2665ca6b63239"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6ed533501df3f4de4fa2665ca6b63239"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__UNLOADED__MODULE__LIST.html">MINIDUMP_UNLOADED_MODULE_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_UNLOADED_MODULE_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a6ed533501df3f4de4fa2665ca6b63239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ac3245d9630d709dda9d852bbb3594"><td class="memTemplParams" colspan="2"><a id="af5ac3245d9630d709dda9d852bbb3594"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af5ac3245d9630d709dda9d852bbb3594"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__THREAD__LIST.html">MINIDUMP_THREAD_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_THREAD_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:af5ac3245d9630d709dda9d852bbb3594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0853a876c74f56925c9fed57df1d4e4"><td class="memTemplParams" colspan="2"><a id="ae0853a876c74f56925c9fed57df1d4e4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae0853a876c74f56925c9fed57df1d4e4"><td class="memTemplItemLeft" align="right" valign="top">const MINIDUMP_HANDLE_DATA_STREAM *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_HANDLE_DATA_STREAM &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae0853a876c74f56925c9fed57df1d4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01e66114473dfd8bb2d3f57af86a09e"><td class="memTemplParams" colspan="2"><a id="ae01e66114473dfd8bb2d3f57af86a09e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae01e66114473dfd8bb2d3f57af86a09e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MEMORY__INFO__LIST.html">MINIDUMP_MEMORY_INFO_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MEMORY_INFO_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae01e66114473dfd8bb2d3f57af86a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ca9502c6765e74527d0a890588aabf"><td class="memTemplParams" colspan="2"><a id="ae1ca9502c6765e74527d0a890588aabf"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae1ca9502c6765e74527d0a890588aabf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfoList.html">MinidumpModuleCrashpadInfoList</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpModuleCrashpadInfoList &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae1ca9502c6765e74527d0a890588aabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memTemplParams" colspan="2"><a id="a7e69ddf4143c3bf004ae589fd7566f88"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionary.html">MinidumpSimpleStringDictionary</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpSimpleStringDictionary &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ec9d484542a9381da429f311f4e301"><td class="memTemplParams" colspan="2"><a id="ad9ec9d484542a9381da429f311f4e301"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad9ec9d484542a9381da429f311f4e301"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1CodeViewRecordPDB20.html">CodeViewRecordPDB20</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; CodeViewRecordPDB20 &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ad9ec9d484542a9381da429f311f4e301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0da61d4589262d25b6955d93378176"><td class="memTemplParams" colspan="2"><a id="a5d0da61d4589262d25b6955d93378176"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5d0da61d4589262d25b6955d93378176"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1CodeViewRecordPDB70.html">CodeViewRecordPDB70</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; CodeViewRecordPDB70 &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a5d0da61d4589262d25b6955d93378176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74140dac921a98cd307aa9935e3d114b"><td class="memItemLeft" align="right" valign="top"><a id="a74140dac921a98cd307aa9935e3d114b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__DIRECTORY.html">MINIDUMP_DIRECTORY</a>)</td></tr>
<tr class="separator:a74140dac921a98cd307aa9935e3d114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d55335cfc826aa10bcca7e5bafbe9d9"><td class="memItemLeft" align="right" valign="top"><a id="a4d55335cfc826aa10bcca7e5bafbe9d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__MEMORY__LIST.html">MINIDUMP_MEMORY_LIST</a>)</td></tr>
<tr class="separator:a4d55335cfc826aa10bcca7e5bafbe9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d1f4c122b7e84f7a7cc47631689fd8"><td class="memItemLeft" align="right" valign="top"><a id="a90d1f4c122b7e84f7a7cc47631689fd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__MODULE__LIST.html">MINIDUMP_MODULE_LIST</a>)</td></tr>
<tr class="separator:a90d1f4c122b7e84f7a7cc47631689fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5764e8ed7252404256e868016da139eb"><td class="memItemLeft" align="right" valign="top"><a id="a5764e8ed7252404256e868016da139eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__UNLOADED__MODULE__LIST.html">MINIDUMP_UNLOADED_MODULE_LIST</a>)</td></tr>
<tr class="separator:a5764e8ed7252404256e868016da139eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b5b9ccf411a827569d2ef7705203a4"><td class="memItemLeft" align="right" valign="top"><a id="a62b5b9ccf411a827569d2ef7705203a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__THREAD__LIST.html">MINIDUMP_THREAD_LIST</a>)</td></tr>
<tr class="separator:a62b5b9ccf411a827569d2ef7705203a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d3876a55220aed734c961912e2593f"><td class="memItemLeft" align="right" valign="top"><a id="ab3d3876a55220aed734c961912e2593f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (MINIDUMP_HANDLE_DATA_STREAM)</td></tr>
<tr class="separator:ab3d3876a55220aed734c961912e2593f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d20ce36664c4dc9929153da348f45a"><td class="memItemLeft" align="right" valign="top"><a id="ad4d20ce36664c4dc9929153da348f45a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__MEMORY__INFO__LIST.html">MINIDUMP_MEMORY_INFO_LIST</a>)</td></tr>
<tr class="separator:ad4d20ce36664c4dc9929153da348f45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a5769138fd33b721795773deea6ce"><td class="memItemLeft" align="right" valign="top"><a id="a7b1a5769138fd33b721795773deea6ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfoList.html">MinidumpModuleCrashpadInfoList</a>)</td></tr>
<tr class="separator:a7b1a5769138fd33b721795773deea6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615edb0cc10ae7de6b93d020cf0bfaf4"><td class="memItemLeft" align="right" valign="top"><a id="a615edb0cc10ae7de6b93d020cf0bfaf4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpRVAList.html">MinidumpRVAList</a>)</td></tr>
<tr class="separator:a615edb0cc10ae7de6b93d020cf0bfaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302566ec2aa6e6771db3b4be4e6aa682"><td class="memItemLeft" align="right" valign="top"><a id="a302566ec2aa6e6771db3b4be4e6aa682"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionary.html">MinidumpSimpleStringDictionary</a>)</td></tr>
<tr class="separator:a302566ec2aa6e6771db3b4be4e6aa682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e90afb7c78eafed9eda8485265ae16a"><td class="memItemLeft" align="right" valign="top"><a id="a2e90afb7c78eafed9eda8485265ae16a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structIMAGE__DEBUG__MISC.html">IMAGE_DEBUG_MISC</a>)</td></tr>
<tr class="separator:a2e90afb7c78eafed9eda8485265ae16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690a621b0359475ed37034c4e75f26b0"><td class="memItemLeft" align="right" valign="top"><a id="a690a621b0359475ed37034c4e75f26b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a>)</td></tr>
<tr class="separator:a690a621b0359475ed37034c4e75f26b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2227fbf02e47435f050101570bf0f7ba"><td class="memItemLeft" align="right" valign="top"><a id="a2227fbf02e47435f050101570bf0f7ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1CodeViewRecordPDB20.html">CodeViewRecordPDB20</a>)</td></tr>
<tr class="separator:a2227fbf02e47435f050101570bf0f7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c365f95d8aa537d13f617dfc13991c3"><td class="memItemLeft" align="right" valign="top"><a id="a9c365f95d8aa537d13f617dfc13991c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1CodeViewRecordPDB70.html">CodeViewRecordPDB70</a>)</td></tr>
<tr class="separator:a9c365f95d8aa537d13f617dfc13991c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61f5e906dff25a41c015dbcf02a8cff"><td class="memItemLeft" align="right" valign="top"><a id="af61f5e906dff25a41c015dbcf02a8cff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpUTF8String.html">MinidumpUTF8String</a>)</td></tr>
<tr class="separator:af61f5e906dff25a41c015dbcf02a8cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4ed41a7f2c94d294e1c1bca34a3e15"><td class="memItemLeft" align="right" valign="top"><a id="a7b4ed41a7f2c94d294e1c1bca34a3e15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (uint8_t)</td></tr>
<tr class="separator:a7b4ed41a7f2c94d294e1c1bca34a3e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda65d4c6e9c710f32fcbd9af6a03357"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abda65d4c6e9c710f32fcbd9af6a03357"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#abda65d4c6e9c710f32fcbd9af6a03357">TMinidumpWritableAtLocationDescriptor</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="memdesc:abda65d4c6e9c710f32fcbd9af6a03357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known.  <a href="#abda65d4c6e9c710f32fcbd9af6a03357">More...</a><br /></td></tr>
<tr class="separator:abda65d4c6e9c710f32fcbd9af6a03357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e98915fad73c8628924c3a900732fc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e98915fad73c8628924c3a900732fc0"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0">MinidumpWritableAtLocationDescriptor</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="memdesc:a0e98915fad73c8628924c3a900732fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known.  <a href="#a0e98915fad73c8628924c3a900732fc0">More...</a><br /></td></tr>
<tr class="separator:a0e98915fad73c8628924c3a900732fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3e635fd21c8c642d41ceb2072e7d08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b3e635fd21c8c642d41ceb2072e7d08"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5b3e635fd21c8c642d41ceb2072e7d08">MinidumpWritableAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a5b3e635fd21c8c642d41ceb2072e7d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typed minidump object located within a minidump file’s contents, where the offset of the object is known.  <a href="#a5b3e635fd21c8c642d41ceb2072e7d08">More...</a><br /></td></tr>
<tr class="separator:a5b3e635fd21c8c642d41ceb2072e7d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9504862c089964763d7d362572c2ac6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#ad9504862c089964763d7d362572c2ac6">ErrnoMessage</a> (int err, const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:ad9504862c089964763d7d362572c2ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message using an <code>errno</code> value.  <a href="#ad9504862c089964763d7d362572c2ac6">More...</a><br /></td></tr>
<tr class="separator:ad9504862c089964763d7d362572c2ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8e66fbc47a4f22a03710797f226238"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a8d8e66fbc47a4f22a03710797f226238">ErrnoMessage</a> (const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a8d8e66fbc47a4f22a03710797f226238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message using <code>errno</code>.  <a href="#a8d8e66fbc47a4f22a03710797f226238">More...</a><br /></td></tr>
<tr class="separator:a8d8e66fbc47a4f22a03710797f226238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d079e80aa56bc0840f1c0b944e01bfb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a2d079e80aa56bc0840f1c0b944e01bfb">ErrorMessage</a> (const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a2d079e80aa56bc0840f1c0b944e01bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message using <code>GetLastError()</code>.  <a href="#a2d079e80aa56bc0840f1c0b944e01bfb">More...</a><br /></td></tr>
<tr class="separator:a2d079e80aa56bc0840f1c0b944e01bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cad311e386c21af1ca653f2aca2695b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a8cad311e386c21af1ca653f2aca2695b">FileExists</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:a8cad311e386c21af1ca653f2aca2695b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a file exists.  <a href="#a8cad311e386c21af1ca653f2aca2695b">More...</a><br /></td></tr>
<tr class="separator:a8cad311e386c21af1ca653f2aca2695b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897d99ec1dd2c343d29a3d14e3560732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecrashpad.html#a1e53a1957d9edcba8b406ea632b6daf2">FileOffset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a897d99ec1dd2c343d29a3d14e3560732">FileSize</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:a897d99ec1dd2c343d29a3d14e3560732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the size of a file.  <a href="#a897d99ec1dd2c343d29a3d14e3560732">More...</a><br /></td></tr>
<tr class="separator:a897d99ec1dd2c343d29a3d14e3560732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4835fcb6a4a897b0841b8575789b77"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#aaa4835fcb6a4a897b0841b8575789b77">BytesToHexString</a> (const void *bytes, size_t length)</td></tr>
<tr class="memdesc:aaa4835fcb6a4a897b0841b8575789b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hexadecimal string corresponding to <em>bytes</em> and <em>length</em>.  <a href="#aaa4835fcb6a4a897b0841b8575789b77">More...</a><br /></td></tr>
<tr class="separator:aaa4835fcb6a4a897b0841b8575789b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a7a2461cf4e1f674eac147c19d9483"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a49a7a2461cf4e1f674eac147c19d9483">MachErrorMessage</a> (mach_error_t mach_err, const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a49a7a2461cf4e1f674eac147c19d9483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a Mach error message.  <a href="#a49a7a2461cf4e1f674eac147c19d9483">More...</a><br /></td></tr>
<tr class="separator:a49a7a2461cf4e1f674eac147c19d9483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db2fa97998b00a8ee57398fa8c8b14e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a8db2fa97998b00a8ee57398fa8c8b14e">BootstrapErrorMessage</a> (kern_return_t bootstrap_err, const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a8db2fa97998b00a8ee57398fa8c8b14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a bootstrap error message.  <a href="#a8db2fa97998b00a8ee57398fa8c8b14e">More...</a><br /></td></tr>
<tr class="separator:a8db2fa97998b00a8ee57398fa8c8b14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35412b33d0a275fa43e8633296059534"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a35412b33d0a275fa43e8633296059534">ReadStreamToString</a> (<a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *stream)</td></tr>
<tr class="memdesc:a35412b33d0a275fa43e8633296059534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body. ">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string.  <a href="#a35412b33d0a275fa43e8633296059534">More...</a><br /></td></tr>
<tr class="separator:a35412b33d0a275fa43e8633296059534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861ba97c72a60c7e1802c39395d1d1fe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a861ba97c72a60c7e1802c39395d1d1fe">ReadStreamToString</a> (<a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *stream, size_t buffer_size)</td></tr>
<tr class="memdesc:a861ba97c72a60c7e1802c39395d1d1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body. ">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string.  <a href="#a861ba97c72a60c7e1802c39395d1d1fe">More...</a><br /></td></tr>
<tr class="separator:a861ba97c72a60c7e1802c39395d1d1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afefac1494b6a67c50a254c75a8caccf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#afefac1494b6a67c50a254c75a8caccf1">InitializeMinidumpContextX86</a> (<a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:afefac1494b6a67c50a254c75a8caccf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <a href="#afefac1494b6a67c50a254c75a8caccf1">More...</a><br /></td></tr>
<tr class="separator:afefac1494b6a67c50a254c75a8caccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1dd7166c73ca082608b1ab21b5a395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#afa1dd7166c73ca082608b1ab21b5a395">InitializeMinidumpContextAMD64</a> (<a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html">MinidumpContextAMD64</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:afa1dd7166c73ca082608b1ab21b5a395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <a href="#afa1dd7166c73ca082608b1ab21b5a395">More...</a><br /></td></tr>
<tr class="separator:afa1dd7166c73ca082608b1ab21b5a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a774c6adc6455eb01f0595262c1ce7df9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a774c6adc6455eb01f0595262c1ce7df9">ExpectMinidumpContextX86</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:a774c6adc6455eb01f0595262c1ce7df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a context structure contains expected values.  <a href="#a774c6adc6455eb01f0595262c1ce7df9">More...</a><br /></td></tr>
<tr class="separator:a774c6adc6455eb01f0595262c1ce7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b85697010c624299be8ac6192cc3ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#ac5b85697010c624299be8ac6192cc3ed">ExpectMinidumpContextAMD64</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html">MinidumpContextAMD64</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:ac5b85697010c624299be8ac6192cc3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a context structure contains expected values.  <a href="#ac5b85697010c624299be8ac6192cc3ed">More...</a><br /></td></tr>
<tr class="separator:ac5b85697010c624299be8ac6192cc3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adfb5c0e6e1c121bdac4c663a3fa0db06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#adfb5c0e6e1c121bdac4c663a3fa0db06">InitializeCPUContextX86</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:adfb5c0e6e1c121bdac4c663a3fa0db06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <a href="#adfb5c0e6e1c121bdac4c663a3fa0db06">More...</a><br /></td></tr>
<tr class="separator:adfb5c0e6e1c121bdac4c663a3fa0db06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea06b36ac8ee94add2d8aaca404265c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a9ea06b36ac8ee94add2d8aaca404265c">InitializeCPUContextX86_64</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a9ea06b36ac8ee94add2d8aaca404265c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <a href="#a9ea06b36ac8ee94add2d8aaca404265c">More...</a><br /></td></tr>
<tr class="separator:a9ea06b36ac8ee94add2d8aaca404265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a623baebebe1cf76d4ddcd1ba30116587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a623baebebe1cf76d4ddcd1ba30116587">InitializeCPUContextX86Fxsave</a> (<a class="el" href="structcrashpad_1_1CPUContextX86_1_1Fxsave.html">CPUContextX86::Fxsave</a> *fxsave, uint32_t *seed)</td></tr>
<tr class="memdesc:a623baebebe1cf76d4ddcd1ba30116587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <code>fxsave</code> context substructure for testing.  <a href="#a623baebebe1cf76d4ddcd1ba30116587">More...</a><br /></td></tr>
<tr class="separator:a623baebebe1cf76d4ddcd1ba30116587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d029ec1724e63a58007a8705975df23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5d029ec1724e63a58007a8705975df23">InitializeCPUContextX86_64Fxsave</a> (<a class="el" href="structcrashpad_1_1CPUContextX86__64_1_1Fxsave.html">CPUContextX86_64::Fxsave</a> *fxsave, uint32_t *seed)</td></tr>
<tr class="memdesc:a5d029ec1724e63a58007a8705975df23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <code>fxsave</code> context substructure for testing.  <a href="#a5d029ec1724e63a58007a8705975df23">More...</a><br /></td></tr>
<tr class="separator:a5d029ec1724e63a58007a8705975df23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The testing namespace, for use in test code only. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8db2fa97998b00a8ee57398fa8c8b14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db2fa97998b00a8ee57398fa8c8b14e">&sect;&nbsp;</a></span>BootstrapErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::BootstrapErrorMessage </td>
          <td>(</td>
          <td class="paramtype">kern_return_t&#160;</td>
          <td class="paramname"><em>bootstrap_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a bootstrap error message. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bootstrap_err</td><td>The bootstrap error code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"Permission denied (1100)"</code> if <em>bootstrap_err</em> has the value <code>BOOTSTRAP_NOT_PRIVILEGED</code> on a system where this is defined to be 1100. If <em>base</em> is not empty, it will be prepended to this string, separated by a colon. If <em>bootstrap_err</em> is not a valid bootstrap error code, it will be interpreted as a Mach error code in the manner of <a class="el" href="namespacecrashpad_1_1test.html#a49a7a2461cf4e1f674eac147c19d9483" title="Formats a Mach error message. ">MachErrorMessage()</a>. </dd></dl>

</div>
</div>
<a id="aaa4835fcb6a4a897b0841b8575789b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4835fcb6a4a897b0841b8575789b77">&sect;&nbsp;</a></span>BytesToHexString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::BytesToHexString </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hexadecimal string corresponding to <em>bytes</em> and <em>length</em>. </p>
<p>Example usage: </p><div class="fragment"><div class="line">uint8_t expected[10];</div><div class="line">uint8_t observed[10];</div><div class="line"><span class="comment">// …</span></div><div class="line">EXPECT_EQ(<a class="code" href="namespacecrashpad_1_1test.html#aaa4835fcb6a4a897b0841b8575789b77">BytesToHexString</a>(expected, arraysize(expected)),</div><div class="line">          <a class="code" href="namespacecrashpad_1_1test.html#aaa4835fcb6a4a897b0841b8575789b77">BytesToHexString</a>(observed, arraysize(observed)));</div></div><!-- fragment --> 
</div>
</div>
<a id="ad9504862c089964763d7d362572c2ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9504862c089964763d7d362572c2ac6">&sect;&nbsp;</a></span>ErrnoMessage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ErrnoMessage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats an error message using an <code>errno</code> value. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error.</p>
<p>The message is formatted using <code>strerror()</code>. <em>err</em> may be <code>0</code> or outside of the range of known error codes, and the message returned will contain the string that <code>strerror()</code> uses in these cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>The error code, usable as an <code>errno</code> value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"Operation not permitted (1)"</code> if <em>err</em> has the value <code>EPERM</code> on a system where this is defined to be <code>1</code>. If <em>base</em> is not empty, it will be prepended to this string, separated by a colon. </dd></dl>

</div>
</div>
<a id="a8d8e66fbc47a4f22a03710797f226238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8e66fbc47a4f22a03710797f226238">&sect;&nbsp;</a></span>ErrnoMessage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ErrnoMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats an error message using <code>errno</code>. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error.</p>
<p>The message is formatted using <code>strerror()</code>. <code>errno</code> may be <code>0</code> or outside of the range of known error codes, and the message returned will contain the string that <code>strerror()</code> uses in these cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"Operation not permitted (1)"</code> if <code>errno</code> has the value <code>EPERM</code> on a system where this is defined to be <code>1</code>. If <em>base</em> is not empty, it will be prepended to this string, separated by a colon. </dd></dl>

</div>
</div>
<a id="a2d079e80aa56bc0840f1c0b944e01bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d079e80aa56bc0840f1c0b944e01bfb">&sect;&nbsp;</a></span>ErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ErrorMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats an error message using <code>GetLastError()</code>. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error. The format is the same as the <code>PLOG()</code> formatting in base. </p>

</div>
</div>
<a id="ac5b85697010c624299be8ac6192cc3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b85697010c624299be8ac6192cc3ed">&sect;&nbsp;</a></span>ExpectMinidumpContextAMD64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextAMD64 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expect_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html">MinidumpContextAMD64</a> *&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snapshot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em>expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em>observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> snapshot. If <code>false</code>, compare <em>observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a774c6adc6455eb01f0595262c1ce7df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774c6adc6455eb01f0595262c1ce7df9">&sect;&nbsp;</a></span>ExpectMinidumpContextX86()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextX86 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expect_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snapshot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em>expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em>observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> snapshot. If <code>false</code>, compare <em>observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d907f190db31282e6c8a08df38f7f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d907f190db31282e6c8a08df38f7f3f">&sect;&nbsp;</a></span>ExpectMinidumpMemoryDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpMemoryDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *&#160;</td>
          <td class="paramname"><em>observed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values. </p>
<p>In <em>expected</em> and <em>observed</em>, <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html#ac6d589aa4a3b82315866f2a27bee770c" title="The base address of the memory region in the address space of the process that the minidump file cont...">MINIDUMP_MEMORY_DESCRIPTOR::StartOfMemoryRange</a> and <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html#ad83430521d4a8991d85e06be61525a92" title="The size of the referenced structure or union, in bytes. ">MINIDUMP_LOCATION_DESCRIPTOR::DataSize</a> are compared and must match. If <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html#ae877992492577366d7185721b8239877" title="The relative virtual address of the structure or union within the minidump file. ">MINIDUMP_LOCATION_DESCRIPTOR::Rva</a> is nonzero in <em>expected</em>, the same field in <em>observed</em> must match it, subject to a 16-byte alignment augmentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing expected values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing observed values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bcb7b725b62a0058c18e0851a1adf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcb7b725b62a0058c18e0851a1adf5c">&sect;&nbsp;</a></span>ExpectMinidumpMemoryDescriptorAndContents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpMemoryDescriptorAndContents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>at_eof</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values, and that the memory region it points to contains expected values assuming it was written by a <a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html" title="A SnapshotMinidumpMemoryWriter implementation used for testing. ">TestMinidumpMemoryWriter</a> object. </p>
<p><em>expected</em> and <em>observed</em> are compared by <a class="el" href="namespacecrashpad_1_1test.html#a5d907f190db31282e6c8a08df38f7f3f" title="Verifies, via gtest assertions, that a MINIDUMP_MEMORY_DESCRIPTOR structure contains expected values...">ExpectMinidumpMemoryDescriptor()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing expected values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing observed values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file in which <em>observed</em> was found. The memory region referenced by <em>observed</em> will be read from this string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <em>value</em> used to create a <a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html" title="A SnapshotMinidumpMemoryWriter implementation used for testing. ">TestMinidumpMemoryWriter</a>. Each byte of memory in the region referenced by <em>observed</em> must be this value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">at_eof</td><td>If <code>true</code>, the region referenced by <em>observed</em> must appear at the end of <em>file_contents</em>, without any data following it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cad311e386c21af1ca653f2aca2695b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cad311e386c21af1ca653f2aca2695b">&sect;&nbsp;</a></span>FileExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::test::FileExists </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a file exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to check for existence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>path</em> exists. <code>false</code> if it does not exist. If an error other than “file not found” occurs when searching for <em>path</em>, returns <code>false</code> with a gtest failure added. </dd></dl>

</div>
</div>
<a id="a897d99ec1dd2c343d29a3d14e3560732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897d99ec1dd2c343d29a3d14e3560732">&sect;&nbsp;</a></span>FileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecrashpad.html#a1e53a1957d9edcba8b406ea632b6daf2">FileOffset</a> crashpad::test::FileSize </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the size of a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path of the file to check. The file must exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the file at <em>path</em>. If the file does not exist, or an error occurs when attempting to determine its size, returns <code>-1</code> with a gtest failure added. </dd></dl>

</div>
</div>
<a id="adfb5c0e6e1c121bdac4c663a3fa0db06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb5c0e6e1c121bdac4c663a3fa0db06">&sect;&nbsp;</a></span>InitializeCPUContextX86()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="namespacecrashpad_1_1test.html#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing. ">InitializeMinidumpContextX86()</a> and <a class="el" href="namespacecrashpad_1_1test.html#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing. ">InitializeMinidumpContextAMD64()</a> for identical <em>seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em>seed</em> is <code>0</code>, <em>context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union...">CPUContext::architecture</a> field, which will identify the context type. If <em>seed</em> is nonzero, <em>context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ea06b36ac8ee94add2d8aaca404265c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea06b36ac8ee94add2d8aaca404265c">&sect;&nbsp;</a></span>InitializeCPUContextX86_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="namespacecrashpad_1_1test.html#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing. ">InitializeMinidumpContextX86()</a> and <a class="el" href="namespacecrashpad_1_1test.html#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing. ">InitializeMinidumpContextAMD64()</a> for identical <em>seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em>seed</em> is <code>0</code>, <em>context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union...">CPUContext::architecture</a> field, which will identify the context type. If <em>seed</em> is nonzero, <em>context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d029ec1724e63a58007a8705975df23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d029ec1724e63a58007a8705975df23">&sect;&nbsp;</a></span>InitializeCPUContextX86_64Fxsave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86_64Fxsave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContextX86__64_1_1Fxsave.html">CPUContextX86_64::Fxsave</a> *&#160;</td>
          <td class="paramname"><em>fxsave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an <code>fxsave</code> context substructure for testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fxsave</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">seed</td><td>The seed value. Initializing two <code>fxsave</code> structures of the same type with identical seed values should produce identical structures. Initialization with a different seed value should produce a different <code>fxsave</code> structure. If <em>seed</em> is <code>0</code>, <em>fxsave</em> is zeroed out entirely. If <em>seed</em> is nonzero, <em>fxsave</em> will be populated entirely with nonzero values. <em>seed</em> will be updated by this function to allow the caller to perform subsequent initialization of the context structure containing <em>fxsave</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a623baebebe1cf76d4ddcd1ba30116587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623baebebe1cf76d4ddcd1ba30116587">&sect;&nbsp;</a></span>InitializeCPUContextX86Fxsave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86Fxsave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContextX86_1_1Fxsave.html">CPUContextX86::Fxsave</a> *&#160;</td>
          <td class="paramname"><em>fxsave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an <code>fxsave</code> context substructure for testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fxsave</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">seed</td><td>The seed value. Initializing two <code>fxsave</code> structures of the same type with identical seed values should produce identical structures. Initialization with a different seed value should produce a different <code>fxsave</code> structure. If <em>seed</em> is <code>0</code>, <em>fxsave</em> is zeroed out entirely. If <em>seed</em> is nonzero, <em>fxsave</em> will be populated entirely with nonzero values. <em>seed</em> will be updated by this function to allow the caller to perform subsequent initialization of the context structure containing <em>fxsave</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa1dd7166c73ca082608b1ab21b5a395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1dd7166c73ca082608b1ab21b5a395">&sect;&nbsp;</a></span>InitializeMinidumpContextAMD64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextAMD64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html">MinidumpContextAMD64</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> test initialization functions such as <a class="el" href="namespacecrashpad_1_1test.html#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing. ">InitializeCPUContextX86()</a> and <a class="el" href="namespacecrashpad_1_1test.html#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing. ">InitializeCPUContextX86_64()</a> for identical <em>seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em>seed</em> is <code>0</code>, <em>context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em>seed</em> is nonzero, <em>context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afefac1494b6a67c50a254c75a8caccf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefac1494b6a67c50a254c75a8caccf1">&sect;&nbsp;</a></span>InitializeMinidumpContextX86()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextX86 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> test initialization functions such as <a class="el" href="namespacecrashpad_1_1test.html#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing. ">InitializeCPUContextX86()</a> and <a class="el" href="namespacecrashpad_1_1test.html#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing. ">InitializeCPUContextX86_64()</a> for identical <em>seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em>seed</em> is <code>0</code>, <em>context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em>seed</em> is nonzero, <em>context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49a7a2461cf4e1f674eac147c19d9483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a7a2461cf4e1f674eac147c19d9483">&sect;&nbsp;</a></span>MachErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::MachErrorMessage </td>
          <td>(</td>
          <td class="paramtype">mach_error_t&#160;</td>
          <td class="paramname"><em>mach_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a Mach error message. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mach_err</td><td>The Mach error code, which may be a <code>kern_return_t</code> or related type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"(os/kern) invalid address (1)"</code> if <em>mach_err</em> has the value <code>KERN_INVALID_ADDRESS</code> on a system where this is defined to be 1. If <em>base</em> is not empty, it will be prepended to this string, separated by a colon. </dd></dl>

</div>
</div>
<a id="a68bb97f184e9e5a41356a960fdaf3320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bb97f184e9e5a41356a960fdaf3320">&sect;&nbsp;</a></span>MinidumpHeaderAtStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> * crashpad::test::MinidumpHeaderAtStart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__DIRECTORY.html">MINIDUMP_DIRECTORY</a> **&#160;</td>
          <td class="paramname"><em>directory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> at the start of a minidump file, along with the <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a> it references. </p>
<p>This function validates the <a class="el" href="structMINIDUMP__HEADER.html#ae1c77644aa56ab70fd6f50c343eafda8" title="The minidump file format magic number, MINIDUMP_SIGNATURE. ">MINIDUMP_HEADER::Signature</a> and <a class="el" href="structMINIDUMP__HEADER.html#a7ea8d51f5ca990eec9eb0b3643c6b406" title="The minidump file format version number, MINIDUMP_VERSION. ">MINIDUMP_HEADER::Version</a> fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">directory</td><td>The <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a> referenced by the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a>. If the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> does not reference a <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a>, <code>nullptr</code> without raising a gtest assertion. If the referenced <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a> is not valid, <code>nullptr</code> with a gtest assertion raised. On failure, <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> at the beginning of the minidump file. On failure, raises a gtest assertion and returns <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a1a3936c22f43c2defcaa16e7c09ce544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3936c22f43c2defcaa16e7c09ce544">&sect;&nbsp;</a></span>MinidumpRVAListAtStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcrashpad_1_1MinidumpRVAList.html">MinidumpRVAList</a> * crashpad::test::MinidumpRVAListAtStart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structcrashpad_1_1MinidumpRVAList.html" title="A list of RVA pointers. ">MinidumpRVAList</a> at the start of a minidump file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8" title="An offset within a minidump file, relative to the start of its MINIDUMP_HEADER. ">RVA</a> objects expected in the <a class="el" href="structcrashpad_1_1MinidumpRVAList.html" title="A list of RVA pointers. ">MinidumpRVAList</a>. This function will only be successful if exactly this many objects are present, and if space for them exists in <em>file_contents</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the <a class="el" href="structcrashpad_1_1MinidumpRVAList.html" title="A list of RVA pointers. ">MinidumpRVAList</a> at the beginning of the file. On failure, raises a gtest assertion and returns <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a527731a826e40dd36ac112e7cd3dfcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527731a826e40dd36ac112e7cd3dfcd2">&sect;&nbsp;</a></span>MinidumpStringAtRVA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a> * crashpad::test::MinidumpStringAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> located within a minidump file’s contents. </p>
<p>If <em>rva</em> points outside of the range of <em>file_contents</em>, if the string has an incorrect length or is not <code>NUL</code>-terminated, or if any of the string data would lie outside of the range of <em>file_contents</em>, this function will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> in <em>file_contents</em>. On failure, raises a gtest assertion and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a2276ff84807d40b2fc4f7fd2ccc8b743" title="Returns the contents of a MINIDUMP_STRING as a string16. ">MinidumpStringAtRVAAsString()</a> </dd>
<dd>
<a class="el" href="namespacecrashpad_1_1test.html#a9f5bbb381b32ca4c5276a5aacbef1c5f" title="Returns a MinidumpUTF8String located within a minidump file’s contents. ">MinidumpUTF8StringAtRVA()</a> </dd></dl>

</div>
</div>
<a id="a2276ff84807d40b2fc4f7fd2ccc8b743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2276ff84807d40b2fc4f7fd2ccc8b743">&sect;&nbsp;</a></span>MinidumpStringAtRVAAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">base::string16 crashpad::test::MinidumpStringAtRVAAsString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> as a <code>string16</code>. </p>
<p>This function uses <a class="el" href="namespacecrashpad_1_1test.html#a527731a826e40dd36ac112e7cd3dfcd2" title="Returns a MINIDUMP_STRING located within a minidump file’s contents. ">MinidumpStringAtRVA()</a> to obtain a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a>, and returns the string data as a <code>string16</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the string read from <em>file_writer</em> at offset <em>rva</em>. On failure, raises a gtest assertion and returns an empty string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a4d8f1de3f021881b6464a1fedbddf956" title="Returns the contents of a MinidumpUTF8String as a std::string. ">MinidumpUTF8StringAtRVAAsString()</a> </dd></dl>

</div>
</div>
<a id="a9f5bbb381b32ca4c5276a5aacbef1c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5bbb381b32ca4c5276a5aacbef1c5f">&sect;&nbsp;</a></span>MinidumpUTF8StringAtRVA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html">MinidumpUTF8String</a> * crashpad::test::MinidumpUTF8StringAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file. ">MinidumpUTF8String</a> located within a minidump file’s contents. </p>
<p>If <em>rva</em> points outside of the range of <em>file_contents</em>, if the string has an incorrect length or is not <code>NUL</code>-terminated, or if any of the string data would lie outside of the range of <em>file_contents</em>, this function will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file. ">MinidumpUTF8String</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file. ">MinidumpUTF8String</a> in <em>file_contents</em>. On failure, raises a gtest assertion and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a4d8f1de3f021881b6464a1fedbddf956" title="Returns the contents of a MinidumpUTF8String as a std::string. ">MinidumpUTF8StringAtRVAAsString()</a> </dd>
<dd>
<a class="el" href="namespacecrashpad_1_1test.html#a527731a826e40dd36ac112e7cd3dfcd2" title="Returns a MINIDUMP_STRING located within a minidump file’s contents. ">MinidumpStringAtRVA()</a> </dd></dl>

</div>
</div>
<a id="a4d8f1de3f021881b6464a1fedbddf956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8f1de3f021881b6464a1fedbddf956">&sect;&nbsp;</a></span>MinidumpUTF8StringAtRVAAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::MinidumpUTF8StringAtRVAAsString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file. ">MinidumpUTF8String</a> as a <code>std::string</code>. </p>
<p>This function uses <a class="el" href="namespacecrashpad_1_1test.html#a9f5bbb381b32ca4c5276a5aacbef1c5f" title="Returns a MinidumpUTF8String located within a minidump file’s contents. ">MinidumpUTF8StringAtRVA()</a> to obtain a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file. ">MinidumpUTF8String</a>, and returns the string data as a <code>std::string</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file. ">MinidumpUTF8String</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the string read from <em>file_writer</em> at offset <em>rva</em>. On failure, raises a gtest assertion and returns an empty string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a2276ff84807d40b2fc4f7fd2ccc8b743" title="Returns the contents of a MINIDUMP_STRING as a string16. ">MinidumpStringAtRVAAsString()</a> </dd></dl>

</div>
</div>
<a id="a0e98915fad73c8628924c3a900732fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e98915fad73c8628924c3a900732fc0">&sect;&nbsp;</a></span>MinidumpWritableAtLocationDescriptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* crashpad::test::MinidumpWritableAtLocationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known. </p>
<p>This function has template specializations that perform more stringent checking than the default implementation:</p><ul>
<li>With a <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> template parameter, a template specialization ensures that the structure’s magic number and version fields are correct.</li>
<li>With a <a class="el" href="structMINIDUMP__MEMORY__LIST.html" title="Information about memory regions within the process. ">MINIDUMP_MEMORY_LIST</a>, <a class="el" href="structMINIDUMP__THREAD__LIST.html" title="Information about all threads within the process. ">MINIDUMP_THREAD_LIST</a>, <a class="el" href="structMINIDUMP__MODULE__LIST.html" title="Information about all modules loaded within the process at the time the snapshot was taken...">MINIDUMP_MODULE_LIST</a>, <a class="el" href="structMINIDUMP__MEMORY__INFO__LIST.html" title="Contains a list of memory regions. ">MINIDUMP_MEMORY_INFO_LIST</a>, or <a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionary.html" title="A list of key-value pairs. ">MinidumpSimpleStringDictionary</a> template parameter, template specializations ensure that the size given by <em>location</em> matches the size expected of a stream containing the number of elements it claims to have.</li>
<li>With an <a class="el" href="structIMAGE__DEBUG__MISC.html" title="Miscellaneous debugging record. ">IMAGE_DEBUG_MISC</a>, <a class="el" href="structcrashpad_1_1CodeViewRecordPDB20.html" title="A CodeView record linking to a .pdb 2.0 file. ">CodeViewRecordPDB20</a>, or <a class="el" href="structcrashpad_1_1CodeViewRecordPDB70.html" title="A CodeView record linking to a .pdb 7.0 file. ">CodeViewRecordPDB70</a> template parameter, template specializations ensure that the structure has the expected format including any magic number and the <code>NUL</code>- terminated string.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>A <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html" title="A pointer to a structure or union within a minidump file. ">MINIDUMP_LOCATION_DESCRIPTOR</a> giving the offset within the minidump file of the desired object, as well as its size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the size of <em>location</em> is at least as big as the size of the requested object, and if <em>location</em> is within the range of <em>file_contents</em>, returns a pointer into <em>file_contents</em> at offset <em>rva</em>. Otherwise, raises a gtest assertion failure and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a5b3e635fd21c8c642d41ceb2072e7d08" title="Returns a typed minidump object located within a minidump file’s contents, where the offset of the o...">MinidumpWritableAtRVA()</a> </dd></dl>

</div>
</div>
<a id="a5cbb750966dcd4d580ba9eeb51a45fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbb750966dcd4d580ba9eeb51a45fc6">&sect;&nbsp;</a></span>MinidumpWritableAtLocationDescriptorInternal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * crashpad::test::MinidumpWritableAtLocationDescriptorInternal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_oversized_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an untyped minidump object located within a minidump file’s contents, where the offset and size of the object are known. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>A <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html" title="A pointer to a structure or union within a minidump file. ">MINIDUMP_LOCATION_DESCRIPTOR</a> giving the offset within the minidump file of the desired object, as well as its size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_size</td><td>The expected size of the object. If <em>allow_oversized_data</em> is <code>true</code>, <em>expected_size</em> is treated as the minimum size of <em>location</em>, but it is permitted to be larger. If <em>allow_oversized_data</em> is <code>false</code>, the size of <em>location</em> must match <em>expected_size</em> exactly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_oversized_data</td><td>Controls whether <em>expected_size</em> is a minimum limit (<code>true</code>) or an exact match is required (<code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the size of <em>location</em> is agrees with <em>expected_size</em>, and if <em>location</em> is within the range of <em>file_contents</em>, returns a pointer into <em>file_contents</em> at offset <em>rva</em>. Otherwise, raises a gtest assertion failure and returns <code>nullptr</code>.</dd></dl>
<p>Do not call this function. Use the typed version, <a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a>, or another type-specific function. </p>

</div>
</div>
<a id="a5b3e635fd21c8c642d41ceb2072e7d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3e635fd21c8c642d41ceb2072e7d08">&sect;&nbsp;</a></span>MinidumpWritableAtRVA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* crashpad::test::MinidumpWritableAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a typed minidump object located within a minidump file’s contents, where the offset of the object is known. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>rva</em> plus the size of an object of type <em>T</em> is within the range of <em>file_contents</em>, returns a pointer into <em>file_contents</em> at offset <em>rva</em>. Otherwise, raises a gtest assertion failure and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> </dd></dl>

</div>
</div>
<a id="a35412b33d0a275fa43e8633296059534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35412b33d0a275fa43e8633296059534">&sect;&nbsp;</a></span>ReadStreamToString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ReadStreamToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body. ">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream from which to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the stream, or an empty string on failure. </dd></dl>

</div>
</div>
<a id="a861ba97c72a60c7e1802c39395d1d1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861ba97c72a60c7e1802c39395d1d1fe">&sect;&nbsp;</a></span>ReadStreamToString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ReadStreamToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body. ">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream from which to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>The size of the buffer to use when reading from the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the stream, or an empty string on failure. </dd></dl>

</div>
</div>
<a id="abda65d4c6e9c710f32fcbd9af6a03357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda65d4c6e9c710f32fcbd9af6a03357">&sect;&nbsp;</a></span>TMinidumpWritableAtLocationDescriptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* crashpad::test::TMinidumpWritableAtLocationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known. </p>
<p>This function is similar to <a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> and is used to implement that function. It exists independently so that template specializations are able to call this function, which provides the default implementation.</p>
<p>Do not call this function directly. Use <a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> instead. </p>

</div>
</div>
<a id="a5e604ee6a23070a89e2a0015eb2854a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e604ee6a23070a89e2a0015eb2854a9">&sect;&nbsp;</a></span>VerifyMinidumpHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::VerifyMinidumpHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> contains expected values. </p>
<p>All fields in the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> will be evaluated except for the Signature and Version fields, because those are checked by <a class="el" href="namespacecrashpad_1_1test.html#a68bb97f184e9e5a41356a960fdaf3320" title="Returns the MINIDUMP_HEADER at the start of a minidump file, along with the MINIDUMP_DIRECTORY it ref...">MinidumpHeaderAtStart()</a>. Most other fields are are compared to their correct default values. <a class="el" href="structMINIDUMP__HEADER.html#ac64203d27bba37f630437048a0e19630" title="The number of MINIDUMP_DIRECTORY elements present in the directory referenced by StreamDirectoryRva. ">MINIDUMP_HEADER::NumberOfStreams</a> is compared to <em>streams</em>, and <a class="el" href="structMINIDUMP__HEADER.html#a5f3811a143f2a6405e721d03d8c86f1d" title="The time that the minidump file was generated, in time_t format, the number of seconds since the POSI...">MINIDUMP_HEADER::TimeDateStamp</a> is compared to <em>timestamp</em>. Most fields are checked with nonfatal EXPECT-style assertions, but <a class="el" href="structMINIDUMP__HEADER.html#ac64203d27bba37f630437048a0e19630" title="The number of MINIDUMP_DIRECTORY elements present in the directory referenced by StreamDirectoryRva. ">MINIDUMP_HEADER::NumberOfStreams</a> and <a class="el" href="structMINIDUMP__HEADER.html#afc88b1f46827fbeae6ef6e0718a23b57" title="A pointer to an array of MINIDUMP_DIRECTORY structures that identify all of the streams within this m...">MINIDUMP_HEADER::StreamDirectoryRva</a> are checked with fatal ASSERT-style assertions, because they must be correct in order for processing of the minidump to continue. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
