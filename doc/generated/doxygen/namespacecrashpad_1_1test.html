<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crashpad: crashpad::test Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="crashpad_doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Crashpad
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacecrashpad_1_1test.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">crashpad::test Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The testing namespace, for use in test code only.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1BufferExtensionStreamDataSource.html">BufferExtensionStreamDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A user extension data source that wraps a buffer.  <a href="classcrashpad_1_1test_1_1BufferExtensionStreamDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ChildLauncher.html">ChildLauncher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a child process for testing. Uses Google Test <code>ASSERT_*</code> to indicate failure. The child's output is passed through a pipe and is available via <a class="el" href="classcrashpad_1_1test_1_1ChildLauncher.html#a3ed4b8859fa32e8f772e50afc19163ee" title="The read end of a pipe attached to the child&#39;s stdout.">stdout_read_handle()</a>, and the child's input is attached to a second pipe available via <a class="el" href="classcrashpad_1_1test_1_1ChildLauncher.html#afe9c94037f079ad475e6b0aab992c21f" title="The write end of a pipe attached to the child&#39;s stdin.">stdin_write_handle()</a>.  <a href="classcrashpad_1_1test_1_1ChildLauncher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ExceptionSwallower.html">ExceptionSwallower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swallows <code>EXC_CRASH</code> and <code>EXC_CORPSE_NOTIFY</code> exceptions in test child processes.  <a href="classcrashpad_1_1test_1_1ExceptionSwallower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1FakePtraceConnection.html">FakePtraceConnection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stands-in where real PtraceConnections aren't available.  <a href="classcrashpad_1_1test_1_1FakePtraceConnection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1InProcessIntermediateDumpHandler.html">InProcessIntermediateDumpHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump all in-process data to iOS intermediate dump. Note: All methods are <code>RUNS-DURING-CRASH</code>.  <a href="classcrashpad_1_1test_1_1InProcessIntermediateDumpHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1IOSIntermediateDumpWriter.html">IOSIntermediateDumpWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for writing intermediate dump file.  <a href="classcrashpad_1_1test_1_1IOSIntermediateDumpWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1MachMultiprocess.html">MachMultiprocess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a Mach-aware multiprocess test.  <a href="classcrashpad_1_1test_1_1MachMultiprocess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1MemorySnapshotIOSIntermediateDump.html">MemorySnapshotIOSIntermediateDump</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1MemorySnapshot.html" title="An abstract interface to a snapshot representing a region of memory present in a snapshot process.">MemorySnapshot</a> of a memory region.  <a href="classcrashpad_1_1test_1_1MemorySnapshotIOSIntermediateDump.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1test_1_1MinidumpWritableTraits.html">MinidumpWritableTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits class defining whether a minidump object type is required to appear only as a fixed-size object or if it is variable-sized.  <a href="structcrashpad_1_1test_1_1MinidumpWritableTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1Multiprocess.html">Multiprocess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a multiprocess test.  <a href="classcrashpad_1_1test_1_1Multiprocess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1MultiprocessExec.html">MultiprocessExec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages an <code>exec()</code>-based multiprocess test.  <a href="classcrashpad_1_1test_1_1MultiprocessExec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ProcessSnapshotIOSIntermediateDump.html">ProcessSnapshotIOSIntermediateDump</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a> of a running (or crashed) process running on a iphoneOS system.  <a href="classcrashpad_1_1test_1_1ProcessSnapshotIOSIntermediateDump.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ScopedGuardedPage.html">ScopedGuardedPage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAII object that allocates a read-write page with an inacessible page following it.  <a href="classcrashpad_1_1test_1_1ScopedGuardedPage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ScopedModuleHandle.html">ScopedModuleHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains ownership of a loadable module handle, releasing it as appropriate on destruction.  <a href="classcrashpad_1_1test_1_1ScopedModuleHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ScopedSetThreadName.html">ScopedSetThreadName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the current thread for the lifetime of this object.  <a href="classcrashpad_1_1test_1_1ScopedSetThreadName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ScopedTempDir.html">ScopedTempDir</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAII object that creates a temporary directory for testing.  <a href="classcrashpad_1_1test_1_1ScopedTempDir.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestExceptionSnapshot.html">TestExceptionSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ExceptionSnapshot.html" title="An abstract interface to a snapshot representing an exception that a snapshot process sustained and t...">ExceptionSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestExceptionSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestMemoryMapRegionSnapshot.html">TestMemoryMapRegionSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1MemoryMapRegionSnapshot.html" title="An abstract interface to a snapshot representing a region of the memory map present in the snapshot p...">MemoryMapRegionSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestMemoryMapRegionSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestMemorySnapshot.html">TestMemorySnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1MemorySnapshot.html" title="An abstract interface to a snapshot representing a region of memory present in a snapshot process.">MemorySnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestMemorySnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html">TestMinidumpMemoryWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1SnapshotMinidumpMemoryWriter.html" title="The base class for writers of memory ranges pointed to by MINIDUMP_MEMORY_DESCRIPTOR objects in a min...">SnapshotMinidumpMemoryWriter</a> implementation used for testing.  <a href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestModuleSnapshot.html">TestModuleSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ModuleSnapshot.html" title="An abstract interface to a snapshot representing a code module (binary image) loaded into a snapshot ...">ModuleSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestModuleSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestOutputStream.html">TestOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The help class for <em class="arg">OutputStreamInterface</em> related tests.  <a href="classcrashpad_1_1test_1_1TestOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestPaths.html">TestPaths</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to obtain paths from within tests.  <a href="classcrashpad_1_1test_1_1TestPaths.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestProcessSnapshot.html">TestProcessSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process.">ProcessSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestProcessSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestSystemSnapshot.html">TestSystemSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1SystemSnapshot.html" title="An abstract interface to a snapshot representing the state of a system, comprising an operating syste...">SystemSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestSystemSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestThreadSnapshot.html">TestThreadSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ThreadSnapshot.html" title="An abstract interface to a snapshot representing a thread (lightweight process) present in a snapshot...">ThreadSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestThreadSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestUInt32MinidumpWritable.html">TestUInt32MinidumpWritable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classcrashpad_1_1internal_1_1MinidumpWritable.html" title="The base class for all content that might be written to a minidump file.">internal::MinidumpWritable</a> that carries a <code>uint32_t</code> for testing.  <a href="classcrashpad_1_1test_1_1TestUInt32MinidumpWritable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1WinChildProcess.html">WinChildProcess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates the launching of child processes from unit tests.  <a href="classcrashpad_1_1test_1_1WinChildProcess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1WinMultiprocess.html">WinMultiprocess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a multiprocess test on Windows.  <a href="classcrashpad_1_1test_1_1WinMultiprocess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1WinMultiprocessWithTempDir.html">WinMultiprocessWithTempDir</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a multiprocess test on Windows with a parent-created temporary directory.  <a href="classcrashpad_1_1test_1_1WinMultiprocessWithTempDir.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae6aff46b9fa19a1664a0d5fd2c2f26f7" id="r_ae6aff46b9fa19a1664a0d5fd2c2f26f7"><td class="memItemLeft" align="right" valign="top"><a id="ae6aff46b9fa19a1664a0d5fd2c2f26f7" name="ae6aff46b9fa19a1664a0d5fd2c2f26f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ReturnCodeType</b> = int</td></tr>
<tr class="separator:ae6aff46b9fa19a1664a0d5fd2c2f26f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5591ba02262c4dcbcf029770028d399d" id="r_a5591ba02262c4dcbcf029770028d399d"><td class="memItemLeft" align="right" valign="top"><a id="a5591ba02262c4dcbcf029770028d399d" name="a5591ba02262c4dcbcf029770028d399d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessType</b> = pid_t</td></tr>
<tr class="memdesc:a5591ba02262c4dcbcf029770028d399d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for platform-specific type to represent a process. <br /></td></tr>
<tr class="separator:a5591ba02262c4dcbcf029770028d399d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a792154d99d868c18ba566d01d20be2cc" id="r_a792154d99d868c18ba566d01d20be2cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a792154d99d868c18ba566d01d20be2cc">MinidumpByteArrayAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a792154d99d868c18ba566d01d20be2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bytes referenced by a <a class="el" href="structcrashpad_1_1MinidumpByteArray.html" title="A variable-length array of bytes carried within a minidump file. The data have no intrinsic type and ...">MinidumpByteArray</a> object located in a minidump file at the specified <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8" title="An offset within a minidump file, relative to the start of its MINIDUMP_HEADER.">RVA</a>.  <br /></td></tr>
<tr class="separator:a792154d99d868c18ba566d01d20be2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb795649eae454aec13f03b7c20a4c2d" id="r_abb795649eae454aec13f03b7c20a4c2d"><td class="memItemLeft" align="right" valign="top"><a id="abb795649eae454aec13f03b7c20a4c2d" name="abb795649eae454aec13f03b7c20a4c2d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeMinidumpContextMIPS64</b> (<a class="el" href="structcrashpad_1_1MinidumpContextMIPS64.html">MinidumpContextMIPS64</a> *context, uint32_t seed)</td></tr>
<tr class="separator:abb795649eae454aec13f03b7c20a4c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bb97f184e9e5a41356a960fdaf3320" id="r_a68bb97f184e9e5a41356a960fdaf3320"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68bb97f184e9e5a41356a960fdaf3320">MinidumpHeaderAtStart</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__DIRECTORY.html">MINIDUMP_DIRECTORY</a> **directory)</td></tr>
<tr class="memdesc:a68bb97f184e9e5a41356a960fdaf3320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file.">MINIDUMP_HEADER</a> at the start of a minidump file, along with the <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file.">MINIDUMP_DIRECTORY</a> it references.  <br /></td></tr>
<tr class="separator:a68bb97f184e9e5a41356a960fdaf3320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e604ee6a23070a89e2a0015eb2854a9" id="r_a5e604ee6a23070a89e2a0015eb2854a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e604ee6a23070a89e2a0015eb2854a9">VerifyMinidumpHeader</a> (const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *header, uint32_t streams, uint32_t timestamp)</td></tr>
<tr class="memdesc:a5e604ee6a23070a89e2a0015eb2854a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file.">MINIDUMP_HEADER</a> contains expected values.  <br /></td></tr>
<tr class="separator:a5e604ee6a23070a89e2a0015eb2854a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d907f190db31282e6c8a08df38f7f3f" id="r_a5d907f190db31282e6c8a08df38f7f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d907f190db31282e6c8a08df38f7f3f">ExpectMinidumpMemoryDescriptor</a> (const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *expected, const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *observed)</td></tr>
<tr class="memdesc:a5d907f190db31282e6c8a08df38f7f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values.  <br /></td></tr>
<tr class="separator:a5d907f190db31282e6c8a08df38f7f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcb7b725b62a0058c18e0851a1adf5c" id="r_a7bcb7b725b62a0058c18e0851a1adf5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bcb7b725b62a0058c18e0851a1adf5c">ExpectMinidumpMemoryDescriptorAndContents</a> (const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *expected, const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *observed, const std::string &amp;file_contents, uint8_t value, bool at_eof)</td></tr>
<tr class="memdesc:a7bcb7b725b62a0058c18e0851a1adf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values, and that the memory region it points to contains expected values assuming it was written by a <a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html" title="A SnapshotMinidumpMemoryWriter implementation used for testing.">TestMinidumpMemoryWriter</a> object.  <br /></td></tr>
<tr class="separator:a7bcb7b725b62a0058c18e0851a1adf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3936c22f43c2defcaa16e7c09ce544" id="r_a1a3936c22f43c2defcaa16e7c09ce544"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpRVAList.html">MinidumpRVAList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a3936c22f43c2defcaa16e7c09ce544">MinidumpRVAListAtStart</a> (const std::string &amp;file_contents, size_t count)</td></tr>
<tr class="memdesc:a1a3936c22f43c2defcaa16e7c09ce544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structcrashpad_1_1MinidumpRVAList.html" title="A list of RVA pointers.">MinidumpRVAList</a> at the start of a minidump file.  <br /></td></tr>
<tr class="separator:a1a3936c22f43c2defcaa16e7c09ce544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527731a826e40dd36ac112e7cd3dfcd2" id="r_a527731a826e40dd36ac112e7cd3dfcd2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a527731a826e40dd36ac112e7cd3dfcd2">MinidumpStringAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a527731a826e40dd36ac112e7cd3dfcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file.">MINIDUMP_STRING</a> located within a minidump file’s contents.  <br /></td></tr>
<tr class="separator:a527731a826e40dd36ac112e7cd3dfcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0469cc2de268bc9218d17a4f5135935f" id="r_a0469cc2de268bc9218d17a4f5135935f"><td class="memItemLeft" align="right" valign="top"><a id="a0469cc2de268bc9218d17a4f5135935f" name="a0469cc2de268bc9218d17a4f5135935f"></a>
const <a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>MinidumpStringAtRVA</b> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#a18e623b3f5dac42b87070281dda7b26b">RVA64</a> rva)</td></tr>
<tr class="memdesc:a0469cc2de268bc9218d17a4f5135935f"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit specialization of MinidumpStringAtRVA. <br /></td></tr>
<tr class="separator:a0469cc2de268bc9218d17a4f5135935f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5bbb381b32ca4c5276a5aacbef1c5f" id="r_a9f5bbb381b32ca4c5276a5aacbef1c5f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html">MinidumpUTF8String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f5bbb381b32ca4c5276a5aacbef1c5f">MinidumpUTF8StringAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a9f5bbb381b32ca4c5276a5aacbef1c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file.">MinidumpUTF8String</a> located within a minidump file’s contents.  <br /></td></tr>
<tr class="separator:a9f5bbb381b32ca4c5276a5aacbef1c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb071a607a23f0e4a99f2328edc997be" id="r_abb071a607a23f0e4a99f2328edc997be"><td class="memItemLeft" align="right" valign="top"><a id="abb071a607a23f0e4a99f2328edc997be" name="abb071a607a23f0e4a99f2328edc997be"></a>
const <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html">MinidumpUTF8String</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>MinidumpUTF8StringAtRVA</b> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#a18e623b3f5dac42b87070281dda7b26b">RVA64</a> rva)</td></tr>
<tr class="memdesc:abb071a607a23f0e4a99f2328edc997be"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit specialization of MinidumpUTF8StringAtRVA. <br /></td></tr>
<tr class="separator:abb071a607a23f0e4a99f2328edc997be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5777a4692213162a65910c17778a2c29" id="r_a5777a4692213162a65910c17778a2c29"><td class="memItemLeft" align="right" valign="top">std::u16string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5777a4692213162a65910c17778a2c29">MinidumpStringAtRVAAsString</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a5777a4692213162a65910c17778a2c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file.">MINIDUMP_STRING</a> as a <code>std::u16string</code>.  <br /></td></tr>
<tr class="separator:a5777a4692213162a65910c17778a2c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b82622b84c15151273189e104713b3" id="r_a36b82622b84c15151273189e104713b3"><td class="memItemLeft" align="right" valign="top"><a id="a36b82622b84c15151273189e104713b3" name="a36b82622b84c15151273189e104713b3"></a>
std::u16string&#160;</td><td class="memItemRight" valign="bottom"><b>MinidumpStringAtRVAAsString</b> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#a18e623b3f5dac42b87070281dda7b26b">RVA64</a> rva)</td></tr>
<tr class="memdesc:a36b82622b84c15151273189e104713b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit specialization of MinidumpStringAtRVAAsString. <br /></td></tr>
<tr class="separator:a36b82622b84c15151273189e104713b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8f1de3f021881b6464a1fedbddf956" id="r_a4d8f1de3f021881b6464a1fedbddf956"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d8f1de3f021881b6464a1fedbddf956">MinidumpUTF8StringAtRVAAsString</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a4d8f1de3f021881b6464a1fedbddf956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file.">MinidumpUTF8String</a> as a <code>std::string</code>.  <br /></td></tr>
<tr class="separator:a4d8f1de3f021881b6464a1fedbddf956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0d7a413f0beb53f6ba96485a4470fa" id="r_a9c0d7a413f0beb53f6ba96485a4470fa"><td class="memItemLeft" align="right" valign="top"><a id="a9c0d7a413f0beb53f6ba96485a4470fa" name="a9c0d7a413f0beb53f6ba96485a4470fa"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>MinidumpUTF8StringAtRVAAsString</b> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#a18e623b3f5dac42b87070281dda7b26b">RVA64</a> rva)</td></tr>
<tr class="memdesc:a9c0d7a413f0beb53f6ba96485a4470fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit specialization of MinidumpUTF8StringAtRVAAsString. <br /></td></tr>
<tr class="separator:a9c0d7a413f0beb53f6ba96485a4470fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbb750966dcd4d580ba9eeb51a45fc6" id="r_a5cbb750966dcd4d580ba9eeb51a45fc6"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cbb750966dcd4d580ba9eeb51a45fc6">MinidumpWritableAtLocationDescriptorInternal</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location, size_t expected_size, bool allow_oversized_data)</td></tr>
<tr class="memdesc:a5cbb750966dcd4d580ba9eeb51a45fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an untyped minidump object located within a minidump file’s contents, where the offset and size of the object are known.  <br /></td></tr>
<tr class="separator:a5cbb750966dcd4d580ba9eeb51a45fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a95d2d96b45fc476d983a0c2c3b8ab9" id="r_a5a95d2d96b45fc476d983a0c2c3b8ab9"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a95d2d96b45fc476d983a0c2c3b8ab9">MinidumpWritableAtLocationDescriptorInternal</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR64.html">MINIDUMP_LOCATION_DESCRIPTOR64</a> &amp;location, size_t expected_size, bool allow_oversized_data)</td></tr>
<tr class="memdesc:a5a95d2d96b45fc476d983a0c2c3b8ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit specialization of MinidumpWritableAtLocationDescriptorInternal.  <br /></td></tr>
<tr class="separator:a5a95d2d96b45fc476d983a0c2c3b8ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbef5521fa7d72b22f11af5fb6c46c8b" id="r_acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memItemLeft" align="right" valign="top"><a id="acbef5521fa7d72b22f11af5fb6c46c8b" name="acbef5521fa7d72b22f11af5fb6c46c8b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structIMAGE__DEBUG__MISC.html">IMAGE_DEBUG_MISC</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; IMAGE_DEBUG_MISC &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfd6e9d9034ac4eb0fa4a81d5d24f47" id="r_a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memItemLeft" align="right" valign="top"><a id="a3cfd6e9d9034ac4eb0fa4a81d5d24f47" name="a3cfd6e9d9034ac4eb0fa4a81d5d24f47"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_HEADER &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01134f431c0e023b0c28b1b11884d0e" id="r_af01134f431c0e023b0c28b1b11884d0e"><td class="memItemLeft" align="right" valign="top"><a id="af01134f431c0e023b0c28b1b11884d0e" name="af01134f431c0e023b0c28b1b11884d0e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af01134f431c0e023b0c28b1b11884d0e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MEMORY__LIST.html">MINIDUMP_MEMORY_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MEMORY_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:af01134f431c0e023b0c28b1b11884d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4fb44a0fd839f5c5741163cf55e5c4" id="r_a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memItemLeft" align="right" valign="top"><a id="a2e4fb44a0fd839f5c5741163cf55e5c4" name="a2e4fb44a0fd839f5c5741163cf55e5c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MODULE__LIST.html">MINIDUMP_MODULE_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MODULE_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed533501df3f4de4fa2665ca6b63239" id="r_a6ed533501df3f4de4fa2665ca6b63239"><td class="memItemLeft" align="right" valign="top"><a id="a6ed533501df3f4de4fa2665ca6b63239" name="a6ed533501df3f4de4fa2665ca6b63239"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6ed533501df3f4de4fa2665ca6b63239"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__UNLOADED__MODULE__LIST.html">MINIDUMP_UNLOADED_MODULE_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_UNLOADED_MODULE_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a6ed533501df3f4de4fa2665ca6b63239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ac3245d9630d709dda9d852bbb3594" id="r_af5ac3245d9630d709dda9d852bbb3594"><td class="memItemLeft" align="right" valign="top"><a id="af5ac3245d9630d709dda9d852bbb3594" name="af5ac3245d9630d709dda9d852bbb3594"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af5ac3245d9630d709dda9d852bbb3594"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__THREAD__LIST.html">MINIDUMP_THREAD_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_THREAD_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:af5ac3245d9630d709dda9d852bbb3594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707a558fc489c1f708c58a0211a65cbc" id="r_a707a558fc489c1f708c58a0211a65cbc"><td class="memItemLeft" align="right" valign="top"><a id="a707a558fc489c1f708c58a0211a65cbc" name="a707a558fc489c1f708c58a0211a65cbc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a707a558fc489c1f708c58a0211a65cbc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__THREAD__NAME__LIST.html">MINIDUMP_THREAD_NAME_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_THREAD_NAME_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a707a558fc489c1f708c58a0211a65cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0853a876c74f56925c9fed57df1d4e4" id="r_ae0853a876c74f56925c9fed57df1d4e4"><td class="memItemLeft" align="right" valign="top"><a id="ae0853a876c74f56925c9fed57df1d4e4" name="ae0853a876c74f56925c9fed57df1d4e4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae0853a876c74f56925c9fed57df1d4e4"><td class="memTemplItemLeft" align="right" valign="top">const MINIDUMP_HANDLE_DATA_STREAM *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_HANDLE_DATA_STREAM &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae0853a876c74f56925c9fed57df1d4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01e66114473dfd8bb2d3f57af86a09e" id="r_ae01e66114473dfd8bb2d3f57af86a09e"><td class="memItemLeft" align="right" valign="top"><a id="ae01e66114473dfd8bb2d3f57af86a09e" name="ae01e66114473dfd8bb2d3f57af86a09e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae01e66114473dfd8bb2d3f57af86a09e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MEMORY__INFO__LIST.html">MINIDUMP_MEMORY_INFO_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MEMORY_INFO_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae01e66114473dfd8bb2d3f57af86a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ca9502c6765e74527d0a890588aabf" id="r_ae1ca9502c6765e74527d0a890588aabf"><td class="memItemLeft" align="right" valign="top"><a id="ae1ca9502c6765e74527d0a890588aabf" name="ae1ca9502c6765e74527d0a890588aabf"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae1ca9502c6765e74527d0a890588aabf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfoList.html">MinidumpModuleCrashpadInfoList</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpModuleCrashpadInfoList &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae1ca9502c6765e74527d0a890588aabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69ddf4143c3bf004ae589fd7566f88" id="r_a7e69ddf4143c3bf004ae589fd7566f88"><td class="memItemLeft" align="right" valign="top"><a id="a7e69ddf4143c3bf004ae589fd7566f88" name="a7e69ddf4143c3bf004ae589fd7566f88"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionary.html">MinidumpSimpleStringDictionary</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpSimpleStringDictionary &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea90e0adf08a1a750d42deadacc86ba" id="r_aeea90e0adf08a1a750d42deadacc86ba"><td class="memItemLeft" align="right" valign="top"><a id="aeea90e0adf08a1a750d42deadacc86ba" name="aeea90e0adf08a1a750d42deadacc86ba"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aeea90e0adf08a1a750d42deadacc86ba"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpAnnotationList.html">MinidumpAnnotationList</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpAnnotationList &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:aeea90e0adf08a1a750d42deadacc86ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ec9d484542a9381da429f311f4e301" id="r_ad9ec9d484542a9381da429f311f4e301"><td class="memItemLeft" align="right" valign="top"><a id="ad9ec9d484542a9381da429f311f4e301" name="ad9ec9d484542a9381da429f311f4e301"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad9ec9d484542a9381da429f311f4e301"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1CodeViewRecordPDB20.html">CodeViewRecordPDB20</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; CodeViewRecordPDB20 &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ad9ec9d484542a9381da429f311f4e301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0da61d4589262d25b6955d93378176" id="r_a5d0da61d4589262d25b6955d93378176"><td class="memItemLeft" align="right" valign="top"><a id="a5d0da61d4589262d25b6955d93378176" name="a5d0da61d4589262d25b6955d93378176"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5d0da61d4589262d25b6955d93378176"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1CodeViewRecordPDB70.html">CodeViewRecordPDB70</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; CodeViewRecordPDB70 &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a5d0da61d4589262d25b6955d93378176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6caef1521261ad46438f7fd04eac92" id="r_abd6caef1521261ad46438f7fd04eac92"><td class="memItemLeft" align="right" valign="top"><a id="abd6caef1521261ad46438f7fd04eac92" name="abd6caef1521261ad46438f7fd04eac92"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abd6caef1521261ad46438f7fd04eac92"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1CodeViewRecordBuildID.html">CodeViewRecordBuildID</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; CodeViewRecordBuildID &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:abd6caef1521261ad46438f7fd04eac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74140dac921a98cd307aa9935e3d114b" id="r_a74140dac921a98cd307aa9935e3d114b"><td class="memItemLeft" align="right" valign="top"><a id="a74140dac921a98cd307aa9935e3d114b" name="a74140dac921a98cd307aa9935e3d114b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__DIRECTORY.html">MINIDUMP_DIRECTORY</a>)</td></tr>
<tr class="separator:a74140dac921a98cd307aa9935e3d114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d55335cfc826aa10bcca7e5bafbe9d9" id="r_a4d55335cfc826aa10bcca7e5bafbe9d9"><td class="memItemLeft" align="right" valign="top"><a id="a4d55335cfc826aa10bcca7e5bafbe9d9" name="a4d55335cfc826aa10bcca7e5bafbe9d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__MEMORY__LIST.html">MINIDUMP_MEMORY_LIST</a>)</td></tr>
<tr class="separator:a4d55335cfc826aa10bcca7e5bafbe9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d1f4c122b7e84f7a7cc47631689fd8" id="r_a90d1f4c122b7e84f7a7cc47631689fd8"><td class="memItemLeft" align="right" valign="top"><a id="a90d1f4c122b7e84f7a7cc47631689fd8" name="a90d1f4c122b7e84f7a7cc47631689fd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__MODULE__LIST.html">MINIDUMP_MODULE_LIST</a>)</td></tr>
<tr class="separator:a90d1f4c122b7e84f7a7cc47631689fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5764e8ed7252404256e868016da139eb" id="r_a5764e8ed7252404256e868016da139eb"><td class="memItemLeft" align="right" valign="top"><a id="a5764e8ed7252404256e868016da139eb" name="a5764e8ed7252404256e868016da139eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__UNLOADED__MODULE__LIST.html">MINIDUMP_UNLOADED_MODULE_LIST</a>)</td></tr>
<tr class="separator:a5764e8ed7252404256e868016da139eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b5b9ccf411a827569d2ef7705203a4" id="r_a62b5b9ccf411a827569d2ef7705203a4"><td class="memItemLeft" align="right" valign="top"><a id="a62b5b9ccf411a827569d2ef7705203a4" name="a62b5b9ccf411a827569d2ef7705203a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__THREAD__LIST.html">MINIDUMP_THREAD_LIST</a>)</td></tr>
<tr class="separator:a62b5b9ccf411a827569d2ef7705203a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64ff2e6965116aac57b9c35eeb1c0b8" id="r_ae64ff2e6965116aac57b9c35eeb1c0b8"><td class="memItemLeft" align="right" valign="top"><a id="ae64ff2e6965116aac57b9c35eeb1c0b8" name="ae64ff2e6965116aac57b9c35eeb1c0b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__THREAD__NAME__LIST.html">MINIDUMP_THREAD_NAME_LIST</a>)</td></tr>
<tr class="separator:ae64ff2e6965116aac57b9c35eeb1c0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d3876a55220aed734c961912e2593f" id="r_ab3d3876a55220aed734c961912e2593f"><td class="memItemLeft" align="right" valign="top"><a id="ab3d3876a55220aed734c961912e2593f" name="ab3d3876a55220aed734c961912e2593f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (MINIDUMP_HANDLE_DATA_STREAM)</td></tr>
<tr class="separator:ab3d3876a55220aed734c961912e2593f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d20ce36664c4dc9929153da348f45a" id="r_ad4d20ce36664c4dc9929153da348f45a"><td class="memItemLeft" align="right" valign="top"><a id="ad4d20ce36664c4dc9929153da348f45a" name="ad4d20ce36664c4dc9929153da348f45a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__MEMORY__INFO__LIST.html">MINIDUMP_MEMORY_INFO_LIST</a>)</td></tr>
<tr class="separator:ad4d20ce36664c4dc9929153da348f45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a5769138fd33b721795773deea6ce" id="r_a7b1a5769138fd33b721795773deea6ce"><td class="memItemLeft" align="right" valign="top"><a id="a7b1a5769138fd33b721795773deea6ce" name="a7b1a5769138fd33b721795773deea6ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfoList.html">MinidumpModuleCrashpadInfoList</a>)</td></tr>
<tr class="separator:a7b1a5769138fd33b721795773deea6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615edb0cc10ae7de6b93d020cf0bfaf4" id="r_a615edb0cc10ae7de6b93d020cf0bfaf4"><td class="memItemLeft" align="right" valign="top"><a id="a615edb0cc10ae7de6b93d020cf0bfaf4" name="a615edb0cc10ae7de6b93d020cf0bfaf4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpRVAList.html">MinidumpRVAList</a>)</td></tr>
<tr class="separator:a615edb0cc10ae7de6b93d020cf0bfaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302566ec2aa6e6771db3b4be4e6aa682" id="r_a302566ec2aa6e6771db3b4be4e6aa682"><td class="memItemLeft" align="right" valign="top"><a id="a302566ec2aa6e6771db3b4be4e6aa682" name="a302566ec2aa6e6771db3b4be4e6aa682"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionary.html">MinidumpSimpleStringDictionary</a>)</td></tr>
<tr class="separator:a302566ec2aa6e6771db3b4be4e6aa682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ea15cc2785d5b80624299a47e9ae50" id="r_a28ea15cc2785d5b80624299a47e9ae50"><td class="memItemLeft" align="right" valign="top"><a id="a28ea15cc2785d5b80624299a47e9ae50" name="a28ea15cc2785d5b80624299a47e9ae50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpAnnotationList.html">MinidumpAnnotationList</a>)</td></tr>
<tr class="separator:a28ea15cc2785d5b80624299a47e9ae50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e90afb7c78eafed9eda8485265ae16a" id="r_a2e90afb7c78eafed9eda8485265ae16a"><td class="memItemLeft" align="right" valign="top"><a id="a2e90afb7c78eafed9eda8485265ae16a" name="a2e90afb7c78eafed9eda8485265ae16a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structIMAGE__DEBUG__MISC.html">IMAGE_DEBUG_MISC</a>)</td></tr>
<tr class="separator:a2e90afb7c78eafed9eda8485265ae16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690a621b0359475ed37034c4e75f26b0" id="r_a690a621b0359475ed37034c4e75f26b0"><td class="memItemLeft" align="right" valign="top"><a id="a690a621b0359475ed37034c4e75f26b0" name="a690a621b0359475ed37034c4e75f26b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a>)</td></tr>
<tr class="separator:a690a621b0359475ed37034c4e75f26b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2227fbf02e47435f050101570bf0f7ba" id="r_a2227fbf02e47435f050101570bf0f7ba"><td class="memItemLeft" align="right" valign="top"><a id="a2227fbf02e47435f050101570bf0f7ba" name="a2227fbf02e47435f050101570bf0f7ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1CodeViewRecordPDB20.html">CodeViewRecordPDB20</a>)</td></tr>
<tr class="separator:a2227fbf02e47435f050101570bf0f7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c365f95d8aa537d13f617dfc13991c3" id="r_a9c365f95d8aa537d13f617dfc13991c3"><td class="memItemLeft" align="right" valign="top"><a id="a9c365f95d8aa537d13f617dfc13991c3" name="a9c365f95d8aa537d13f617dfc13991c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1CodeViewRecordPDB70.html">CodeViewRecordPDB70</a>)</td></tr>
<tr class="separator:a9c365f95d8aa537d13f617dfc13991c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d505d092b1326ac7b0d56d8e6905d0" id="r_a28d505d092b1326ac7b0d56d8e6905d0"><td class="memItemLeft" align="right" valign="top"><a id="a28d505d092b1326ac7b0d56d8e6905d0" name="a28d505d092b1326ac7b0d56d8e6905d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1CodeViewRecordBuildID.html">CodeViewRecordBuildID</a>)</td></tr>
<tr class="separator:a28d505d092b1326ac7b0d56d8e6905d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61f5e906dff25a41c015dbcf02a8cff" id="r_af61f5e906dff25a41c015dbcf02a8cff"><td class="memItemLeft" align="right" valign="top"><a id="af61f5e906dff25a41c015dbcf02a8cff" name="af61f5e906dff25a41c015dbcf02a8cff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpUTF8String.html">MinidumpUTF8String</a>)</td></tr>
<tr class="separator:af61f5e906dff25a41c015dbcf02a8cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4ed41a7f2c94d294e1c1bca34a3e15" id="r_a7b4ed41a7f2c94d294e1c1bca34a3e15"><td class="memItemLeft" align="right" valign="top"><a id="a7b4ed41a7f2c94d294e1c1bca34a3e15" name="a7b4ed41a7f2c94d294e1c1bca34a3e15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (uint8_t)</td></tr>
<tr class="separator:a7b4ed41a7f2c94d294e1c1bca34a3e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed432a39ba3d9fa96dc3a131c9119c40" id="r_aed432a39ba3d9fa96dc3a131c9119c40"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aed432a39ba3d9fa96dc3a131c9119c40"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed432a39ba3d9fa96dc3a131c9119c40">TMinidumpWritableAtLocationDescriptor</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="memdesc:aed432a39ba3d9fa96dc3a131c9119c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known.  <br /></td></tr>
<tr class="separator:aed432a39ba3d9fa96dc3a131c9119c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d28a5554a694aec7d8dc0fb6c49276" id="r_a76d28a5554a694aec7d8dc0fb6c49276"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a76d28a5554a694aec7d8dc0fb6c49276"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76d28a5554a694aec7d8dc0fb6c49276">TMinidumpWritableAtLocationDescriptor</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR64.html">MINIDUMP_LOCATION_DESCRIPTOR64</a> &amp;location)</td></tr>
<tr class="memdesc:a76d28a5554a694aec7d8dc0fb6c49276"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit specialization of TMinidumpWritableAtLocationDescriptor.  <br /></td></tr>
<tr class="separator:a76d28a5554a694aec7d8dc0fb6c49276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a17a529d0d0e415a8290530e8797b9e" id="r_a6a17a529d0d0e415a8290530e8797b9e"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6a17a529d0d0e415a8290530e8797b9e"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a17a529d0d0e415a8290530e8797b9e">MinidumpWritableAtLocationDescriptor</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="memdesc:a6a17a529d0d0e415a8290530e8797b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known.  <br /></td></tr>
<tr class="separator:a6a17a529d0d0e415a8290530e8797b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1e8943fa1682214b7bb9c320fc3362" id="r_a4c1e8943fa1682214b7bb9c320fc3362"><td class="memTemplParams" colspan="2"><a id="a4c1e8943fa1682214b7bb9c320fc3362" name="a4c1e8943fa1682214b7bb9c320fc3362"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a4c1e8943fa1682214b7bb9c320fc3362"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR64.html">MINIDUMP_LOCATION_DESCRIPTOR64</a> &amp;location)</td></tr>
<tr class="memdesc:a4c1e8943fa1682214b7bb9c320fc3362"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit specialization of MinidumpWritableAtLocationDescriptor. <br /></td></tr>
<tr class="separator:a4c1e8943fa1682214b7bb9c320fc3362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbef5521fa7d72b22f11af5fb6c46c8b" id="r_acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memItemLeft" align="right" valign="top"><a id="acbef5521fa7d72b22f11af5fb6c46c8b" name="acbef5521fa7d72b22f11af5fb6c46c8b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structIMAGE__DEBUG__MISC.html">IMAGE_DEBUG_MISC</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; IMAGE_DEBUG_MISC &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfd6e9d9034ac4eb0fa4a81d5d24f47" id="r_a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memItemLeft" align="right" valign="top"><a id="a3cfd6e9d9034ac4eb0fa4a81d5d24f47" name="a3cfd6e9d9034ac4eb0fa4a81d5d24f47"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_HEADER &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01134f431c0e023b0c28b1b11884d0e" id="r_af01134f431c0e023b0c28b1b11884d0e"><td class="memItemLeft" align="right" valign="top"><a id="af01134f431c0e023b0c28b1b11884d0e" name="af01134f431c0e023b0c28b1b11884d0e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af01134f431c0e023b0c28b1b11884d0e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MEMORY__LIST.html">MINIDUMP_MEMORY_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MEMORY_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:af01134f431c0e023b0c28b1b11884d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4fb44a0fd839f5c5741163cf55e5c4" id="r_a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memItemLeft" align="right" valign="top"><a id="a2e4fb44a0fd839f5c5741163cf55e5c4" name="a2e4fb44a0fd839f5c5741163cf55e5c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MODULE__LIST.html">MINIDUMP_MODULE_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MODULE_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed533501df3f4de4fa2665ca6b63239" id="r_a6ed533501df3f4de4fa2665ca6b63239"><td class="memItemLeft" align="right" valign="top"><a id="a6ed533501df3f4de4fa2665ca6b63239" name="a6ed533501df3f4de4fa2665ca6b63239"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6ed533501df3f4de4fa2665ca6b63239"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__UNLOADED__MODULE__LIST.html">MINIDUMP_UNLOADED_MODULE_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_UNLOADED_MODULE_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a6ed533501df3f4de4fa2665ca6b63239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ac3245d9630d709dda9d852bbb3594" id="r_af5ac3245d9630d709dda9d852bbb3594"><td class="memItemLeft" align="right" valign="top"><a id="af5ac3245d9630d709dda9d852bbb3594" name="af5ac3245d9630d709dda9d852bbb3594"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af5ac3245d9630d709dda9d852bbb3594"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__THREAD__LIST.html">MINIDUMP_THREAD_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_THREAD_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:af5ac3245d9630d709dda9d852bbb3594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707a558fc489c1f708c58a0211a65cbc" id="r_a707a558fc489c1f708c58a0211a65cbc"><td class="memItemLeft" align="right" valign="top"><a id="a707a558fc489c1f708c58a0211a65cbc" name="a707a558fc489c1f708c58a0211a65cbc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a707a558fc489c1f708c58a0211a65cbc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__THREAD__NAME__LIST.html">MINIDUMP_THREAD_NAME_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_THREAD_NAME_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a707a558fc489c1f708c58a0211a65cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0853a876c74f56925c9fed57df1d4e4" id="r_ae0853a876c74f56925c9fed57df1d4e4"><td class="memItemLeft" align="right" valign="top"><a id="ae0853a876c74f56925c9fed57df1d4e4" name="ae0853a876c74f56925c9fed57df1d4e4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae0853a876c74f56925c9fed57df1d4e4"><td class="memTemplItemLeft" align="right" valign="top">const MINIDUMP_HANDLE_DATA_STREAM *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_HANDLE_DATA_STREAM &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae0853a876c74f56925c9fed57df1d4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01e66114473dfd8bb2d3f57af86a09e" id="r_ae01e66114473dfd8bb2d3f57af86a09e"><td class="memItemLeft" align="right" valign="top"><a id="ae01e66114473dfd8bb2d3f57af86a09e" name="ae01e66114473dfd8bb2d3f57af86a09e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae01e66114473dfd8bb2d3f57af86a09e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MEMORY__INFO__LIST.html">MINIDUMP_MEMORY_INFO_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MEMORY_INFO_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae01e66114473dfd8bb2d3f57af86a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ec9d484542a9381da429f311f4e301" id="r_ad9ec9d484542a9381da429f311f4e301"><td class="memItemLeft" align="right" valign="top"><a id="ad9ec9d484542a9381da429f311f4e301" name="ad9ec9d484542a9381da429f311f4e301"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad9ec9d484542a9381da429f311f4e301"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1CodeViewRecordPDB20.html">CodeViewRecordPDB20</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; CodeViewRecordPDB20 &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ad9ec9d484542a9381da429f311f4e301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0da61d4589262d25b6955d93378176" id="r_a5d0da61d4589262d25b6955d93378176"><td class="memItemLeft" align="right" valign="top"><a id="a5d0da61d4589262d25b6955d93378176" name="a5d0da61d4589262d25b6955d93378176"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5d0da61d4589262d25b6955d93378176"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1CodeViewRecordPDB70.html">CodeViewRecordPDB70</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; CodeViewRecordPDB70 &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a5d0da61d4589262d25b6955d93378176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6caef1521261ad46438f7fd04eac92" id="r_abd6caef1521261ad46438f7fd04eac92"><td class="memItemLeft" align="right" valign="top"><a id="abd6caef1521261ad46438f7fd04eac92" name="abd6caef1521261ad46438f7fd04eac92"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abd6caef1521261ad46438f7fd04eac92"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1CodeViewRecordBuildID.html">CodeViewRecordBuildID</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; CodeViewRecordBuildID &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:abd6caef1521261ad46438f7fd04eac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ca9502c6765e74527d0a890588aabf" id="r_ae1ca9502c6765e74527d0a890588aabf"><td class="memItemLeft" align="right" valign="top"><a id="ae1ca9502c6765e74527d0a890588aabf" name="ae1ca9502c6765e74527d0a890588aabf"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae1ca9502c6765e74527d0a890588aabf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpModuleCrashpadInfoList.html">MinidumpModuleCrashpadInfoList</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpModuleCrashpadInfoList &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae1ca9502c6765e74527d0a890588aabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69ddf4143c3bf004ae589fd7566f88" id="r_a7e69ddf4143c3bf004ae589fd7566f88"><td class="memItemLeft" align="right" valign="top"><a id="a7e69ddf4143c3bf004ae589fd7566f88" name="a7e69ddf4143c3bf004ae589fd7566f88"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionary.html">MinidumpSimpleStringDictionary</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpSimpleStringDictionary &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea90e0adf08a1a750d42deadacc86ba" id="r_aeea90e0adf08a1a750d42deadacc86ba"><td class="memItemLeft" align="right" valign="top"><a id="aeea90e0adf08a1a750d42deadacc86ba" name="aeea90e0adf08a1a750d42deadacc86ba"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aeea90e0adf08a1a750d42deadacc86ba"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpAnnotationList.html">MinidumpAnnotationList</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpAnnotationList &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:aeea90e0adf08a1a750d42deadacc86ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef56904dc505d92e539a949ed5a3621f" id="r_aef56904dc505d92e539a949ed5a3621f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aef56904dc505d92e539a949ed5a3621f"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef56904dc505d92e539a949ed5a3621f">MinidumpWritableAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:aef56904dc505d92e539a949ed5a3621f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typed minidump object located within a minidump file’s contents, where the offset of the object is known.  <br /></td></tr>
<tr class="separator:aef56904dc505d92e539a949ed5a3621f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b4113a166a5404854179f244073a42" id="r_a49b4113a166a5404854179f244073a42"><td class="memTemplParams" colspan="2"><a id="a49b4113a166a5404854179f244073a42" name="a49b4113a166a5404854179f244073a42"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a49b4113a166a5404854179f244073a42"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtRVA</b> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#a18e623b3f5dac42b87070281dda7b26b">RVA64</a> rva)</td></tr>
<tr class="memdesc:a49b4113a166a5404854179f244073a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit specialization of MinidumpWritableAtRVA. <br /></td></tr>
<tr class="separator:a49b4113a166a5404854179f244073a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbba6ad3c0e7e503a9e45cb1a9ebf9f5" id="r_afbba6ad3c0e7e503a9e45cb1a9ebf9f5"><td class="memItemLeft" align="right" valign="top"><a id="afbba6ad3c0e7e503a9e45cb1a9ebf9f5" name="afbba6ad3c0e7e503a9e45cb1a9ebf9f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>WriteTestModule</b> (const base::FilePath &amp;module_path, const std::string &amp;soname)</td></tr>
<tr class="separator:afbba6ad3c0e7e503a9e45cb1a9ebf9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f42c5d290ec3dc2dbae82b56a806fac" id="r_a4f42c5d290ec3dc2dbae82b56a806fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcrashpad_1_1test_1_1ScopedModuleHandle.html">ScopedModuleHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f42c5d290ec3dc2dbae82b56a806fac">LoadTestModule</a> (const std::string &amp;module_name, const std::string &amp;module_soname)</td></tr>
<tr class="memdesc:a4f42c5d290ec3dc2dbae82b56a806fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and loads a test module.  <br /></td></tr>
<tr class="separator:a4f42c5d290ec3dc2dbae82b56a806fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9504862c089964763d7d362572c2ac6" id="r_ad9504862c089964763d7d362572c2ac6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9504862c089964763d7d362572c2ac6">ErrnoMessage</a> (int err, const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:ad9504862c089964763d7d362572c2ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message using an <code>errno</code> value.  <br /></td></tr>
<tr class="separator:ad9504862c089964763d7d362572c2ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8e66fbc47a4f22a03710797f226238" id="r_a8d8e66fbc47a4f22a03710797f226238"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d8e66fbc47a4f22a03710797f226238">ErrnoMessage</a> (const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a8d8e66fbc47a4f22a03710797f226238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message using <code>errno</code>.  <br /></td></tr>
<tr class="separator:a8d8e66fbc47a4f22a03710797f226238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d079e80aa56bc0840f1c0b944e01bfb" id="r_a2d079e80aa56bc0840f1c0b944e01bfb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d079e80aa56bc0840f1c0b944e01bfb">ErrorMessage</a> (const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a2d079e80aa56bc0840f1c0b944e01bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message using <code>GetLastError()</code>.  <br /></td></tr>
<tr class="separator:a2d079e80aa56bc0840f1c0b944e01bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cad311e386c21af1ca653f2aca2695b" id="r_a8cad311e386c21af1ca653f2aca2695b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cad311e386c21af1ca653f2aca2695b">FileExists</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:a8cad311e386c21af1ca653f2aca2695b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a file exists.  <br /></td></tr>
<tr class="separator:a8cad311e386c21af1ca653f2aca2695b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489b62007e6118a1addd46674ca4e474" id="r_a489b62007e6118a1addd46674ca4e474"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a489b62007e6118a1addd46674ca4e474">RemoveFileIfExists</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:a489b62007e6118a1addd46674ca4e474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a file if it exists, logging a message on failure.  <br /></td></tr>
<tr class="separator:a489b62007e6118a1addd46674ca4e474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897d99ec1dd2c343d29a3d14e3560732" id="r_a897d99ec1dd2c343d29a3d14e3560732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecrashpad.html#a73e870ea9156f1bfdff1b998a77cdd9e">FileOffset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a897d99ec1dd2c343d29a3d14e3560732">FileSize</a> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:a897d99ec1dd2c343d29a3d14e3560732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the size of a file.  <br /></td></tr>
<tr class="separator:a897d99ec1dd2c343d29a3d14e3560732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1635127f269cfa8d35e239a8c8f7f7d4" id="r_a1635127f269cfa8d35e239a8c8f7f7d4"><td class="memItemLeft" align="right" valign="top"><a id="a1635127f269cfa8d35e239a8c8f7f7d4" name="a1635127f269cfa8d35e239a8c8f7f7d4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CreateFile</b> (const base::FilePath &amp;filepath)</td></tr>
<tr class="memdesc:a1635127f269cfa8d35e239a8c8f7f7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty file at path <em class="arg">filepath</em>. <br /></td></tr>
<tr class="separator:a1635127f269cfa8d35e239a8c8f7f7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70be49b8df7a164ab2d8641f6bf88bef" id="r_a70be49b8df7a164ab2d8641f6bf88bef"><td class="memItemLeft" align="right" valign="top"><a id="a70be49b8df7a164ab2d8641f6bf88bef" name="a70be49b8df7a164ab2d8641f6bf88bef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>PathExists</b> (const base::FilePath &amp;path)</td></tr>
<tr class="memdesc:a70be49b8df7a164ab2d8641f6bf88bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if a filesystem node exists at path <em class="arg">path</em>. <br /></td></tr>
<tr class="separator:a70be49b8df7a164ab2d8641f6bf88bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e323579fb063cb426c2855bb73d33c" id="r_af7e323579fb063cb426c2855bb73d33c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7e323579fb063cb426c2855bb73d33c">SetFileModificationTime</a> (const base::FilePath &amp;path, const timespec &amp;mtime)</td></tr>
<tr class="memdesc:af7e323579fb063cb426c2855bb73d33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the modification time for a file, directory, or symbolic link.  <br /></td></tr>
<tr class="separator:af7e323579fb063cb426c2855bb73d33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9bc67b39f0b394ae33cc4fd36fc73d" id="r_a3a9bc67b39f0b394ae33cc4fd36fc73d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a9bc67b39f0b394ae33cc4fd36fc73d">CanCreateSymbolicLinks</a> ()</td></tr>
<tr class="memdesc:a3a9bc67b39f0b394ae33cc4fd36fc73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it should be possible to create symbolic links.  <br /></td></tr>
<tr class="separator:a3a9bc67b39f0b394ae33cc4fd36fc73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fb90bfe915d400207c2a370f93fcc1" id="r_ae3fb90bfe915d400207c2a370f93fcc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3fb90bfe915d400207c2a370f93fcc1">CreateSymbolicLink</a> (const base::FilePath &amp;target_path, const base::FilePath &amp;symlink_path)</td></tr>
<tr class="memdesc:ae3fb90bfe915d400207c2a370f93fcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new symbolic link.  <br /></td></tr>
<tr class="separator:ae3fb90bfe915d400207c2a370f93fcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4835fcb6a4a897b0841b8575789b77" id="r_aaa4835fcb6a4a897b0841b8575789b77"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa4835fcb6a4a897b0841b8575789b77">BytesToHexString</a> (const void *bytes, size_t length)</td></tr>
<tr class="memdesc:aaa4835fcb6a4a897b0841b8575789b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hexadecimal string corresponding to <em class="arg">bytes</em> and <em class="arg">length</em>.  <br /></td></tr>
<tr class="separator:aaa4835fcb6a4a897b0841b8575789b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dc6af450dc4cd4fa937c99665222f9" id="r_ac2dc6af450dc4cd4fa937c99665222f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2dc6af450dc4cd4fa937c99665222f9">IOSLaunchApplicationAndRunTests</a> (int argc, char *argv[])</td></tr>
<tr class="memdesc:ac2dc6af450dc4cd4fa937c99665222f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs all registered tests in the context of a UIKit application.  <br /></td></tr>
<tr class="separator:ac2dc6af450dc4cd4fa937c99665222f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3e9e43f844bb11aeea80c515bf94aa" id="r_a6a3e9e43f844bb11aeea80c515bf94aa"><td class="memItemLeft" align="right" valign="top"><a id="a6a3e9e43f844bb11aeea80c515bf94aa" name="a6a3e9e43f844bb11aeea80c515bf94aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceAllocatorsWithHandlerForbidden</b> ()</td></tr>
<tr class="separator:a6a3e9e43f844bb11aeea80c515bf94aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dd0773c6a29a2bd213336d6654e58d" id="r_ab5dd0773c6a29a2bd213336d6654e58d"><td class="memItemLeft" align="right" valign="top"><a id="ab5dd0773c6a29a2bd213336d6654e58d" name="ab5dd0773c6a29a2bd213336d6654e58d"></a>
<a class="el" href="namespacecrashpad.html#ac349d7ee7fdd6c312073c0e9d9af3db6">LinuxVMAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetTLS</b> ()</td></tr>
<tr class="memdesc:ab5dd0773c6a29a2bd213336d6654e58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread-local storage address for the current thread. <br /></td></tr>
<tr class="separator:ab5dd0773c6a29a2bd213336d6654e58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80403780da9c07617b44d8d7db7c618" id="r_ab80403780da9c07617b44d8d7db7c618"><td class="memItemLeft" align="right" valign="top">const dyld_all_image_infos *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab80403780da9c07617b44d8d7db7c618">DyldGetAllImageInfos</a> ()</td></tr>
<tr class="memdesc:ab80403780da9c07617b44d8d7db7c618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls or emulates the <code>_dyld_get_all_image_infos()</code> private/internal function.  <br /></td></tr>
<tr class="separator:ab80403780da9c07617b44d8d7db7c618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a7a2461cf4e1f674eac147c19d9483" id="r_a49a7a2461cf4e1f674eac147c19d9483"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49a7a2461cf4e1f674eac147c19d9483">MachErrorMessage</a> (mach_error_t mach_err, const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a49a7a2461cf4e1f674eac147c19d9483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a Mach error message.  <br /></td></tr>
<tr class="separator:a49a7a2461cf4e1f674eac147c19d9483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39568e00a9e49cda7938f6154b1264cf" id="r_a39568e00a9e49cda7938f6154b1264cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39568e00a9e49cda7938f6154b1264cf">InitializeMainArguments</a> (int argc, char *argv[])</td></tr>
<tr class="memdesc:a39568e00a9e49cda7938f6154b1264cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the arguments to <code>main()</code> for later use.  <br /></td></tr>
<tr class="separator:a39568e00a9e49cda7938f6154b1264cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f9df0a866217f549d350e196488558" id="r_a04f9df0a866217f549d350e196488558"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04f9df0a866217f549d350e196488558">GetMainArguments</a> ()</td></tr>
<tr class="memdesc:a04f9df0a866217f549d350e196488558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves pointers to the arguments to <code>main()</code>.  <br /></td></tr>
<tr class="separator:a04f9df0a866217f549d350e196488558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bab7cf5bb0010f068fbd2cbfd35874" id="r_a28bab7cf5bb0010f068fbd2cbfd35874"><td class="memItemLeft" align="right" valign="top"><a id="a28bab7cf5bb0010f068fbd2cbfd35874" name="a28bab7cf5bb0010f068fbd2cbfd35874"></a>
<a class="el" href="#a5591ba02262c4dcbcf029770028d399d">ProcessType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetSelfProcess</b> ()</td></tr>
<tr class="memdesc:a28bab7cf5bb0010f068fbd2cbfd35874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="#a5591ba02262c4dcbcf029770028d399d" title="Alias for platform-specific type to represent a process.">ProcessType</a> representing the current process. <br /></td></tr>
<tr class="separator:a28bab7cf5bb0010f068fbd2cbfd35874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603da2f249fd4491222cc8d1088c63f6" id="r_a603da2f249fd4491222cc8d1088c63f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a603da2f249fd4491222cc8d1088c63f6">SanityCheckContext</a> (const NativeCPUContext &amp;context)</td></tr>
<tr class="memdesc:a603da2f249fd4491222cc8d1088c63f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanity check conditions that should be true for any NativeCPUContext produced by <a class="el" href="namespacecrashpad.html#ac25486c6b4c38fc7c7868e978094edcf" title="Saves the CPU context.">CaptureContext()</a>.  <br /></td></tr>
<tr class="separator:a603da2f249fd4491222cc8d1088c63f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb08a3c9f2a02f5e20fc256266b9125" id="r_a5cb08a3c9f2a02f5e20fc256266b9125"><td class="memItemLeft" align="right" valign="top"><a id="a5cb08a3c9f2a02f5e20fc256266b9125" name="a5cb08a3c9f2a02f5e20fc256266b9125"></a>
uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><b>ProgramCounterFromContext</b> (const NativeCPUContext &amp;context)</td></tr>
<tr class="memdesc:a5cb08a3c9f2a02f5e20fc256266b9125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the program counter from a NativeCPUContext. <br /></td></tr>
<tr class="separator:a5cb08a3c9f2a02f5e20fc256266b9125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dfb1f9093f96eb9dfa17241f73de2e" id="r_a85dfb1f9093f96eb9dfa17241f73de2e"><td class="memItemLeft" align="right" valign="top"><a id="a85dfb1f9093f96eb9dfa17241f73de2e" name="a85dfb1f9093f96eb9dfa17241f73de2e"></a>
uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><b>StackPointerFromContext</b> (const NativeCPUContext &amp;context)</td></tr>
<tr class="memdesc:a85dfb1f9093f96eb9dfa17241f73de2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the stack pointer from a NativeCPUContext. <br /></td></tr>
<tr class="separator:a85dfb1f9093f96eb9dfa17241f73de2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35412b33d0a275fa43e8633296059534" id="r_a35412b33d0a275fa43e8633296059534"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35412b33d0a275fa43e8633296059534">ReadStreamToString</a> (<a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *stream)</td></tr>
<tr class="memdesc:a35412b33d0a275fa43e8633296059534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string.  <br /></td></tr>
<tr class="separator:a35412b33d0a275fa43e8633296059534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861ba97c72a60c7e1802c39395d1d1fe" id="r_a861ba97c72a60c7e1802c39395d1d1fe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a861ba97c72a60c7e1802c39395d1d1fe">ReadStreamToString</a> (<a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *stream, size_t buffer_size)</td></tr>
<tr class="memdesc:a861ba97c72a60c7e1802c39395d1d1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string.  <br /></td></tr>
<tr class="separator:a861ba97c72a60c7e1802c39395d1d1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afefac1494b6a67c50a254c75a8caccf1" id="r_afefac1494b6a67c50a254c75a8caccf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afefac1494b6a67c50a254c75a8caccf1">InitializeMinidumpContextX86</a> (<a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:afefac1494b6a67c50a254c75a8caccf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:afefac1494b6a67c50a254c75a8caccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1dd7166c73ca082608b1ab21b5a395" id="r_afa1dd7166c73ca082608b1ab21b5a395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa1dd7166c73ca082608b1ab21b5a395">InitializeMinidumpContextAMD64</a> (<a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html">MinidumpContextAMD64</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:afa1dd7166c73ca082608b1ab21b5a395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:afa1dd7166c73ca082608b1ab21b5a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2906dd1369f589786ada460e0675f1e1" id="r_a2906dd1369f589786ada460e0675f1e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2906dd1369f589786ada460e0675f1e1">InitializeMinidumpContextARM</a> (<a class="el" href="structcrashpad_1_1MinidumpContextARM.html">MinidumpContextARM</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a2906dd1369f589786ada460e0675f1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:a2906dd1369f589786ada460e0675f1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129b18c1aea376834602a7b249cd48fd" id="r_a129b18c1aea376834602a7b249cd48fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a129b18c1aea376834602a7b249cd48fd">InitializeMinidumpContextARM64</a> (<a class="el" href="structcrashpad_1_1MinidumpContextARM64.html">MinidumpContextARM64</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a129b18c1aea376834602a7b249cd48fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:a129b18c1aea376834602a7b249cd48fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e83478949a9c662428b5013f7745767" id="r_a4e83478949a9c662428b5013f7745767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e83478949a9c662428b5013f7745767">InitializeMinidumpContextMIPS</a> (<a class="el" href="structcrashpad_1_1MinidumpContextMIPS.html">MinidumpContextMIPS</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a4e83478949a9c662428b5013f7745767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:a4e83478949a9c662428b5013f7745767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4238891476dd3c0a88d838027080d081" id="r_a4238891476dd3c0a88d838027080d081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4238891476dd3c0a88d838027080d081">InitializeMinidumpContextRISCV64</a> (<a class="el" href="structcrashpad_1_1MinidumpContextRISCV64.html">MinidumpContextRISCV64</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a4238891476dd3c0a88d838027080d081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:a4238891476dd3c0a88d838027080d081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e7f1aab1bec394086f3bc88f6c3c1a" id="r_ae3e7f1aab1bec394086f3bc88f6c3c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3e7f1aab1bec394086f3bc88f6c3c1a">InitializeMinidumpContextMIPS64</a> (<a class="el" href="structcrashpad_1_1MinidumpContextMIPS.html">MinidumpContextMIPS</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:ae3e7f1aab1bec394086f3bc88f6c3c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:ae3e7f1aab1bec394086f3bc88f6c3c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a774c6adc6455eb01f0595262c1ce7df9" id="r_a774c6adc6455eb01f0595262c1ce7df9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a774c6adc6455eb01f0595262c1ce7df9">ExpectMinidumpContextX86</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:a774c6adc6455eb01f0595262c1ce7df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a context structure contains expected values.  <br /></td></tr>
<tr class="separator:a774c6adc6455eb01f0595262c1ce7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b85697010c624299be8ac6192cc3ed" id="r_ac5b85697010c624299be8ac6192cc3ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5b85697010c624299be8ac6192cc3ed">ExpectMinidumpContextAMD64</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html">MinidumpContextAMD64</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:ac5b85697010c624299be8ac6192cc3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a context structure contains expected values.  <br /></td></tr>
<tr class="separator:ac5b85697010c624299be8ac6192cc3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b4484ecca982bdc773e4b302f6b4a4" id="r_a64b4484ecca982bdc773e4b302f6b4a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64b4484ecca982bdc773e4b302f6b4a4">ExpectMinidumpContextARM</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextARM.html">MinidumpContextARM</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:a64b4484ecca982bdc773e4b302f6b4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a context structure contains expected values.  <br /></td></tr>
<tr class="separator:a64b4484ecca982bdc773e4b302f6b4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60df6310bda73150339e10aca2a52bbc" id="r_a60df6310bda73150339e10aca2a52bbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60df6310bda73150339e10aca2a52bbc">ExpectMinidumpContextARM64</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextARM64.html">MinidumpContextARM64</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:a60df6310bda73150339e10aca2a52bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a context structure contains expected values.  <br /></td></tr>
<tr class="separator:a60df6310bda73150339e10aca2a52bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562b93f75f01cc502822a7273265a5e4" id="r_a562b93f75f01cc502822a7273265a5e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a562b93f75f01cc502822a7273265a5e4">ExpectMinidumpContextMIPS</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextMIPS.html">MinidumpContextMIPS</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:a562b93f75f01cc502822a7273265a5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a context structure contains expected values.  <br /></td></tr>
<tr class="separator:a562b93f75f01cc502822a7273265a5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a60bac7e9f929110e53e544769b1a8d" id="r_a4a60bac7e9f929110e53e544769b1a8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a60bac7e9f929110e53e544769b1a8d">ExpectMinidumpContextMIPS64</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextMIPS64.html">MinidumpContextMIPS64</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:a4a60bac7e9f929110e53e544769b1a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a context structure contains expected values.  <br /></td></tr>
<tr class="separator:a4a60bac7e9f929110e53e544769b1a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582f7e99ce53a1132cfaa247245011d5" id="r_a582f7e99ce53a1132cfaa247245011d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a582f7e99ce53a1132cfaa247245011d5">ExpectMinidumpContextRISCV64</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextRISCV64.html">MinidumpContextRISCV64</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:a582f7e99ce53a1132cfaa247245011d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via Google Test assertions, that a context structure contains expected values.  <br /></td></tr>
<tr class="separator:a582f7e99ce53a1132cfaa247245011d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a623baebebe1cf76d4ddcd1ba30116587" id="r_a623baebebe1cf76d4ddcd1ba30116587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a623baebebe1cf76d4ddcd1ba30116587">InitializeCPUContextX86Fxsave</a> (<a class="el" href="structcrashpad_1_1CPUContextX86_1_1Fxsave.html">CPUContextX86::Fxsave</a> *fxsave, uint32_t *seed)</td></tr>
<tr class="memdesc:a623baebebe1cf76d4ddcd1ba30116587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <code>fxsave</code> context substructure for testing.  <br /></td></tr>
<tr class="separator:a623baebebe1cf76d4ddcd1ba30116587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d029ec1724e63a58007a8705975df23" id="r_a5d029ec1724e63a58007a8705975df23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d029ec1724e63a58007a8705975df23">InitializeCPUContextX86_64Fxsave</a> (<a class="el" href="structcrashpad_1_1CPUContextX86__64_1_1Fxsave.html">CPUContextX86_64::Fxsave</a> *fxsave, uint32_t *seed)</td></tr>
<tr class="memdesc:a5d029ec1724e63a58007a8705975df23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <code>fxsave</code> context substructure for testing.  <br /></td></tr>
<tr class="separator:a5d029ec1724e63a58007a8705975df23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adfb5c0e6e1c121bdac4c663a3fa0db06" id="r_adfb5c0e6e1c121bdac4c663a3fa0db06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb5c0e6e1c121bdac4c663a3fa0db06">InitializeCPUContextX86</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:adfb5c0e6e1c121bdac4c663a3fa0db06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:adfb5c0e6e1c121bdac4c663a3fa0db06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea06b36ac8ee94add2d8aaca404265c" id="r_a9ea06b36ac8ee94add2d8aaca404265c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ea06b36ac8ee94add2d8aaca404265c">InitializeCPUContextX86_64</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a9ea06b36ac8ee94add2d8aaca404265c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:a9ea06b36ac8ee94add2d8aaca404265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb36af9be12b2c03dde22a32f0e023ad" id="r_abb36af9be12b2c03dde22a32f0e023ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb36af9be12b2c03dde22a32f0e023ad">InitializeCPUContextARM</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:abb36af9be12b2c03dde22a32f0e023ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:abb36af9be12b2c03dde22a32f0e023ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c3bc73eecce97b3e7c13bdf6cfa29b" id="r_a68c3bc73eecce97b3e7c13bdf6cfa29b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68c3bc73eecce97b3e7c13bdf6cfa29b">InitializeCPUContextARM64</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a68c3bc73eecce97b3e7c13bdf6cfa29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:a68c3bc73eecce97b3e7c13bdf6cfa29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a59e291e8858eea7c75b7a3de50b89b" id="r_a6a59e291e8858eea7c75b7a3de50b89b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a59e291e8858eea7c75b7a3de50b89b">InitializeCPUContextMIPS</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a6a59e291e8858eea7c75b7a3de50b89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:a6a59e291e8858eea7c75b7a3de50b89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f907e2e405f38c11c2829c229ba080e" id="r_a4f907e2e405f38c11c2829c229ba080e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f907e2e405f38c11c2829c229ba080e">InitializeCPUContextMIPS64</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a4f907e2e405f38c11c2829c229ba080e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:a4f907e2e405f38c11c2829c229ba080e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fe3e86ffdff287694013430cc33524" id="r_a81fe3e86ffdff287694013430cc33524"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81fe3e86ffdff287694013430cc33524">InitializeCPUContextRISCV64</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a81fe3e86ffdff287694013430cc33524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <br /></td></tr>
<tr class="separator:a81fe3e86ffdff287694013430cc33524"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0dfcfa3ff8df71290ee2ded56333ddfb" id="r_a0dfcfa3ff8df71290ee2ded56333ddfb"><td class="memItemLeft" align="right" valign="top"><a id="a0dfcfa3ff8df71290ee2ded56333ddfb" name="a0dfcfa3ff8df71290ee2ded56333ddfb"></a>
const std::vector&lt; std::string &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>g_arguments</b></td></tr>
<tr class="separator:a0dfcfa3ff8df71290ee2ded56333ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The testing namespace, for use in test code only. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aaa4835fcb6a4a897b0841b8575789b77" name="aaa4835fcb6a4a897b0841b8575789b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4835fcb6a4a897b0841b8575789b77">&#9670;&#160;</a></span>BytesToHexString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::BytesToHexString </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hexadecimal string corresponding to <em class="arg">bytes</em> and <em class="arg">length</em>. </p>
<p>Example usage: </p><div class="fragment"><div class="line">uint8_t expected[10];</div>
<div class="line">uint8_t observed[10];</div>
<div class="line"><span class="comment">// …</span></div>
<div class="line">EXPECT_EQ(<a class="code hl_function" href="#aaa4835fcb6a4a897b0841b8575789b77">BytesToHexString</a>(observed, std::size(observed)),</div>
<div class="line">          <a class="code hl_function" href="#aaa4835fcb6a4a897b0841b8575789b77">BytesToHexString</a>(expected, std::size(expected)));</div>
<div class="ttc" id="anamespacecrashpad_1_1test_html_aaa4835fcb6a4a897b0841b8575789b77"><div class="ttname"><a href="#aaa4835fcb6a4a897b0841b8575789b77">crashpad::test::BytesToHexString</a></div><div class="ttdeci">std::string BytesToHexString(const void *bytes, size_t length)</div><div class="ttdoc">Returns a hexadecimal string corresponding to bytes and length.</div><div class="ttdef"><b>Definition</b> hex_string.cc:22</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3a9bc67b39f0b394ae33cc4fd36fc73d" name="a3a9bc67b39f0b394ae33cc4fd36fc73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9bc67b39f0b394ae33cc4fd36fc73d">&#9670;&#160;</a></span>CanCreateSymbolicLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::test::CanCreateSymbolicLinks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether it should be possible to create symbolic links. </p>
<p>It is always possible to create symbolic links on POSIX.</p>
<p>On Windows, it is only possible to create symbolic links when running as an administrator, or as a non-administrator when running Windows 10 build 15063 (1703, Creators Update) or later, provided that developer mode is enabled and <code>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</code> is used. This function tests the creation of a symbolic link and returns true on success, and false on failure. If the symbolic link could not be created for a reason other than the expected lack of privilege, a message is logged.</p>
<p>Additional background: <a href="https://blogs.windows.com/buildingapps/2016/12/02/symlinks-windows-10/">Symlinks in Windows 10!</a> </p>

</div>
</div>
<a id="ae3fb90bfe915d400207c2a370f93fcc1" name="ae3fb90bfe915d400207c2a370f93fcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fb90bfe915d400207c2a370f93fcc1">&#9670;&#160;</a></span>CreateSymbolicLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::test::CreateSymbolicLink </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>target_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>symlink_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new symbolic link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_path</td><td>The target for the link. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symlink_path</td><td>The name for the new link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise <code>false</code> with a message logged. </dd></dl>

</div>
</div>
<a id="ab80403780da9c07617b44d8d7db7c618" name="ab80403780da9c07617b44d8d7db7c618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80403780da9c07617b44d8d7db7c618">&#9670;&#160;</a></span>DyldGetAllImageInfos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const dyld_all_image_infos * crashpad::test::DyldGetAllImageInfos </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls or emulates the <code>_dyld_get_all_image_infos()</code> private/internal function. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this process’ dyld_all_image_infos structure, or <code>nullptr</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a8d8e66fbc47a4f22a03710797f226238" name="a8d8e66fbc47a4f22a03710797f226238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8e66fbc47a4f22a03710797f226238">&#9670;&#160;</a></span>ErrnoMessage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ErrnoMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats an error message using <code>errno</code>. </p>
<p>The returned string will combine the <em class="arg">base</em> string, if supplied, with a textual and numeric description of the error.</p>
<p>The message is formatted using <code>strerror()</code>. <code>errno</code> may be <code>0</code> or outside of the range of known error codes, and the message returned will contain the string that <code>strerror()</code> uses in these cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"Operation not permitted (1)"</code> if <code>errno</code> has the value <code>EPERM</code> on a system where this is defined to be <code>1</code>. If <em class="arg">base</em> is not empty, it will be prepended to this string, separated by a colon. </dd></dl>

</div>
</div>
<a id="ad9504862c089964763d7d362572c2ac6" name="ad9504862c089964763d7d362572c2ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9504862c089964763d7d362572c2ac6">&#9670;&#160;</a></span>ErrnoMessage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ErrnoMessage </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats an error message using an <code>errno</code> value. </p>
<p>The returned string will combine the <em class="arg">base</em> string, if supplied, with a textual and numeric description of the error.</p>
<p>The message is formatted using <code>strerror()</code>. <em class="arg">err</em> may be <code>0</code> or outside of the range of known error codes, and the message returned will contain the string that <code>strerror()</code> uses in these cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>The error code, usable as an <code>errno</code> value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"Operation not permitted (1)"</code> if <em class="arg">err</em> has the value <code>EPERM</code> on a system where this is defined to be <code>1</code>. If <em class="arg">base</em> is not empty, it will be prepended to this string, separated by a colon. </dd></dl>

</div>
</div>
<a id="a2d079e80aa56bc0840f1c0b944e01bfb" name="a2d079e80aa56bc0840f1c0b944e01bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d079e80aa56bc0840f1c0b944e01bfb">&#9670;&#160;</a></span>ErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ErrorMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats an error message using <code>GetLastError()</code>. </p>
<p>The returned string will combine the <em class="arg">base</em> string, if supplied, with a textual and numeric description of the error. The format is the same as the <code>PLOG()</code> formatting in base. </p>

</div>
</div>
<a id="ac5b85697010c624299be8ac6192cc3ed" name="ac5b85697010c624299be8ac6192cc3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b85697010c624299be8ac6192cc3ed">&#9670;&#160;</a></span>ExpectMinidumpContextAMD64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextAMD64 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>expect_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html">MinidumpContextAMD64</a> *</td>          <td class="paramname"><span class="paramname"><em>observed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>snapshot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em class="arg">expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em class="arg">observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot. If <code>false</code>, compare <em class="arg">observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b4484ecca982bdc773e4b302f6b4a4" name="a64b4484ecca982bdc773e4b302f6b4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b4484ecca982bdc773e4b302f6b4a4">&#9670;&#160;</a></span>ExpectMinidumpContextARM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextARM </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>expect_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextARM.html">MinidumpContextARM</a> *</td>          <td class="paramname"><span class="paramname"><em>observed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>snapshot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em class="arg">expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em class="arg">observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot. If <code>false</code>, compare <em class="arg">observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60df6310bda73150339e10aca2a52bbc" name="a60df6310bda73150339e10aca2a52bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60df6310bda73150339e10aca2a52bbc">&#9670;&#160;</a></span>ExpectMinidumpContextARM64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextARM64 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>expect_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextARM64.html">MinidumpContextARM64</a> *</td>          <td class="paramname"><span class="paramname"><em>observed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>snapshot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em class="arg">expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em class="arg">observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot. If <code>false</code>, compare <em class="arg">observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a562b93f75f01cc502822a7273265a5e4" name="a562b93f75f01cc502822a7273265a5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562b93f75f01cc502822a7273265a5e4">&#9670;&#160;</a></span>ExpectMinidumpContextMIPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextMIPS </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>expect_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextMIPS.html">MinidumpContextMIPS</a> *</td>          <td class="paramname"><span class="paramname"><em>observed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>snapshot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em class="arg">expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em class="arg">observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot. If <code>false</code>, compare <em class="arg">observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a60bac7e9f929110e53e544769b1a8d" name="a4a60bac7e9f929110e53e544769b1a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a60bac7e9f929110e53e544769b1a8d">&#9670;&#160;</a></span>ExpectMinidumpContextMIPS64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextMIPS64 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>expect_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextMIPS64.html">MinidumpContextMIPS64</a> *</td>          <td class="paramname"><span class="paramname"><em>observed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>snapshot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em class="arg">expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em class="arg">observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot. If <code>false</code>, compare <em class="arg">observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a582f7e99ce53a1132cfaa247245011d5" name="a582f7e99ce53a1132cfaa247245011d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582f7e99ce53a1132cfaa247245011d5">&#9670;&#160;</a></span>ExpectMinidumpContextRISCV64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextRISCV64 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>expect_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextRISCV64.html">MinidumpContextRISCV64</a> *</td>          <td class="paramname"><span class="paramname"><em>observed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>snapshot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em class="arg">expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em class="arg">observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot. If <code>false</code>, compare <em class="arg">observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a774c6adc6455eb01f0595262c1ce7df9" name="a774c6adc6455eb01f0595262c1ce7df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774c6adc6455eb01f0595262c1ce7df9">&#9670;&#160;</a></span>ExpectMinidumpContextX86()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextX86 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>expect_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *</td>          <td class="paramname"><span class="paramname"><em>observed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>snapshot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em class="arg">expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em class="arg">observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot. If <code>false</code>, compare <em class="arg">observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d907f190db31282e6c8a08df38f7f3f" name="a5d907f190db31282e6c8a08df38f7f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d907f190db31282e6c8a08df38f7f3f">&#9670;&#160;</a></span>ExpectMinidumpMemoryDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpMemoryDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *</td>          <td class="paramname"><span class="paramname"><em>expected</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *</td>          <td class="paramname"><span class="paramname"><em>observed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values. </p>
<p>In <em class="arg">expected</em> and <em class="arg">observed</em>, <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html#ac6d589aa4a3b82315866f2a27bee770c" title="The base address of the memory region in the address space of the process that the minidump file cont...">MINIDUMP_MEMORY_DESCRIPTOR::StartOfMemoryRange</a> and <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html#ad83430521d4a8991d85e06be61525a92" title="The size of the referenced structure or union, in bytes.">MINIDUMP_LOCATION_DESCRIPTOR::DataSize</a> are compared and must match. If <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html#ae877992492577366d7185721b8239877" title="The relative virtual address of the structure or union within the minidump file.">MINIDUMP_LOCATION_DESCRIPTOR::Rva</a> is nonzero in <em class="arg">expected</em>, the same field in <em class="arg">observed</em> must match it, subject to a 16-byte alignment augmentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing expected values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing observed values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bcb7b725b62a0058c18e0851a1adf5c" name="a7bcb7b725b62a0058c18e0851a1adf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcb7b725b62a0058c18e0851a1adf5c">&#9670;&#160;</a></span>ExpectMinidumpMemoryDescriptorAndContents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpMemoryDescriptorAndContents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *</td>          <td class="paramname"><span class="paramname"><em>expected</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *</td>          <td class="paramname"><span class="paramname"><em>observed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>at_eof</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values, and that the memory region it points to contains expected values assuming it was written by a <a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html" title="A SnapshotMinidumpMemoryWriter implementation used for testing.">TestMinidumpMemoryWriter</a> object. </p>
<p><em class="arg">expected</em> and <em class="arg">observed</em> are compared by <a class="el" href="#a5d907f190db31282e6c8a08df38f7f3f" title="Verifies, via Google Test assertions, that a MINIDUMP_MEMORY_DESCRIPTOR structure contains expected v...">ExpectMinidumpMemoryDescriptor()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing expected values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file.">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing observed values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file in which <em class="arg">observed</em> was found. The memory region referenced by <em class="arg">observed</em> will be read from this string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <em class="arg">value</em> used to create a <a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html" title="A SnapshotMinidumpMemoryWriter implementation used for testing.">TestMinidumpMemoryWriter</a>. Each byte of memory in the region referenced by <em class="arg">observed</em> must be this value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">at_eof</td><td>If <code>true</code>, the region referenced by <em class="arg">observed</em> must appear at the end of <em class="arg">file_contents</em>, without any data following it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cad311e386c21af1ca653f2aca2695b" name="a8cad311e386c21af1ca653f2aca2695b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cad311e386c21af1ca653f2aca2695b">&#9670;&#160;</a></span>FileExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::test::FileExists </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a file exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to check for existence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em class="arg">path</em> exists. <code>false</code> if it does not exist. If an error other than “file not found” occurs when searching for <em class="arg">path</em>, returns <code>false</code> with a Google Test failure added. </dd></dl>

</div>
</div>
<a id="a897d99ec1dd2c343d29a3d14e3560732" name="a897d99ec1dd2c343d29a3d14e3560732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897d99ec1dd2c343d29a3d14e3560732">&#9670;&#160;</a></span>FileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecrashpad.html#a73e870ea9156f1bfdff1b998a77cdd9e">FileOffset</a> crashpad::test::FileSize </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the size of a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path of the file to check. The file must exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the file at <em class="arg">path</em>. If the file does not exist, or an error occurs when attempting to determine its size, returns <code>-1</code> with a Google Test failure added. </dd></dl>

</div>
</div>
<a id="a04f9df0a866217f549d350e196488558" name="a04f9df0a866217f549d350e196488558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f9df0a866217f549d350e196488558">&#9670;&#160;</a></span>GetMainArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; crashpad::test::GetMainArguments </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves pointers to the arguments to <code>main()</code>. </p>
<p>Tests that need to access the original values of a test program’s <code>main()</code> function’s parameters at process creation can use this function to retrieve them, provided that <code>main()</code> called <a class="el" href="#a39568e00a9e49cda7938f6154b1264cf" title="Saves the arguments to main() for later use.">InitializeMainArguments()</a> before making any changes to its arguments. </p>

</div>
</div>
<a id="abb36af9be12b2c03dde22a32f0e023ad" name="abb36af9be12b2c03dde22a32f0e023ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb36af9be12b2c03dde22a32f0e023ad">&#9670;&#160;</a></span>InitializeCPUContextARM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextARM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing.">InitializeMinidumpContextX86()</a> and <a class="el" href="#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing.">InitializeMinidumpContextAMD64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union.">CPUContext::architecture</a> field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68c3bc73eecce97b3e7c13bdf6cfa29b" name="a68c3bc73eecce97b3e7c13bdf6cfa29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c3bc73eecce97b3e7c13bdf6cfa29b">&#9670;&#160;</a></span>InitializeCPUContextARM64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextARM64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing.">InitializeMinidumpContextX86()</a> and <a class="el" href="#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing.">InitializeMinidumpContextAMD64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union.">CPUContext::architecture</a> field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a59e291e8858eea7c75b7a3de50b89b" name="a6a59e291e8858eea7c75b7a3de50b89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a59e291e8858eea7c75b7a3de50b89b">&#9670;&#160;</a></span>InitializeCPUContextMIPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextMIPS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing.">InitializeMinidumpContextX86()</a> and <a class="el" href="#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing.">InitializeMinidumpContextAMD64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union.">CPUContext::architecture</a> field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f907e2e405f38c11c2829c229ba080e" name="a4f907e2e405f38c11c2829c229ba080e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f907e2e405f38c11c2829c229ba080e">&#9670;&#160;</a></span>InitializeCPUContextMIPS64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextMIPS64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing.">InitializeMinidumpContextX86()</a> and <a class="el" href="#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing.">InitializeMinidumpContextAMD64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union.">CPUContext::architecture</a> field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81fe3e86ffdff287694013430cc33524" name="a81fe3e86ffdff287694013430cc33524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fe3e86ffdff287694013430cc33524">&#9670;&#160;</a></span>InitializeCPUContextRISCV64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextRISCV64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing.">InitializeMinidumpContextX86()</a> and <a class="el" href="#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing.">InitializeMinidumpContextAMD64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union.">CPUContext::architecture</a> field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfb5c0e6e1c121bdac4c663a3fa0db06" name="adfb5c0e6e1c121bdac4c663a3fa0db06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb5c0e6e1c121bdac4c663a3fa0db06">&#9670;&#160;</a></span>InitializeCPUContextX86()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing.">InitializeMinidumpContextX86()</a> and <a class="el" href="#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing.">InitializeMinidumpContextAMD64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union.">CPUContext::architecture</a> field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ea06b36ac8ee94add2d8aaca404265c" name="a9ea06b36ac8ee94add2d8aaca404265c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea06b36ac8ee94add2d8aaca404265c">&#9670;&#160;</a></span>InitializeCPUContextX86_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing.">InitializeMinidumpContextX86()</a> and <a class="el" href="#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing.">InitializeMinidumpContextAMD64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union.">CPUContext::architecture</a> field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d029ec1724e63a58007a8705975df23" name="a5d029ec1724e63a58007a8705975df23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d029ec1724e63a58007a8705975df23">&#9670;&#160;</a></span>InitializeCPUContextX86_64Fxsave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86_64Fxsave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContextX86__64_1_1Fxsave.html">CPUContextX86_64::Fxsave</a> *</td>          <td class="paramname"><span class="paramname"><em>fxsave</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an <code>fxsave</code> context substructure for testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fxsave</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">seed</td><td>The seed value. Initializing two <code>fxsave</code> structures of the same type with identical seed values should produce identical structures. Initialization with a different seed value should produce a different <code>fxsave</code> structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">fxsave</em> is zeroed out entirely. If <em class="arg">seed</em> is nonzero, <em class="arg">fxsave</em> will be populated entirely with nonzero values. <em class="arg">seed</em> will be updated by this function to allow the caller to perform subsequent initialization of the context structure containing <em class="arg">fxsave</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a623baebebe1cf76d4ddcd1ba30116587" name="a623baebebe1cf76d4ddcd1ba30116587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623baebebe1cf76d4ddcd1ba30116587">&#9670;&#160;</a></span>InitializeCPUContextX86Fxsave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86Fxsave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContextX86_1_1Fxsave.html">CPUContextX86::Fxsave</a> *</td>          <td class="paramname"><span class="paramname"><em>fxsave</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an <code>fxsave</code> context substructure for testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fxsave</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">seed</td><td>The seed value. Initializing two <code>fxsave</code> structures of the same type with identical seed values should produce identical structures. Initialization with a different seed value should produce a different <code>fxsave</code> structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">fxsave</em> is zeroed out entirely. If <em class="arg">seed</em> is nonzero, <em class="arg">fxsave</em> will be populated entirely with nonzero values. <em class="arg">seed</em> will be updated by this function to allow the caller to perform subsequent initialization of the context structure containing <em class="arg">fxsave</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39568e00a9e49cda7938f6154b1264cf" name="a39568e00a9e49cda7938f6154b1264cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39568e00a9e49cda7938f6154b1264cf">&#9670;&#160;</a></span>InitializeMainArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMainArguments </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the arguments to <code>main()</code> for later use. </p>
<p>Call this function from a test program’s <code>main()</code> function so that tests that require access to these variables can retrieve them from <a class="el" href="#a04f9df0a866217f549d350e196488558" title="Retrieves pointers to the arguments to main().">GetMainArguments()</a>.</p>
<p>The contents of <em class="arg">argv</em>, limited to <em class="arg">argc</em> elements, will be copied, so that subsequent modifications to these variables by <code>main()</code> will not affect the state returned by <a class="el" href="#a04f9df0a866217f549d350e196488558" title="Retrieves pointers to the arguments to main().">GetMainArguments()</a>.</p>
<p>This function must be called exactly once during the lifetime of a test program. </p>

</div>
</div>
<a id="afa1dd7166c73ca082608b1ab21b5a395" name="afa1dd7166c73ca082608b1ab21b5a395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1dd7166c73ca082608b1ab21b5a395">&#9670;&#160;</a></span>InitializeMinidumpContextAMD64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextAMD64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextAMD64.html">MinidumpContextAMD64</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> test initialization functions such as <a class="el" href="#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing.">InitializeCPUContextX86()</a> and <a class="el" href="#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing.">InitializeCPUContextX86_64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2906dd1369f589786ada460e0675f1e1" name="a2906dd1369f589786ada460e0675f1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2906dd1369f589786ada460e0675f1e1">&#9670;&#160;</a></span>InitializeMinidumpContextARM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextARM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextARM.html">MinidumpContextARM</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> test initialization functions such as <a class="el" href="#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing.">InitializeCPUContextX86()</a> and <a class="el" href="#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing.">InitializeCPUContextX86_64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a129b18c1aea376834602a7b249cd48fd" name="a129b18c1aea376834602a7b249cd48fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129b18c1aea376834602a7b249cd48fd">&#9670;&#160;</a></span>InitializeMinidumpContextARM64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextARM64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextARM64.html">MinidumpContextARM64</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> test initialization functions such as <a class="el" href="#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing.">InitializeCPUContextX86()</a> and <a class="el" href="#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing.">InitializeCPUContextX86_64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e83478949a9c662428b5013f7745767" name="a4e83478949a9c662428b5013f7745767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e83478949a9c662428b5013f7745767">&#9670;&#160;</a></span>InitializeMinidumpContextMIPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextMIPS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextMIPS.html">MinidumpContextMIPS</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> test initialization functions such as <a class="el" href="#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing.">InitializeCPUContextX86()</a> and <a class="el" href="#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing.">InitializeCPUContextX86_64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3e7f1aab1bec394086f3bc88f6c3c1a" name="ae3e7f1aab1bec394086f3bc88f6c3c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e7f1aab1bec394086f3bc88f6c3c1a">&#9670;&#160;</a></span>InitializeMinidumpContextMIPS64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextMIPS64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextMIPS.html">MinidumpContextMIPS</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> test initialization functions such as <a class="el" href="#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing.">InitializeCPUContextX86()</a> and <a class="el" href="#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing.">InitializeCPUContextX86_64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4238891476dd3c0a88d838027080d081" name="a4238891476dd3c0a88d838027080d081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4238891476dd3c0a88d838027080d081">&#9670;&#160;</a></span>InitializeMinidumpContextRISCV64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextRISCV64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextRISCV64.html">MinidumpContextRISCV64</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> test initialization functions such as <a class="el" href="#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing.">InitializeCPUContextX86()</a> and <a class="el" href="#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing.">InitializeCPUContextX86_64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afefac1494b6a67c50a254c75a8caccf1" name="afefac1494b6a67c50a254c75a8caccf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefac1494b6a67c50a254c75a8caccf1">&#9670;&#160;</a></span>InitializeMinidumpContextX86()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextX86 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture.">CPUContext</a> test initialization functions such as <a class="el" href="#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing.">InitializeCPUContextX86()</a> and <a class="el" href="#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing.">InitializeCPUContextX86_64()</a> for identical <em class="arg">seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em class="arg">seed</em> is <code>0</code>, <em class="arg">context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em class="arg">seed</em> is nonzero, <em class="arg">context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2dc6af450dc4cd4fa937c99665222f9" name="ac2dc6af450dc4cd4fa937c99665222f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dc6af450dc4cd4fa937c99665222f9">&#9670;&#160;</a></span>IOSLaunchApplicationAndRunTests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::IOSLaunchApplicationAndRunTests </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs all registered tests in the context of a UIKit application. </p>
<p>Invokes UIApplicationMain() to launch the iOS application and runs all registered tests after the application finishes launching. UIApplicationMain() brings up the main runloop and never returns, so therefore this function never returns either. It invokes _exit() to terminate the application after tests have completed. </p>

</div>
</div>
<a id="a4f42c5d290ec3dc2dbae82b56a806fac" name="a4f42c5d290ec3dc2dbae82b56a806fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f42c5d290ec3dc2dbae82b56a806fac">&#9670;&#160;</a></span>LoadTestModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrashpad_1_1test_1_1ScopedModuleHandle.html">ScopedModuleHandle</a> crashpad::test::LoadTestModule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>module_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>module_soname</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and loads a test module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module_name</td><td>The filename of the mdoule. </td></tr>
    <tr><td class="paramname">module_soname</td><td>The SONAME for the module. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the loaded module on success. On failure, the handle will be invalid and a message will be logged. </dd></dl>

</div>
</div>
<a id="a49a7a2461cf4e1f674eac147c19d9483" name="a49a7a2461cf4e1f674eac147c19d9483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a7a2461cf4e1f674eac147c19d9483">&#9670;&#160;</a></span>MachErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::MachErrorMessage </td>
          <td>(</td>
          <td class="paramtype">mach_error_t</td>          <td class="paramname"><span class="paramname"><em>mach_err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a Mach error message. </p>
<p>The returned string will combine the <em class="arg">base</em> string, if supplied, with a textual and numeric description of the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mach_err</td><td>The Mach error code, which may be a <code>kern_return_t</code> or related type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"(os/kern) invalid address (1)"</code> if <em class="arg">mach_err</em> has the value <code>KERN_INVALID_ADDRESS</code> on a system where this is defined to be 1. If <em class="arg">base</em> is not empty, it will be prepended to this string, separated by a colon. </dd></dl>

</div>
</div>
<a id="a792154d99d868c18ba566d01d20be2cc" name="a792154d99d868c18ba566d01d20be2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792154d99d868c18ba566d01d20be2cc">&#9670;&#160;</a></span>MinidumpByteArrayAtRVA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; crashpad::test::MinidumpByteArrayAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a></td>          <td class="paramname"><span class="paramname"><em>rva</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bytes referenced by a <a class="el" href="structcrashpad_1_1MinidumpByteArray.html" title="A variable-length array of bytes carried within a minidump file. The data have no intrinsic type and ...">MinidumpByteArray</a> object located in a minidump file at the specified <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8" title="An offset within a minidump file, relative to the start of its MINIDUMP_HEADER.">RVA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset in the minidump file of the <a class="el" href="structcrashpad_1_1MinidumpByteArray.html" title="A variable-length array of bytes carried within a minidump file. The data have no intrinsic type and ...">MinidumpByteArray</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structcrashpad_1_1MinidumpByteArray.html#aec012e2ccbbcf2bb88b7f18d26d1b1a8" title="The bytes of data.">MinidumpByteArray::data</a> referenced by the <em class="arg">rva</em>. Note that this function does not check that the data are within the bounds of the <em class="arg">file_contents</em>. </dd></dl>

</div>
</div>
<a id="a68bb97f184e9e5a41356a960fdaf3320" name="a68bb97f184e9e5a41356a960fdaf3320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bb97f184e9e5a41356a960fdaf3320">&#9670;&#160;</a></span>MinidumpHeaderAtStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> * crashpad::test::MinidumpHeaderAtStart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__DIRECTORY.html">MINIDUMP_DIRECTORY</a> **</td>          <td class="paramname"><span class="paramname"><em>directory</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file.">MINIDUMP_HEADER</a> at the start of a minidump file, along with the <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file.">MINIDUMP_DIRECTORY</a> it references. </p>
<p>This function validates the <a class="el" href="structMINIDUMP__HEADER.html#ae1c77644aa56ab70fd6f50c343eafda8" title="The minidump file format magic number, MINIDUMP_SIGNATURE.">MINIDUMP_HEADER::Signature</a> and <a class="el" href="structMINIDUMP__HEADER.html#a7ea8d51f5ca990eec9eb0b3643c6b406" title="The minidump file format version number, MINIDUMP_VERSION.">MINIDUMP_HEADER::Version</a> fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">directory</td><td>The <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file.">MINIDUMP_DIRECTORY</a> referenced by the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file.">MINIDUMP_HEADER</a>. If the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file.">MINIDUMP_HEADER</a> does not reference a <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file.">MINIDUMP_DIRECTORY</a>, <code>nullptr</code> without raising a Google Test assertion. If the referenced <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file.">MINIDUMP_DIRECTORY</a> is not valid, <code>nullptr</code> with a Google Test assertion raised. On failure, <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file.">MINIDUMP_HEADER</a> at the beginning of the minidump file. On failure, raises a Google Test assertion and returns <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a1a3936c22f43c2defcaa16e7c09ce544" name="a1a3936c22f43c2defcaa16e7c09ce544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3936c22f43c2defcaa16e7c09ce544">&#9670;&#160;</a></span>MinidumpRVAListAtStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcrashpad_1_1MinidumpRVAList.html">MinidumpRVAList</a> * crashpad::test::MinidumpRVAListAtStart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structcrashpad_1_1MinidumpRVAList.html" title="A list of RVA pointers.">MinidumpRVAList</a> at the start of a minidump file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8" title="An offset within a minidump file, relative to the start of its MINIDUMP_HEADER.">RVA</a> objects expected in the <a class="el" href="structcrashpad_1_1MinidumpRVAList.html" title="A list of RVA pointers.">MinidumpRVAList</a>. This function will only be successful if exactly this many objects are present, and if space for them exists in <em class="arg">file_contents</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the <a class="el" href="structcrashpad_1_1MinidumpRVAList.html" title="A list of RVA pointers.">MinidumpRVAList</a> at the beginning of the file. On failure, raises a Google Test assertion and returns <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a527731a826e40dd36ac112e7cd3dfcd2" name="a527731a826e40dd36ac112e7cd3dfcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527731a826e40dd36ac112e7cd3dfcd2">&#9670;&#160;</a></span>MinidumpStringAtRVA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a> * crashpad::test::MinidumpStringAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a></td>          <td class="paramname"><span class="paramname"><em>rva</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file.">MINIDUMP_STRING</a> located within a minidump file’s contents. </p>
<p>If <em class="arg">rva</em> points outside of the range of <em class="arg">file_contents</em>, if the string has an incorrect length or is not <code>NUL</code>-terminated, or if any of the string data would lie outside of the range of <em class="arg">file_contents</em>, this function will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file.">MINIDUMP_STRING</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file.">MINIDUMP_STRING</a> in <em class="arg">file_contents</em>. On failure, raises a Google Test assertion and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5777a4692213162a65910c17778a2c29" title="Returns the contents of a MINIDUMP_STRING as a std::u16string.">MinidumpStringAtRVAAsString()</a> </dd>
<dd>
<a class="el" href="#a9f5bbb381b32ca4c5276a5aacbef1c5f" title="Returns a MinidumpUTF8String located within a minidump file’s contents.">MinidumpUTF8StringAtRVA()</a> </dd></dl>

</div>
</div>
<a id="a5777a4692213162a65910c17778a2c29" name="a5777a4692213162a65910c17778a2c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5777a4692213162a65910c17778a2c29">&#9670;&#160;</a></span>MinidumpStringAtRVAAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::u16string crashpad::test::MinidumpStringAtRVAAsString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a></td>          <td class="paramname"><span class="paramname"><em>rva</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file.">MINIDUMP_STRING</a> as a <code>std::u16string</code>. </p>
<p>This function uses <a class="el" href="#a527731a826e40dd36ac112e7cd3dfcd2" title="Returns a MINIDUMP_STRING located within a minidump file’s contents.">MinidumpStringAtRVA()</a> to obtain a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file.">MINIDUMP_STRING</a>, and returns the string data as a <code>std::u16string</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file.">MINIDUMP_STRING</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the string read from <em class="arg">file_writer</em> at offset <em class="arg">rva</em>. On failure, raises a Google Test assertion and returns an empty string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4d8f1de3f021881b6464a1fedbddf956" title="Returns the contents of a MinidumpUTF8String as a std::string.">MinidumpUTF8StringAtRVAAsString()</a> </dd></dl>

</div>
</div>
<a id="a9f5bbb381b32ca4c5276a5aacbef1c5f" name="a9f5bbb381b32ca4c5276a5aacbef1c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5bbb381b32ca4c5276a5aacbef1c5f">&#9670;&#160;</a></span>MinidumpUTF8StringAtRVA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html">MinidumpUTF8String</a> * crashpad::test::MinidumpUTF8StringAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a></td>          <td class="paramname"><span class="paramname"><em>rva</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file.">MinidumpUTF8String</a> located within a minidump file’s contents. </p>
<p>If <em class="arg">rva</em> points outside of the range of <em class="arg">file_contents</em>, if the string has an incorrect length or is not <code>NUL</code>-terminated, or if any of the string data would lie outside of the range of <em class="arg">file_contents</em>, this function will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file.">MinidumpUTF8String</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file.">MinidumpUTF8String</a> in <em class="arg">file_contents</em>. On failure, raises a Google Test assertion and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4d8f1de3f021881b6464a1fedbddf956" title="Returns the contents of a MinidumpUTF8String as a std::string.">MinidumpUTF8StringAtRVAAsString()</a> </dd>
<dd>
<a class="el" href="#a527731a826e40dd36ac112e7cd3dfcd2" title="Returns a MINIDUMP_STRING located within a minidump file’s contents.">MinidumpStringAtRVA()</a> </dd></dl>

</div>
</div>
<a id="a4d8f1de3f021881b6464a1fedbddf956" name="a4d8f1de3f021881b6464a1fedbddf956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8f1de3f021881b6464a1fedbddf956">&#9670;&#160;</a></span>MinidumpUTF8StringAtRVAAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::MinidumpUTF8StringAtRVAAsString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a></td>          <td class="paramname"><span class="paramname"><em>rva</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file.">MinidumpUTF8String</a> as a <code>std::string</code>. </p>
<p>This function uses <a class="el" href="#a9f5bbb381b32ca4c5276a5aacbef1c5f" title="Returns a MinidumpUTF8String located within a minidump file’s contents.">MinidumpUTF8StringAtRVA()</a> to obtain a <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file.">MinidumpUTF8String</a>, and returns the string data as a <code>std::string</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structcrashpad_1_1MinidumpUTF8String.html" title="A variable-length UTF-8-encoded string carried within a minidump file.">MinidumpUTF8String</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the string read from <em class="arg">file_writer</em> at offset <em class="arg">rva</em>. On failure, raises a Google Test assertion and returns an empty string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5777a4692213162a65910c17778a2c29" title="Returns the contents of a MINIDUMP_STRING as a std::u16string.">MinidumpStringAtRVAAsString()</a> </dd></dl>

</div>
</div>
<a id="a6a17a529d0d0e415a8290530e8797b9e" name="a6a17a529d0d0e415a8290530e8797b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a17a529d0d0e415a8290530e8797b9e">&#9670;&#160;</a></span>MinidumpWritableAtLocationDescriptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * crashpad::test::MinidumpWritableAtLocationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known. </p>
<p>This function has template specializations that perform more stringent checking than the default implementation:</p><ul>
<li>With a <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file.">MINIDUMP_HEADER</a> template parameter, a template specialization ensures that the structure’s magic number and version fields are correct.</li>
<li>With a <a class="el" href="structMINIDUMP__MEMORY__LIST.html" title="Information about memory regions within the process.">MINIDUMP_MEMORY_LIST</a>, <a class="el" href="structMINIDUMP__THREAD__LIST.html" title="Information about all threads within the process.">MINIDUMP_THREAD_LIST</a>, <a class="el" href="structMINIDUMP__THREAD__NAME__LIST.html" title="Variable-sized struct which contains a list of MINIDUMP_THREAD_NAME structs.">MINIDUMP_THREAD_NAME_LIST</a>, <a class="el" href="structMINIDUMP__MODULE__LIST.html" title="Information about all modules loaded within the process at the time the snapshot was taken.">MINIDUMP_MODULE_LIST</a>, <a class="el" href="structMINIDUMP__MEMORY__INFO__LIST.html" title="Contains a list of memory regions.">MINIDUMP_MEMORY_INFO_LIST</a>, <a class="el" href="structcrashpad_1_1MinidumpSimpleStringDictionary.html" title="A list of key-value pairs.">MinidumpSimpleStringDictionary</a>, or <a class="el" href="structcrashpad_1_1MinidumpAnnotationList.html" title="A list of annotation objects.">MinidumpAnnotationList</a> template parameter, template specializations ensure that the size given by <em class="arg">location</em> matches the size expected of a stream containing the number of elements it claims to have.</li>
<li>With an <a class="el" href="structIMAGE__DEBUG__MISC.html" title="Miscellaneous debugging record.">IMAGE_DEBUG_MISC</a>, <a class="el" href="structcrashpad_1_1CodeViewRecordPDB20.html" title="A CodeView record linking to a .pdb 2.0 file.">CodeViewRecordPDB20</a>, or <a class="el" href="structcrashpad_1_1CodeViewRecordPDB70.html" title="A CodeView record linking to a .pdb 7.0 file.">CodeViewRecordPDB70</a> template parameter, template specializations ensure that the structure has the expected format including any magic number and the <code>NUL</code>- terminated string.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>A <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html" title="A pointer to a structure or union within a minidump file.">MINIDUMP_LOCATION_DESCRIPTOR</a> giving the offset within the minidump file of the desired object, as well as its size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the size of <em class="arg">location</em> is at least as big as the size of the requested object, and if <em class="arg">location</em> is within the range of <em class="arg">file_contents</em>, returns a pointer into <em class="arg">file_contents</em> at offset <em class="arg">rva</em>. Otherwise, raises a Google Test assertion failure and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aef56904dc505d92e539a949ed5a3621f" title="Returns a typed minidump object located within a minidump file’s contents, where the offset of the ob...">MinidumpWritableAtRVA()</a> </dd></dl>

</div>
</div>
<a id="a5cbb750966dcd4d580ba9eeb51a45fc6" name="a5cbb750966dcd4d580ba9eeb51a45fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbb750966dcd4d580ba9eeb51a45fc6">&#9670;&#160;</a></span>MinidumpWritableAtLocationDescriptorInternal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * crashpad::test::MinidumpWritableAtLocationDescriptorInternal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>expected_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_oversized_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an untyped minidump object located within a minidump file’s contents, where the offset and size of the object are known. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>A <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html" title="A pointer to a structure or union within a minidump file.">MINIDUMP_LOCATION_DESCRIPTOR</a> giving the offset within the minidump file of the desired object, as well as its size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_size</td><td>The expected size of the object. If <em class="arg">allow_oversized_data</em> is <code>true</code>, <em class="arg">expected_size</em> is treated as the minimum size of <em class="arg">location</em>, but it is permitted to be larger. If <em class="arg">allow_oversized_data</em> is <code>false</code>, the size of <em class="arg">location</em> must match <em class="arg">expected_size</em> exactly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_oversized_data</td><td>Controls whether <em class="arg">expected_size</em> is a minimum limit (<code>true</code>) or an exact match is required (<code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the size of <em class="arg">location</em> is agrees with <em class="arg">expected_size</em>, and if <em class="arg">location</em> is within the range of <em class="arg">file_contents</em>, returns a pointer into <em class="arg">file_contents</em> at offset <em class="arg">rva</em>. Otherwise, raises a Google Test assertion failure and returns <code>nullptr</code>.</dd></dl>
<p>Do not call this function. Use the typed version, <a class="el" href="#a6a17a529d0d0e415a8290530e8797b9e" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size ...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a>, or another type-specific function. </p>

</div>
</div>
<a id="a5a95d2d96b45fc476d983a0c2c3b8ab9" name="a5a95d2d96b45fc476d983a0c2c3b8ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a95d2d96b45fc476d983a0c2c3b8ab9">&#9670;&#160;</a></span>MinidumpWritableAtLocationDescriptorInternal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * crashpad::test::MinidumpWritableAtLocationDescriptorInternal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR64.html">MINIDUMP_LOCATION_DESCRIPTOR64</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>expected_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_oversized_data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit specialization of MinidumpWritableAtLocationDescriptorInternal. </p>
<p>Do not call this function. Use the typed version, <a class="el" href="#a6a17a529d0d0e415a8290530e8797b9e" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size ...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a>, or another type-specific function. </p>

</div>
</div>
<a id="aef56904dc505d92e539a949ed5a3621f" name="aef56904dc505d92e539a949ed5a3621f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef56904dc505d92e539a949ed5a3621f">&#9670;&#160;</a></span>MinidumpWritableAtRVA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * crashpad::test::MinidumpWritableAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a></td>          <td class="paramname"><span class="paramname"><em>rva</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a typed minidump object located within a minidump file’s contents, where the offset of the object is known. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em class="arg">rva</em> plus the size of an object of type <em class="arg">T</em> is within the range of <em class="arg">file_contents</em>, returns a pointer into <em class="arg">file_contents</em> at offset <em class="arg">rva</em>. Otherwise, raises a Google Test assertion failure and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6a17a529d0d0e415a8290530e8797b9e" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size ...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> </dd></dl>

</div>
</div>
<a id="a35412b33d0a275fa43e8633296059534" name="a35412b33d0a275fa43e8633296059534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35412b33d0a275fa43e8633296059534">&#9670;&#160;</a></span>ReadStreamToString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ReadStreamToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream from which to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the stream, or an empty string on failure. </dd></dl>

</div>
</div>
<a id="a861ba97c72a60c7e1802c39395d1d1fe" name="a861ba97c72a60c7e1802c39395d1d1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861ba97c72a60c7e1802c39395d1d1fe">&#9670;&#160;</a></span>ReadStreamToString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ReadStreamToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>buffer_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body.">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream from which to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>The size of the buffer to use when reading from the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the stream, or an empty string on failure. </dd></dl>

</div>
</div>
<a id="a489b62007e6118a1addd46674ca4e474" name="a489b62007e6118a1addd46674ca4e474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489b62007e6118a1addd46674ca4e474">&#9670;&#160;</a></span>RemoveFileIfExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::test::RemoveFileIfExists </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a file if it exists, logging a message on failure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the file to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a603da2f249fd4491222cc8d1088c63f6" name="a603da2f249fd4491222cc8d1088c63f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603da2f249fd4491222cc8d1088c63f6">&#9670;&#160;</a></span>SanityCheckContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::SanityCheckContext </td>
          <td>(</td>
          <td class="paramtype">const NativeCPUContext &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sanity check conditions that should be true for any NativeCPUContext produced by <a class="el" href="namespacecrashpad.html#ac25486c6b4c38fc7c7868e978094edcf" title="Saves the CPU context.">CaptureContext()</a>. </p>
<p>If the context structure has fields that tell whether it’s valid, such as magic numbers or size fields, sanity-checks those fields for validity with fatal Google Test assertions. For other fields, where it’s possible to reason about their validity based solely on their contents, sanity-checks via nonfatal Google Test assertions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7e323579fb063cb426c2855bb73d33c" name="af7e323579fb063cb426c2855bb73d33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e323579fb063cb426c2855bb73d33c">&#9670;&#160;</a></span>SetFileModificationTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::test::SetFileModificationTime </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timespec &amp;</td>          <td class="paramname"><span class="paramname"><em>mtime</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the modification time for a file, directory, or symbolic link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the file to set the modification time for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtime</td><td>The new modification time for the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise <code>false</code> with a message logged. </dd></dl>

</div>
</div>
<a id="aed432a39ba3d9fa96dc3a131c9119c40" name="aed432a39ba3d9fa96dc3a131c9119c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed432a39ba3d9fa96dc3a131c9119c40">&#9670;&#160;</a></span>TMinidumpWritableAtLocationDescriptor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * crashpad::test::TMinidumpWritableAtLocationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known. </p>
<p>This function is similar to <a class="el" href="#a6a17a529d0d0e415a8290530e8797b9e" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size ...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> and is used to implement that function. It exists independently so that template specializations are able to call this function, which provides the default implementation.</p>
<p>Do not call this function directly. Use <a class="el" href="#a6a17a529d0d0e415a8290530e8797b9e" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size ...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> instead. </p>

</div>
</div>
<a id="a76d28a5554a694aec7d8dc0fb6c49276" name="a76d28a5554a694aec7d8dc0fb6c49276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d28a5554a694aec7d8dc0fb6c49276">&#9670;&#160;</a></span>TMinidumpWritableAtLocationDescriptor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * crashpad::test::TMinidumpWritableAtLocationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_contents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR64.html">MINIDUMP_LOCATION_DESCRIPTOR64</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit specialization of TMinidumpWritableAtLocationDescriptor. </p>
<p>Do not call this function directly. Use <a class="el" href="#a6a17a529d0d0e415a8290530e8797b9e" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size ...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> instead. </p>

</div>
</div>
<a id="a5e604ee6a23070a89e2a0015eb2854a9" name="a5e604ee6a23070a89e2a0015eb2854a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e604ee6a23070a89e2a0015eb2854a9">&#9670;&#160;</a></span>VerifyMinidumpHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::VerifyMinidumpHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *</td>          <td class="paramname"><span class="paramname"><em>header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>streams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timestamp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via Google Test assertions, that a <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file.">MINIDUMP_HEADER</a> contains expected values. </p>
<p>All fields in the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file.">MINIDUMP_HEADER</a> will be evaluated except for the Signature and Version fields, because those are checked by <a class="el" href="#a68bb97f184e9e5a41356a960fdaf3320" title="Returns the MINIDUMP_HEADER at the start of a minidump file, along with the MINIDUMP_DIRECTORY it ref...">MinidumpHeaderAtStart()</a>. Most other fields are are compared to their correct default values. <a class="el" href="structMINIDUMP__HEADER.html#ac64203d27bba37f630437048a0e19630" title="The number of MINIDUMP_DIRECTORY elements present in the directory referenced by StreamDirectoryRva.">MINIDUMP_HEADER::NumberOfStreams</a> is compared to <em class="arg">streams</em>, and <a class="el" href="structMINIDUMP__HEADER.html#a5f3811a143f2a6405e721d03d8c86f1d" title="The time that the minidump file was generated, in time_t format, the number of seconds since the POSI...">MINIDUMP_HEADER::TimeDateStamp</a> is compared to <em class="arg">timestamp</em>. Most fields are checked with nonfatal EXPECT-style assertions, but <a class="el" href="structMINIDUMP__HEADER.html#ac64203d27bba37f630437048a0e19630" title="The number of MINIDUMP_DIRECTORY elements present in the directory referenced by StreamDirectoryRva.">MINIDUMP_HEADER::NumberOfStreams</a> and <a class="el" href="structMINIDUMP__HEADER.html#afc88b1f46827fbeae6ef6e0718a23b57" title="A pointer to an array of MINIDUMP_DIRECTORY structures that identify all of the streams within this m...">MINIDUMP_HEADER::StreamDirectoryRva</a> are checked with fatal ASSERT-style assertions, because they must be correct in order for processing of the minidump to continue. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecrashpad.html">crashpad</a></li><li class="navelem"><a class="el" href="namespacecrashpad_1_1test.html">test</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
